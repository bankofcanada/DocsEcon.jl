<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Final Conditions · StateSpaceEcon</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="StateSpaceEcon logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">StateSpaceEcon</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../Tutorials/">Introduction</a></li><li><a class="tocitem" href="../../Tutorials/README/">README</a></li><li><a class="tocitem" href="../../Tutorials/1.TimeSeriesEcon/main/">Time Series</a></li><li><a class="tocitem" href="../../Tutorials/2.simple_RBC/main/">Simple RBC Model</a></li><li><a class="tocitem" href="../../Tutorials/3.US_SW07/main/">Smets and Wouters 2007</a></li><li><a class="tocitem" href="../../Tutorials/4.FRB-US/main/">FRB/US</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../Reference/TimeSeriesEcon/">TimeSeriesEcon</a></li><li><a class="tocitem" href="../../Reference/ModelBaseEcon/">ModelBaseEcon</a></li><li><a class="tocitem" href="../../Reference/StateSpaceEcon/">StateSpaceEcon</a></li><li><a class="tocitem" href="../../Reference/FAME/">FAME</a></li></ul></li><li><span class="tocitem">Design Papers</span><ul><li><a class="tocitem" href="../">Design Papers</a></li><li class="is-active"><a class="tocitem" href>Final Conditions</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Types-of-Final-Conditions"><span>Types of Final Conditions</span></a></li><li><a class="tocitem" href="#The-Stacked-Time-System-of-Equations"><span>The Stacked Time System of Equations</span></a></li><li><a class="tocitem" href="#Solution-Method"><span>Solution Method</span></a></li><li><a class="tocitem" href="#Handling-of-log-variables"><span>Handling of log-variables</span></a></li><li><a class="tocitem" href="#Conclusion"><span>Conclusion</span></a></li></ul></li><li><a class="tocitem" href="../log_variables/">Log-variables</a></li></ul></li><li><a class="tocitem" href="../../indexpage/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Design Papers</a></li><li class="is-active"><a href>Final Conditions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Final Conditions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/bankofcanada/DocsEcon.jl/blob/master/src/DesignPapers/final_conditions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Final-Conditions"><a class="docs-heading-anchor" href="#Final-Conditions">Final Conditions</a><a id="Final-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Final-Conditions" title="Permalink"></a></h1><p>This article describes the different types of final conditions supported in StateSpaceEcon, the relevant mathematical derivations, as well as some implementation details.</p><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>In the stacked time algorithm all equations for all time periods are solved simultaneously as one, very large system of equations. Because of lags in some of the variables, we must impose initial conditions, i.e. values for the variables before the first period of the simulation. This is not unique to stacked time algorithm - all solution methods require initial conditions.</p><p>Similarly, because of leads in some of the variables, we must provide final conditions. Final conditions are equations in terms of variables at times beyond the last period of the simulation.</p><p>As a running example, consider a model with one variable <span>$y_t$</span>, one shock <span>$sy_t$</span>, and one equation involving one lag and one lead:</p><p class="math-container">\[    f(y_{t-1}, y_t, y_{t+1}, s_t) = 0\]</p><p>Suppose we want to simulate 3 periods. Let&#39;s use indices <span>$t=2..4$</span> for the simulation periods. In the stacked time algorithm we have to solve the following system of equations:</p><p class="math-container">\[\begin{aligned}
    f(y_1, y_2, y_3, s_2) &amp;= 0 \\
    f(y_2, y_3, y_4, s_3) &amp;= 0 \\
    f(y_3, y_4, y_5, s_4) &amp;= 0
\end{aligned}\]</p><p>We see that we have 3 equations with 5 unknowns - we assume that the values of the shocks (<span>$s_t$</span>) are given as exogenous data. In order to find a unique solution for <span>$y_t$</span> for all <span>$t=1..5$</span>, we need two more equations. The first one is the initial condition.</p><p class="math-container">\[y_1 = Y_1,\]</p><p>where <span>$Y_1$</span> is a known value of <span>$y$</span> at time <span>$t=1$</span>. The last equation is the final condition, which would help us solve for <span>$y_5$</span>.</p><h2 id="Types-of-Final-Conditions"><a class="docs-heading-anchor" href="#Types-of-Final-Conditions">Types of Final Conditions</a><a id="Types-of-Final-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Types-of-Final-Conditions" title="Permalink"></a></h2><p>There are four types of final conditions currently implemented in StateSpaceEcon.</p><h3 id="fcgiven"><a class="docs-heading-anchor" href="#fcgiven"><code>fcgiven</code></a><a id="fcgiven-1"></a><a class="docs-heading-anchor-permalink" href="#fcgiven" title="Permalink"></a></h3><p>This is the simplest one of them. It can be used when the values of the variable after the end of the simulation are known and we simply assign them.</p><p>In our running example, the following equation corresponds to <code>fcgiven</code>.</p><p class="math-container">\[y_5 = Y_5\]</p><h3 id="fclevel"><a class="docs-heading-anchor" href="#fclevel"><code>fclevel</code></a><a id="fclevel-1"></a><a class="docs-heading-anchor-permalink" href="#fclevel" title="Permalink"></a></h3><p>This is almost the same as <code>fcgiven</code> in that here again we simply assign known values to the variables in the final conditions. This time the values come from the steady state solution of the system. This works if the steady state of <span>$y_t$</span> is a constant.</p><p class="math-container">\[y_5 = ssY_5,\]</p><p>Where <span>$ssY$</span> is the steady state of <span>$y$</span>. Note that the steady state is not necessarily a constant. In the case of balanced growth path and more than one final conditions period, we still assign the known values of <span>$ssY_t$</span> as computed from its known level and slope.</p><h3 id="fcslope"><a class="docs-heading-anchor" href="#fcslope"><code>fcslope</code></a><a id="fcslope-1"></a><a class="docs-heading-anchor-permalink" href="#fcslope" title="Permalink"></a></h3><p>In this case we write an equation which sets the first difference of <span>$y_t$</span> at the end of the simulation (for all final conditions periods) to the slope of the steady state. This works if the steady state solution of <span>$y_t$</span> is a balanced path with linear growth. It can also be used with constant steady state - in that case the &quot;linear growth&quot; has slope 0.</p><p class="math-container">\[y_5 - y_4 = ssY_5 - ssY_4\]</p><p>Note that <span>$ssY_{t+1} - ssY_{t} = ssY_{slope}$</span> is simply the slope of the steady state - a constant that does not depend on <span>$t$</span>.</p><h3 id="fcnatural"><a class="docs-heading-anchor" href="#fcnatural"><code>fcnatural</code></a><a id="fcnatural-1"></a><a class="docs-heading-anchor-permalink" href="#fcnatural" title="Permalink"></a></h3><p>This is the case when we believe that the solution path beyond the end of the simulation is a straight line, but we don&#39;t know its slope, i.e., we allow the slope to be solved for. Practically, this final condition imposes the constraint that the second difference of the variable is zero after the last simulation period.</p><p class="math-container">\[   y_5 - 2 y_4 + y_3 = 0\]</p><h2 id="The-Stacked-Time-System-of-Equations"><a class="docs-heading-anchor" href="#The-Stacked-Time-System-of-Equations">The Stacked Time System of Equations</a><a id="The-Stacked-Time-System-of-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#The-Stacked-Time-System-of-Equations" title="Permalink"></a></h2><p>Once we stack all equations for all simulation time periods into a single system of equations, we get a system with more unknowns than equations, as we saw above. In addition to initial and final conditions, we also have to impose exogenous constraints.</p><h3 id="Vector-of-Unknowns"><a class="docs-heading-anchor" href="#Vector-of-Unknowns">Vector of Unknowns</a><a id="Vector-of-Unknowns-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-of-Unknowns" title="Permalink"></a></h3><p>Let us denote by <span>$x$</span> the vector of all unknowns. To be specific, the variables and shocks are assigned consecutive and unique indices from <span>$1$</span> to <span>$N$</span>. Also, the time periods of the simulation, together with the necessary number of time periods before (initial conditions) and after (final conditions) the simulation, are numbered sequentially starting from 1 to <span>$T$</span>. Thus vector <span>$x$</span> has <span>$N T$</span> components. We have adopted the convention that the first <span>$T$</span> components correspond to values of the first variable, components from <span>$T+1$</span> to <span>$2T$</span> are for variable 2 and so on.</p><p>We divide the unknowns into three groups based on how they are treated by the solver. The first group contains the unknowns whose values are already known. These include initial conditions and exogenous constraints. We denote these <span>$x_e$</span>.</p><p>The second group is the set of &quot;active unknowns&quot;. These are the ones we are actually solving for in the simulation. We denote them <span>$x_s$</span>.</p><p>The third group consists of the unknowns determined by final conditions. We denote that vector <span>$x_c$</span>.</p><p>In our example, the vectors of unknowns would look like this:</p><p class="math-container">\[\begin{aligned}
    x &amp;= [y_1, y_2, y_3, y_4, y_5, s_1, s_2, s_3, s_4, s_5] \\
    x_e &amp;= [y_1, s_1, s_2, s_3, s_3, s_4, s_5] \\
    x_s &amp;= [y_2, y_3, y_4] \\
    x_c &amp;= [y_5]
\end{aligned}\]</p><p>In what follows, we will renumber the unknowns in <span>$x$</span> such that <span>$x_e$</span> are in the beginning, <span>$x_s$</span> are in the middle and <span>$x_c$</span> are at the end. In the code we don&#39;t actually do this, but it makes it easier to discuss the linear algebra in the following sections.</p><p class="math-container">\[    x = [ x_e... , x_s... , x_c... ]\]</p><h3 id="Equations"><a class="docs-heading-anchor" href="#Equations">Equations</a><a id="Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Equations" title="Permalink"></a></h3><p>The equations are also grouped into the same three groups and for the purpose of this exposition we put them in the same order as we did with the unknowns above.</p><h3 id="The-System-of-Equations"><a class="docs-heading-anchor" href="#The-System-of-Equations">The System of Equations</a><a id="The-System-of-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#The-System-of-Equations" title="Permalink"></a></h3><p>Without loss of generality we have a system of equations <span>$F(x) = 0$</span>. Starting with an initial guess <span>$x^0$</span>, the Newton-Raphson method consists in the iteration</p><p class="math-container">\[    x^{n+1} = x^{n} - [J(x^n)]^{-1} F(x^n),\qquad\mathrm{for}\ n=0,1,2...,\]</p><p>where <span>$J(x^n)$</span> is the Jacobian of <span>$F$</span> evaluated at <span>$x^n$</span>.</p><div class="admonition is-warning"><header class="admonition-header">Important</header><div class="admonition-body"><p>We need to distinguish between <em>initial condition</em> and <em>initial guess</em>. The former refers to the values of the model variables prior to the simulation range. The latter is the vector of unknowns at the start of the iterative solution method. To distinguish the two, we use upper index (superscript) to denote the successive iterations of the Newton-Raphson method, while the lower index (subscript) is used to denote the variable group <span>$e$</span>, <span>$s$</span>, or <span>$c$</span>.</p></div></div><p>The computational step here consists in solving the linear system with matrix <span>$J$</span> and right hand side <span>$F$</span>. We can write this system into a 3-by-3 block-matrix form, with rows corresponding to equations and columns corresponding to unknowns split into the three groups.</p><p class="math-container">\[    \begin{bmatrix} I &amp; 0 &amp; 0 \\ E_s &amp; S &amp; C_s \\ E_c &amp; S_c &amp; C \end{bmatrix}
    \cdot
    \begin{bmatrix} \delta x_e \\ \delta x_s \\ \delta x_c \end{bmatrix}
    =
    \begin{bmatrix} 0 \\ F_s \\ F_c \end{bmatrix}\]</p><p>The first row corresponds to exogenous and initial conditions. Notice that the unknown here is not <span>$x$</span> but the update <span>$\delta x$</span>. If we assign the correct exogenous and initial values in <span>$x^0$</span> then the residuals of this group of equations will be all zeros, <span>$F_e = 0$</span>, and so the update <span>$\delta x_e$</span> will also be always zero.</p><p>Therefore the entire system reduces to solving the following:</p><p class="math-container">\[    \begin{bmatrix} S &amp; C_s \\ S_c &amp; C \end{bmatrix}
    \cdot
    \begin{bmatrix} \delta x_s \\ \delta x_c \end{bmatrix}
    =
    \begin{bmatrix} F_s \\ F_c \end{bmatrix}.\]</p><h2 id="Solution-Method"><a class="docs-heading-anchor" href="#Solution-Method">Solution Method</a><a id="Solution-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Solution-Method" title="Permalink"></a></h2><h3 id="Case-1:-fcgiven"><a class="docs-heading-anchor" href="#Case-1:-fcgiven">Case 1: <code>fcgiven</code></a><a id="Case-1:-fcgiven-1"></a><a class="docs-heading-anchor-permalink" href="#Case-1:-fcgiven" title="Permalink"></a></h3><p>In this case we have</p><p class="math-container">\[    \begin{bmatrix} S &amp; C_s \\ 0 &amp; I \end{bmatrix}
    \cdot
    \begin{bmatrix} \delta x_s \\ \delta x_c \end{bmatrix}
    =
    \begin{bmatrix} F_s \\ 0 \end{bmatrix}.\]</p><p>Once again we assume that the correct values for <span>$x_c$</span> are assigned in the initial guess, <span>$x^0$</span>. Therefore the update <span>$\delta x_c$</span> is always zero. Therefore in this case we simply solve</p><p class="math-container">\[    S \cdot \delta x_s = F_s\]</p><p>Note that even though we are not explicitly solving for <span>$\delta x_e$</span> and <span>$\delta x_c$</span>, the matrix <span>$S$</span> and the right hand side <span>$F_s$</span> here depend on the values <span>$x_e$</span> and <span>$x_c$</span>, since they are part of <span>$x^n$</span> when evaluating <span>$F(x^n)$</span> and <span>$J(n^n)$</span>.</p><h3 id="Case-2:-fclevel"><a class="docs-heading-anchor" href="#Case-2:-fclevel">Case 2: <code>fclevel</code></a><a id="Case-2:-fclevel-1"></a><a class="docs-heading-anchor-permalink" href="#Case-2:-fclevel" title="Permalink"></a></h3><p>This is identical to case 1.</p><h3 id="Case-3:-fcslope"><a class="docs-heading-anchor" href="#Case-3:-fcslope">Case 3: <code>fcslope</code></a><a id="Case-3:-fcslope-1"></a><a class="docs-heading-anchor-permalink" href="#Case-3:-fcslope" title="Permalink"></a></h3><p>This is an interesting case. Pay attention because this part is tricky.</p><p>We have the following equations.</p><p class="math-container">\[\begin{aligned}
    S \cdot \delta x_s &amp;+ C_s \cdot \delta x_c &amp;= F_s \\
    S_c \cdot \delta x_s &amp;+ C \cdot \delta x_c &amp;= F_c
\end{aligned}\]</p><p>We eliminate <span>$\delta x_c$</span> from the system. To do so, we multiply the second equation by <span>$C_s C^{-1}$</span> and subtract the result from the first equation.</p><p class="math-container">\[    \left( S - C_s C^{-1} S_c \right) \cdot \delta x_s = F_s - C_s C^{-1} F_c\]</p><h4 id="Solve-for-\\delta-x_s"><a class="docs-heading-anchor" href="#Solve-for-\\delta-x_s">Solve for <span>$\delta x_s$</span></a><a id="Solve-for-\\delta-x_s-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-for-\\delta-x_s" title="Permalink"></a></h4><p>Suppose that <span>$F_c = 0$</span>. We will discuss later how we make sure that&#39;s the case. Then the solution for <span>$\delta x_s$</span> is given by</p><p class="math-container">\[    \left( S - C_s C^{-1} S_c \right) \cdot \delta x_s = F_s\]</p><p>The only difference with case 1 and 2 is that the system matrix is modified by subtracting <span>$C_s C^{-1} S_c$</span>. The matrix <span>$C^{-1} S_c$</span> is constant. This matrix is specific to the <code>fcslope</code> type of final conditions for the given model. It only depends on the number of variables and the number of final conditions periods. It can be pre-computed and stored.</p><p>The matrix <span>$C_s$</span> on the other hand depends on <span>$x^n$</span> and so it needs to be re-computed at every iteration.</p><h4 id="Solve-for-\\delta-x_c"><a class="docs-heading-anchor" href="#Solve-for-\\delta-x_c">Solve for <span>$\delta x_c$</span></a><a id="Solve-for-\\delta-x_c-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-for-\\delta-x_c" title="Permalink"></a></h4><p>How do we make sure that <span>$F_c = 0$</span>? Remember that the final conditions equation in our example model is</p><p class="math-container">\[y_5 - y_4 = ssY_{slope}.\]</p><p>Imagine how this would generalize to an arbitrary model. Now notice that the residual <span>$F_c$</span> depends on <span>$x^n$</span> and the slope of the steady state <span>$ssY_{slope}$</span>. Since we know the <span>$x^n_s$</span> part of <span>$x^n$</span> prior to solving the system, we can set the <span>$x^n_c$</span> part of <span>$x^n$</span> so that the final conditions are satisfied. In other words, this would make sure that <span>$F_c = 0$</span>. One way to do this is to simply start from the values of the variables at the last period of the simulation (which are in <span>$x^n_s$</span>; that&#39;s <span>$y_4$</span> in our example) and compute all future values (which are in <span>$x^n_c$</span>,; that&#39;s <span>$y_5$</span> in the example) by adding the corresponding steady state slope (that is <span>$y_5 = y_4 + ssY_{slope}$</span>). We must do this on every iteration before we evaluate <span>$F(x^n)$</span> and <span>$J(x^n)$</span>.</p><p>Actually, that&#39;s not true. It turns out that we only need to do this to the initial guess <span>$x^0$</span>. After that, once we compute <span>$\delta x_s$</span> by solving the above system, we can solve the following system for <span>$\delta x_c$</span>.</p><p class="math-container">\[    C \cdot \delta x_c = - S_c \cdot \delta x_s\]</p><p>With <span>$\delta x$</span> computed this way, the resulting <span>$x^{n+1}$</span> will produce <span>$F_c=0$</span> at the next iteration. This can be verified directly.</p><h4 id="The-Matrices:-C,-S_c-and-C{-1}S_c"><a class="docs-heading-anchor" href="#The-Matrices:-C,-S_c-and-C{-1}S_c">The Matrices: <span>$C$</span>, <span>$S_c$</span> and <span>$C^{-1}S_c$</span></a><a id="The-Matrices:-C,-S_c-and-C{-1}S_c-1"></a><a class="docs-heading-anchor-permalink" href="#The-Matrices:-C,-S_c-and-C{-1}S_c" title="Permalink"></a></h4><p>These matrices have <span>$0$</span> everywhere except for some non-zero blocks, which we discuss here.</p><p>Our running example has only one period of final conditions and a single variable, which is a trivial case. In order to see what happens in a more general case, suppose we have 4 periods of final conditions and several variables. In matrix <span>$C$</span> we will have a block, <span>$C_b$</span>, like the one below for each variable in the model. Each <span>$C_b$</span> will be the same square block with as many rows and columns as the number of final condition periods.</p><p class="math-container">\[C_b = \begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\ -1 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; -1 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; -1 &amp; 1
    \end{bmatrix}\]</p><p>Matrix <span>$S_c$</span> also contains identical blocks <span>$S_{c,b}$</span> for each variable. The number of rows is the same as <span>$C_b$</span>, while the number of columns equals the number of simulation periods. The <span>$-1$</span> in the top-right corner is in the column corresponding to the last period of the simulation. (In our trivial example above that would be <span>$t=4$</span>)</p><p class="math-container">\[S_{c,b} = \begin{bmatrix}
            0 &amp; \cdots &amp; 0 &amp; -1 \\
            0 &amp; \cdots &amp; 0 &amp; 0 \\
            0 &amp; \cdots &amp; 0 &amp; 0 \\
            0 &amp; \cdots &amp; 0 &amp; 0
          \end{bmatrix}\]</p><p>Now it is straightforward to compute <span>$C^{-1} S_c$</span>. It also has block-structure with blocks like this:</p><p class="math-container">\[ \left(C^{-1}S_c\right)_b = \begin{bmatrix}
            0 &amp; \cdots &amp; 0 &amp; -1 \\
            0 &amp; \cdots &amp; 0 &amp; -1 \\
            0 &amp; \cdots &amp; 0 &amp; -1 \\
            0 &amp; \cdots &amp; 0 &amp; -1 \\
        \end{bmatrix}.\]</p><p>The column with <span>$-1$</span> again corresponds to the last period of the simulation.</p><h3 id="Case-4:-fcnatural"><a class="docs-heading-anchor" href="#Case-4:-fcnatural">Case 4: <code>fcnatural</code></a><a id="Case-4:-fcnatural-1"></a><a class="docs-heading-anchor-permalink" href="#Case-4:-fcnatural" title="Permalink"></a></h3><p>This case is identical to case 3. The only thing that changes is the matrices.</p><p>This time for our example we will use 5 periods of final conditions, so that the patterns would be more obvious. We have the following.</p><p class="math-container">\[C_b = \begin{bmatrix}
    -1 &amp;  0 &amp;  0 &amp;  0 &amp;  0 \\
     2 &amp; -1 &amp;  0 &amp;  0 &amp;  0 \\
    -1 &amp;  2 &amp; -1 &amp;  0 &amp;  0 \\
     0 &amp; -1 &amp;  2 &amp; -1 &amp;  0 \\
     0 &amp;  0 &amp; -1 &amp;  2 &amp; -1 \\
    \end{bmatrix}\]</p><p>For <span>$S_c$</span> this time we have non-zeros in two columns corresponding to the last two periods of the simulation.</p><p class="math-container">\[S_{c,b} = \begin{bmatrix}
            0 &amp; \cdots &amp; 0 &amp; -1 &amp; 2 \\
            0 &amp; \cdots &amp; 0 &amp; 0 &amp; -1 \\
            0 &amp; \cdots &amp; 0 &amp; 0 &amp;  0 \\
            0 &amp; \cdots &amp; 0 &amp; 0 &amp;  0 \\
            0 &amp; \cdots &amp; 0 &amp; 0 &amp;  0 \\
          \end{bmatrix}\]</p><p>Finally, we have</p><p class="math-container">\[ \left(C^{-1}S_c\right)_b = \begin{bmatrix}
            0 &amp; \cdots &amp; 0 &amp; 1 &amp; -2 \\
            0 &amp; \cdots &amp; 0 &amp; 2 &amp; -3 \\
            0 &amp; \cdots &amp; 0 &amp; 3 &amp; -4 \\
            0 &amp; \cdots &amp; 0 &amp; 4 &amp; -5 \\
            0 &amp; \cdots &amp; 0 &amp; 5 &amp; -6 \\
        \end{bmatrix},\]</p><h2 id="Handling-of-log-variables"><a class="docs-heading-anchor" href="#Handling-of-log-variables">Handling of log-variables</a><a id="Handling-of-log-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Handling-of-log-variables" title="Permalink"></a></h2><p>If we have log variables the final conditions the cases of <code>fclevel</code> and <code>fcgiven</code> are the same as above.</p><p>In the case of <code>fcslope</code> the balanced growth path solution is actually a geometric sequence. What we call its &quot;slope&quot; here is actually the common ratio, that is <span>$ssY_{slope} = ssY_{t} / ssY_{t-1}$</span> for all <span>$t$</span>. We have final condition equations that look like this:</p><p class="math-container">\[    y_5 / y_4 = ssY_{slope}.\]</p><p>In the case of <code>fcnatural</code>, we again impose the condition that the solution must be a geometric sequence, although this time the common ratio is unknown and we must solve for it. We have final conditions like this</p><p class="math-container">\[    y_5 / y_4 = y_4 / y_3.\]</p><p>In both cases it is better to work with an equivalent formulation in terms of logs.</p><p class="math-container">\[\begin{aligned}
    log(y_5) &amp;= log(y_4) + log(ssY_{slope}) \qquad &amp; \mathrm{for `fcslope`} \\
    log(y_5) &amp;= 2 log(y_4) - log(y_3) \qquad &amp; \mathrm{for `fcnatural`}
\end{aligned}\]</p><p>If we were to implement this directly, the matrix blocks <span>$C_b$</span> and <span>$S_{c,b}$</span> corresponding to log-variables would not be constant (as they were above for non-log variables), because they would contain the derivatives of the above log functions and would therefore need to be re-computed on each iteration.</p><p>However, in our implementation of log-variables, we apply the log-transformation and so the unknowns we actually solve for are <span>$log(y_t)$</span>. Thus, the final conditions are in fact identical to the ones for non-log variables and we don&#39;t need to do anything special here.</p><h2 id="Conclusion"><a class="docs-heading-anchor" href="#Conclusion">Conclusion</a><a id="Conclusion-1"></a><a class="docs-heading-anchor-permalink" href="#Conclusion" title="Permalink"></a></h2></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Design Papers</a><a class="docs-footer-nextpage" href="../log_variables/">Log-variables »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Thursday 7 April 2022 19:12">Thursday 7 April 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
