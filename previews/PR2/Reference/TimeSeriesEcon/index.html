<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>TimeSeriesEcon · StateSpaceEcon</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="StateSpaceEcon logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">StateSpaceEcon</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../Tutorials/">Introduction</a></li><li><a class="tocitem" href="../../Tutorials/README/">README</a></li><li><a class="tocitem" href="../../Tutorials/1.TimeSeriesEcon/main/">Time Series</a></li><li><a class="tocitem" href="../../Tutorials/2.simple_RBC/main/">Simple RBC Model</a></li><li><a class="tocitem" href="../../Tutorials/3.US_SW07/main/">Smets and Wouters 2007</a></li><li><a class="tocitem" href="../../Tutorials/4.FRB-US/main/">FRB/US</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li class="is-active"><a class="tocitem" href>TimeSeriesEcon</a></li><li><a class="tocitem" href="../ModelBaseEcon/">ModelBaseEcon</a></li><li><a class="tocitem" href="../StateSpaceEcon/">StateSpaceEcon</a></li><li><a class="tocitem" href="../FAME/">FAME</a></li></ul></li><li><span class="tocitem">Design Papers</span><ul><li><a class="tocitem" href="../../DesignPapers/">Design Papers</a></li><li><a class="tocitem" href="../../DesignPapers/final_conditions/">Final Conditions</a></li><li><a class="tocitem" href="../../DesignPapers/log_variables/">Log-variables</a></li></ul></li><li><a class="tocitem" href="../../indexpage/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>TimeSeriesEcon</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>TimeSeriesEcon</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/bankofcanada/DocsEcon.jl/blob/master/src/Reference/TimeSeriesEcon.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="TimeSeriesEcon-Reference"><a class="docs-heading-anchor" href="#TimeSeriesEcon-Reference">TimeSeriesEcon Reference</a><a id="TimeSeriesEcon-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#TimeSeriesEcon-Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.TimeSeriesEcon" href="#TimeSeriesEcon.TimeSeriesEcon"><code>TimeSeriesEcon.TimeSeriesEcon</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">TimeSeriesEcon</code></pre><p>This package is part of the StateSpaceEcon ecosystem. Provides the data types and functionality necessary to work with macroeconomic discrete time models.</p><p><strong>Working with time</strong></p><ul><li>Frequencies are represented by abstract type <a href="#TimeSeriesEcon.Frequency"><code>Frequency</code></a>. </li><li>Concrete frequencies include <a href="#TimeSeriesEcon.Yearly"><code>Yearly</code></a>, <a href="#TimeSeriesEcon.Quarterly"><code>Quarterly</code></a> and <a href="#TimeSeriesEcon.Monthly"><code>Monthly</code></a>.</li><li>Moments in time are represented by data type <a href="#TimeSeriesEcon.MIT"><code>MIT</code></a>.</li><li>Lengths of time are represented by data type <a href="#TimeSeriesEcon.Duration"><code>Duration</code></a>.</li></ul><p><strong>Working with time series</strong></p><ul><li>Data type <a href="#TimeSeriesEcon.TSeries"><code>TSeries</code></a> represents a single time series.</li><li>Data type <a href="#TimeSeriesEcon.MVTSeries"><code>MVTSeries</code></a> represents a multivariate time series.</li></ul><p><strong>Working with other data</strong></p><ul><li>Data type <a href="#TimeSeriesEcon.Workspace"><code>Workspace</code></a> is a general purpose dictionary-like collection of &quot;variable&quot;-like objects.</li></ul><p><strong>Tutorial</strong></p><ul><li><a href="https://bankofcanada.github.io/DocsEcon.jl/dev/Tutorials/TimeSeriesEcon/main/">TimeSeriesEcon tutorial</a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.M1" href="#TimeSeriesEcon.M1"><code>TimeSeriesEcon.M1</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Convenience constants that make MIT literal constants possible. For example, the constant <code>Q1</code> makes it possible to write <code>2020Q1</code> instead of <code>MIT{Quarterly}(2020, 1)</code>. Use <code>U</code> for <code>MIT{Unit}</code>, <code>Y</code> for <code>MIT{Yearly}</code>, <code>Q1</code> to <code>Q4</code> for <code>MIT{Quarterly}</code> and <code>M1</code> to <code>M12</code> for <code>MIT{Monthly}</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.M10" href="#TimeSeriesEcon.M10"><code>TimeSeriesEcon.M10</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Convenience constants that make MIT literal constants possible. For example, the constant <code>Q1</code> makes it possible to write <code>2020Q1</code> instead of <code>MIT{Quarterly}(2020, 1)</code>. Use <code>U</code> for <code>MIT{Unit}</code>, <code>Y</code> for <code>MIT{Yearly}</code>, <code>Q1</code> to <code>Q4</code> for <code>MIT{Quarterly}</code> and <code>M1</code> to <code>M12</code> for <code>MIT{Monthly}</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.M11" href="#TimeSeriesEcon.M11"><code>TimeSeriesEcon.M11</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Convenience constants that make MIT literal constants possible. For example, the constant <code>Q1</code> makes it possible to write <code>2020Q1</code> instead of <code>MIT{Quarterly}(2020, 1)</code>. Use <code>U</code> for <code>MIT{Unit}</code>, <code>Y</code> for <code>MIT{Yearly}</code>, <code>Q1</code> to <code>Q4</code> for <code>MIT{Quarterly}</code> and <code>M1</code> to <code>M12</code> for <code>MIT{Monthly}</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.M12" href="#TimeSeriesEcon.M12"><code>TimeSeriesEcon.M12</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Convenience constants that make MIT literal constants possible. For example, the constant <code>Q1</code> makes it possible to write <code>2020Q1</code> instead of <code>MIT{Quarterly}(2020, 1)</code>. Use <code>U</code> for <code>MIT{Unit}</code>, <code>Y</code> for <code>MIT{Yearly}</code>, <code>Q1</code> to <code>Q4</code> for <code>MIT{Quarterly}</code> and <code>M1</code> to <code>M12</code> for <code>MIT{Monthly}</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.M2" href="#TimeSeriesEcon.M2"><code>TimeSeriesEcon.M2</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Convenience constants that make MIT literal constants possible. For example, the constant <code>Q1</code> makes it possible to write <code>2020Q1</code> instead of <code>MIT{Quarterly}(2020, 1)</code>. Use <code>U</code> for <code>MIT{Unit}</code>, <code>Y</code> for <code>MIT{Yearly}</code>, <code>Q1</code> to <code>Q4</code> for <code>MIT{Quarterly}</code> and <code>M1</code> to <code>M12</code> for <code>MIT{Monthly}</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.M3" href="#TimeSeriesEcon.M3"><code>TimeSeriesEcon.M3</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Convenience constants that make MIT literal constants possible. For example, the constant <code>Q1</code> makes it possible to write <code>2020Q1</code> instead of <code>MIT{Quarterly}(2020, 1)</code>. Use <code>U</code> for <code>MIT{Unit}</code>, <code>Y</code> for <code>MIT{Yearly}</code>, <code>Q1</code> to <code>Q4</code> for <code>MIT{Quarterly}</code> and <code>M1</code> to <code>M12</code> for <code>MIT{Monthly}</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.M4" href="#TimeSeriesEcon.M4"><code>TimeSeriesEcon.M4</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Convenience constants that make MIT literal constants possible. For example, the constant <code>Q1</code> makes it possible to write <code>2020Q1</code> instead of <code>MIT{Quarterly}(2020, 1)</code>. Use <code>U</code> for <code>MIT{Unit}</code>, <code>Y</code> for <code>MIT{Yearly}</code>, <code>Q1</code> to <code>Q4</code> for <code>MIT{Quarterly}</code> and <code>M1</code> to <code>M12</code> for <code>MIT{Monthly}</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.M5" href="#TimeSeriesEcon.M5"><code>TimeSeriesEcon.M5</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Convenience constants that make MIT literal constants possible. For example, the constant <code>Q1</code> makes it possible to write <code>2020Q1</code> instead of <code>MIT{Quarterly}(2020, 1)</code>. Use <code>U</code> for <code>MIT{Unit}</code>, <code>Y</code> for <code>MIT{Yearly}</code>, <code>Q1</code> to <code>Q4</code> for <code>MIT{Quarterly}</code> and <code>M1</code> to <code>M12</code> for <code>MIT{Monthly}</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.M6" href="#TimeSeriesEcon.M6"><code>TimeSeriesEcon.M6</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Convenience constants that make MIT literal constants possible. For example, the constant <code>Q1</code> makes it possible to write <code>2020Q1</code> instead of <code>MIT{Quarterly}(2020, 1)</code>. Use <code>U</code> for <code>MIT{Unit}</code>, <code>Y</code> for <code>MIT{Yearly}</code>, <code>Q1</code> to <code>Q4</code> for <code>MIT{Quarterly}</code> and <code>M1</code> to <code>M12</code> for <code>MIT{Monthly}</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.M7" href="#TimeSeriesEcon.M7"><code>TimeSeriesEcon.M7</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Convenience constants that make MIT literal constants possible. For example, the constant <code>Q1</code> makes it possible to write <code>2020Q1</code> instead of <code>MIT{Quarterly}(2020, 1)</code>. Use <code>U</code> for <code>MIT{Unit}</code>, <code>Y</code> for <code>MIT{Yearly}</code>, <code>Q1</code> to <code>Q4</code> for <code>MIT{Quarterly}</code> and <code>M1</code> to <code>M12</code> for <code>MIT{Monthly}</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.M8" href="#TimeSeriesEcon.M8"><code>TimeSeriesEcon.M8</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Convenience constants that make MIT literal constants possible. For example, the constant <code>Q1</code> makes it possible to write <code>2020Q1</code> instead of <code>MIT{Quarterly}(2020, 1)</code>. Use <code>U</code> for <code>MIT{Unit}</code>, <code>Y</code> for <code>MIT{Yearly}</code>, <code>Q1</code> to <code>Q4</code> for <code>MIT{Quarterly}</code> and <code>M1</code> to <code>M12</code> for <code>MIT{Monthly}</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.M9" href="#TimeSeriesEcon.M9"><code>TimeSeriesEcon.M9</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Convenience constants that make MIT literal constants possible. For example, the constant <code>Q1</code> makes it possible to write <code>2020Q1</code> instead of <code>MIT{Quarterly}(2020, 1)</code>. Use <code>U</code> for <code>MIT{Unit}</code>, <code>Y</code> for <code>MIT{Yearly}</code>, <code>Q1</code> to <code>Q4</code> for <code>MIT{Quarterly}</code> and <code>M1</code> to <code>M12</code> for <code>MIT{Monthly}</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.Q1" href="#TimeSeriesEcon.Q1"><code>TimeSeriesEcon.Q1</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Convenience constants that make MIT literal constants possible. For example, the constant <code>Q1</code> makes it possible to write <code>2020Q1</code> instead of <code>MIT{Quarterly}(2020, 1)</code>. Use <code>U</code> for <code>MIT{Unit}</code>, <code>Y</code> for <code>MIT{Yearly}</code>, <code>Q1</code> to <code>Q4</code> for <code>MIT{Quarterly}</code> and <code>M1</code> to <code>M12</code> for <code>MIT{Monthly}</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.Q2" href="#TimeSeriesEcon.Q2"><code>TimeSeriesEcon.Q2</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Convenience constants that make MIT literal constants possible. For example, the constant <code>Q1</code> makes it possible to write <code>2020Q1</code> instead of <code>MIT{Quarterly}(2020, 1)</code>. Use <code>U</code> for <code>MIT{Unit}</code>, <code>Y</code> for <code>MIT{Yearly}</code>, <code>Q1</code> to <code>Q4</code> for <code>MIT{Quarterly}</code> and <code>M1</code> to <code>M12</code> for <code>MIT{Monthly}</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.Q3" href="#TimeSeriesEcon.Q3"><code>TimeSeriesEcon.Q3</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Convenience constants that make MIT literal constants possible. For example, the constant <code>Q1</code> makes it possible to write <code>2020Q1</code> instead of <code>MIT{Quarterly}(2020, 1)</code>. Use <code>U</code> for <code>MIT{Unit}</code>, <code>Y</code> for <code>MIT{Yearly}</code>, <code>Q1</code> to <code>Q4</code> for <code>MIT{Quarterly}</code> and <code>M1</code> to <code>M12</code> for <code>MIT{Monthly}</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.Q4" href="#TimeSeriesEcon.Q4"><code>TimeSeriesEcon.Q4</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Convenience constants that make MIT literal constants possible. For example, the constant <code>Q1</code> makes it possible to write <code>2020Q1</code> instead of <code>MIT{Quarterly}(2020, 1)</code>. Use <code>U</code> for <code>MIT{Unit}</code>, <code>Y</code> for <code>MIT{Yearly}</code>, <code>Q1</code> to <code>Q4</code> for <code>MIT{Quarterly}</code> and <code>M1</code> to <code>M12</code> for <code>MIT{Monthly}</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.U" href="#TimeSeriesEcon.U"><code>TimeSeriesEcon.U</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Convenience constants that make MIT literal constants possible. For example, the constant <code>Q1</code> makes it possible to write <code>2020Q1</code> instead of <code>MIT{Quarterly}(2020, 1)</code>. Use <code>U</code> for <code>MIT{Unit}</code>, <code>Y</code> for <code>MIT{Yearly}</code>, <code>Q1</code> to <code>Q4</code> for <code>MIT{Quarterly}</code> and <code>M1</code> to <code>M12</code> for <code>MIT{Monthly}</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.Y" href="#TimeSeriesEcon.Y"><code>TimeSeriesEcon.Y</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Convenience constants that make MIT literal constants possible. For example, the constant <code>Q1</code> makes it possible to write <code>2020Q1</code> instead of <code>MIT{Quarterly}(2020, 1)</code>. Use <code>U</code> for <code>MIT{Unit}</code>, <code>Y</code> for <code>MIT{Yearly}</code>, <code>Q1</code> to <code>Q4</code> for <code>MIT{Quarterly}</code> and <code>M1</code> to <code>M12</code> for <code>MIT{Monthly}</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.Duration" href="#TimeSeriesEcon.Duration"><code>TimeSeriesEcon.Duration</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MIT{F &lt;: Frequency}, Duration{F &lt;: Frequency}</code></pre><p>Two types representing a moment in time (like 2020Q1 or 2020Y) and duration (the quantity of time between two moments).</p><p>Both of these have a Frequency as a type parameter and both internally are represented by integer values.</p><p>If you imagine a time axis of the given <code>Frequency</code>, <code>MIT</code> values are ordinal (correspond to points) while <code>Duration</code> values are cardinal (correspond to distances).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.Frequency" href="#TimeSeriesEcon.Frequency"><code>TimeSeriesEcon.Frequency</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Frequency end</code></pre><p>The abstract supertype for all frequencies.</p><p>See also: <a href="#TimeSeriesEcon.Unit"><code>Unit</code></a> and <a href="#TimeSeriesEcon.YPFrequency"><code>YPFrequency</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.MIT" href="#TimeSeriesEcon.MIT"><code>TimeSeriesEcon.MIT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MIT{F &lt;: Frequency}, Duration{F &lt;: Frequency}</code></pre><p>Two types representing a moment in time (like 2020Q1 or 2020Y) and duration (the quantity of time between two moments).</p><p>Both of these have a Frequency as a type parameter and both internally are represented by integer values.</p><p>If you imagine a time axis of the given <code>Frequency</code>, <code>MIT</code> values are ordinal (correspond to points) while <code>Duration</code> values are cardinal (correspond to distances).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.MIT-Union{Tuple{F}, Tuple{N}, Tuple{Integer, Integer}} where {N, F&lt;:YPFrequency{N}}" href="#TimeSeriesEcon.MIT-Union{Tuple{F}, Tuple{N}, Tuple{Integer, Integer}} where {N, F&lt;:YPFrequency{N}}"><code>TimeSeriesEcon.MIT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MIT{F}(year, period) where {F &lt;: YPFrequency}</code></pre><p>Construct an <a href="#TimeSeriesEcon.MIT"><code>MIT</code></a> instance from <code>year</code> and <code>period</code>. This is valid only for frequencies subtyped from <a href="#TimeSeriesEcon.YPFrequency"><code>YPFrequency</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.MVTSeries" href="#TimeSeriesEcon.MVTSeries"><code>TimeSeriesEcon.MVTSeries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct MVTSeries{F,T,C} &lt;: AbstractMatrix{T}
    firstdate::MIT{F}
    columns::OrderedDict{Symbol,TSeries{F,T}}
    values::C
end</code></pre><p>Multi-variate Time series with frequency <code>F</code> with values of type <code>T</code> stored in a container of type <code>C</code>. By default the type is <code>Float64</code> and the container is <code>Matrix{Float64}</code>. The rows correspond to moments in time and the columns correspond to variables. Columns are named. The values in the field <code>columns</code> are <code>TSeries</code> whose storages are views into the corresponding columns of the <code>values</code> matrix.</p><p><strong>Construction:</strong></p><pre><code class="nohighlight hljs">x = MVTSeries(args...)</code></pre><p>The standard construction is <code>MVTSeries(firstdate::MIT, names, values)</code> Here <code>names</code> should be a tuple of <code>Symbol</code>s and <code>values</code> should be a matrix of the same number of columns as there are names in <code>names</code>. The range of the <code>MVTSeries</code> is determined from the number of rows of <code>values</code>. If <code>values</code> is not provided, the <code>MVTSeries</code> is constructed empty with size <code>(0, length(names))</code><code>. If</code>names<code>is also not provided, the</code>MVTSeries<code>is constructed empty with size</code>(0, 0)`.</p><p>The first argument can be a range. <code>MVTSeries(range::UnitRange{&lt;:MIT}, names, values)</code>  In this case the size of the <code>MVTSeries</code> is determined by the lengths of <code>range</code> and <code>names</code>; the <code>values</code> argument is interpreted as an initializer. If it is omitted or set to <code>undef</code>, the storage is left uninitialized. If it is a number, the storage is filled with it. It can also be an initializer function, such as <code>zeros</code>, <code>ones</code> or <code>rand</code>. Lastly, if the <code>values</code> argument is an array, it must be 2-dimensional and of the correct size.</p><p>Another possibility is to construct from a collection of name-value pairs. <code>MVTSeries(range; var1 = val1, var2 = val2, ...)</code> The <code>range</code> argument is optional, if missing it&#39;ll be determined from the ranges of the given values. The values can be <a href="#TimeSeriesEcon.TSeries"><code>TSeries</code></a>, vectors or constants. Any vector must have the same length as the range.</p><p>An <code>MVTSeries</code> can also be constructed with <code>copy</code>, <code>similar</code>, and <code>fill</code>.</p><p><strong>Indexing:</strong></p><p>Indexing with integers, integer ranges, or boolean arrays works the same as with <code>Matrix</code>. The result from slicing with integer ranges or boolean arrays is always a <code>Matrix</code>, i.e., the <code>MVTSeries</code> structure is lost.</p><p>Indexing with two indexes works as follows. The first index can be an <a href="#TimeSeriesEcon.MIT"><code>MIT</code></a> or a range of <a href="#TimeSeriesEcon.MIT"><code>MIT</code></a> and it works the same as for   <a href="#TimeSeriesEcon.TSeries"><code>TSeries</code></a>. The second index can be a <code>Symbol</code> or a collection of <code>Symbol</code>s, such as a tuple or a vector. <code>begin</code> and <code>end</code> work for the first index the same as with <a href="#TimeSeriesEcon.TSeries"><code>TSeries</code></a>.</p><p>Indexing with one index depends on the type. If it is <code>MIT</code> or a  range of <code>MIT</code>, it is treated as if the second index were <code>:</code>, i.e., the  entire row or multiple rows is returned. If the index is a <code>Symbol</code> or  a collection of <code>Symbol</code>s, it is treated as if the first index were <code>:</code>,  i.e., entire column or multiple columns is returned as <a href="#TimeSeriesEcon.TSeries"><code>TSeries</code></a> or <code>MVTSeries</code> respectively.</p><p>Columns can also be accessed using &quot;dot&quot; notation. For example <code>x[:a]</code> is the same as <code>x.a</code>.</p><p>Check out the tutorial at  <a href="https://bankofcanada.github.io/DocsEcon.jl/dev/Tutorials/TimeSeriesEcon/main/">https://bankofcanada.github.io/DocsEcon.jl/dev/Tutorials/TimeSeriesEcon/main/</a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.Monthly" href="#TimeSeriesEcon.Monthly"><code>TimeSeriesEcon.Monthly</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Monthly &lt;: YPFrequency{12} end</code></pre><p>A concrete frequency defined as 12 periods per year.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.Quarterly" href="#TimeSeriesEcon.Quarterly"><code>TimeSeriesEcon.Quarterly</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Quarterly &lt;: YPFrequency{4} end</code></pre><p>A concrete frequency defined as 4 periods per year.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.TSeries" href="#TimeSeriesEcon.TSeries"><code>TimeSeriesEcon.TSeries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct TSeries{F, T, C} &lt;: AbstractVector{T}
    firstdate::MIT{F}
    values::C
end</code></pre><p>Time series with frequency <code>F</code> and values of type <code>T</code> stored in a container of type <code>C</code>. By default the type is <code>Float64</code> and the container is <code>Vector{Float64}</code>.</p><p><strong>Construction:</strong></p><pre><code class="nohighlight hljs">ts = TSeries(args...)</code></pre><p>The standard construction is <code>TSeries(firstdate::MIT, values::AbstractVector)</code>. If the second argument is not given, the <code>TSeries</code> is constructed empty.</p><p>Alternatively, the first argument can be a range. In this case, the second argument is interpreted as an initializer. If it is omitted or set to <code>undef</code>, the storage is left uninitialized. If it is a number, the storage is filled with it. It can also be an initializer function, such as <code>zeros</code>, <code>ones</code> or <code>rand</code>. Lastly, if the second argument is an array, it must be 1-dimensional and of the same length as the range given in the first argument.</p><p>If only an integer number is given, as in <code>TSeries(n::Integer)</code>, the constructed <code>TSeries</code> will have frequency <code>Unit</code>, first date <code>1U</code> and length <code>n</code>. An initialization argument is not allowed in this case, so the storage remains uninitialized.</p><p>A <code>TSeries</code> can also be constructed with <code>copy</code>, <code>similar</code>, and <code>fill</code>, <code>ones</code>, <code>zeros</code>.</p><p><strong>Indexing:</strong></p><p>Indexing with an <a href="#TimeSeriesEcon.MIT"><code>MIT</code></a> or a range of <a href="#TimeSeriesEcon.MIT"><code>MIT</code></a> works as you&#39;d expect.</p><p>Indexing with <code>Integer</code>s works the same as with <code>Vector</code>.</p><p>Indexing with <code>Bool</code>-array works as you&#39;d expect. For example, <code>s[s .&lt; 0.0] .*= -1</code> multiplies in place the negative entries of <code>s</code> by -1, so effectively it&#39;s the same as <code>s .= abs.(s)</code>.</p><p>There are important differences between indexing with MIT and not using MIT (i.e., using <code>Integer</code> or <code>Bool</code>-array).</p><ul><li><p>with MIT-range we return a <code>TSeries</code>, otherwise we   return a <code>Vector</code>.</p></li><li><p>the range can be extended (the <code>TSeries</code> resized appropriately) by   assigning outside the current range. This works only with <a href="#TimeSeriesEcon.MIT"><code>MIT</code></a>.   With anything else you get a BoundsError if you try to assign outside the   Integer range.</p></li><li><p><code>begin</code> and <code>end</code> are <a href="#TimeSeriesEcon.MIT"><code>MIT</code></a>, so either use both or none of them.   For example <code>s[2:end]</code> doesn&#39;t work because 2 is an <code>Int</code> and <code>end</code> is an   <code>MIT</code>. You should use <code>s[begin+1:end]</code>.</p></li></ul><p>Check out the tutorial at  <a href="https://bankofcanada.github.io/DocsEcon.jl/dev/Tutorials/TimeSeriesEcon/main/">https://bankofcanada.github.io/DocsEcon.jl/dev/Tutorials/TimeSeriesEcon/main/</a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.Unit" href="#TimeSeriesEcon.Unit"><code>TimeSeriesEcon.Unit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Unit &lt;: Frequency end</code></pre><p>Represents a non-dimensional frequency (not associated with the calendar).</p><p>See also: <a href="#TimeSeriesEcon.Frequency"><code>Frequency</code></a>, <a href="#TimeSeriesEcon.YPFrequency"><code>YPFrequency</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.Workspace" href="#TimeSeriesEcon.Workspace"><code>TimeSeriesEcon.Workspace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Workspace
    …
end</code></pre><p>A collection of variables. <code>Workspace</code>s can store data of any kind, including numbers, <code>MIT</code>s, ranges, strings, <code>TSeries</code>, <code>MVTSeries</code>, even nested <code>Workspace</code>s.</p><p><strong>Construction</strong></p><p>Easiest is to start with and empty <code>Workspace</code> and fill it up later. Otherwise, content can be provided at construction time as a collection of name-value pairs, where the name must be a <code>Symbol</code> and the value can be anything.</p><p><strong>Access</strong></p><p>Members of the <code>Workspace</code> can be accessed using &quot;dot&quot; notation or using <code>[]</code> indexing, like a dictionary.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.YPFrequency" href="#TimeSeriesEcon.YPFrequency"><code>TimeSeriesEcon.YPFrequency</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type YPFrequency{N} &lt;: Frequency end</code></pre><p>Represents a calendar frequency defined by a number of periods in a year. The type parameter <code>N</code> is the number of periods and must be a positive integer. </p><p>See also: <a href="#TimeSeriesEcon.Frequency"><code>Frequency</code></a>, <a href="#TimeSeriesEcon.Yearly"><code>Yearly</code></a>, <a href="#TimeSeriesEcon.Quarterly"><code>Quarterly</code></a>, <a href="#TimeSeriesEcon.Monthly"><code>Monthly</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.Yearly" href="#TimeSeriesEcon.Yearly"><code>TimeSeriesEcon.Yearly</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Yearly &lt;: YPFrequency{1} end</code></pre><p>A concrete frequency defined as 1 period per year.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.diff" href="#Base.diff"><code>Base.diff</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">diff(x::TSeries)
diff(x::TSeries, k)</code></pre><p>Construct the first difference, or the <code>k</code>-th difference, of time series <code>t</code>. If <code>y = diff(x,k)</code> then <code>y[t] = x[t] - x[t+k]</code>. A negative value of <code>k</code> means that we subtract a lag and positive value means that we subtract a lead. <code>k</code> not given is the same as <code>k=-1</code>, which matches the standard definition of first difference.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.fill-Union{Tuple{N}, Tuple{Any, UnitRange{var&quot;#s26&quot;} where var&quot;#s26&quot;&lt;:MIT, Tuple{Vararg{Symbol, N}}}} where N" href="#Base.fill-Union{Tuple{N}, Tuple{Any, UnitRange{var&quot;#s26&quot;} where var&quot;#s26&quot;&lt;:MIT, Tuple{Vararg{Symbol, N}}}} where N"><code>Base.fill</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fill(val, range)
fill(val, range, variables)</code></pre><p>In the first form create a <a href="#TimeSeriesEcon.TSeries"><code>TSeries</code></a> with the given range. In the second form create an <a href="#TimeSeriesEcon.MVTSeries"><code>MVTSeries</code></a> with the given range and variables. In both cases they are filled with the given value <code>val</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pairs-Tuple{MVTSeries}" href="#Base.pairs-Tuple{MVTSeries}"><code>Base.pairs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pairs(data::MVTSeries; copy = false)</code></pre><p>Returns an iterator over the named columns of <code>data</code>. Each iteration gives a name-value pair where name is a <code>Symbol</code> and value is a <a href="#TimeSeriesEcon.TSeries"><code>TSeries</code></a>.</p><p>Setting <code>copy=true</code> is equivalent to <code>pairs(copy(data))</code> but slightly more efficient.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.resize!-Tuple{TSeries, Integer}" href="#Base.resize!-Tuple{TSeries, Integer}"><code>Base.resize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">resize!(t::TSeries, n::Integer)</code></pre><p>Extend or shrink the allocated storage for <code>t</code> to <code>n</code> entries. The first date of <code>t</code> does not change. If allocation is extended, the new entries are set to <code>NaN</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.resize!-Tuple{TSeries, UnitRange{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:MIT}" href="#Base.resize!-Tuple{TSeries, UnitRange{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:MIT}"><code>Base.resize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">resize!(t::TSeries, rng)</code></pre><p>Extend or shrink the allocated storage for <code>t</code> so that the new range of <code>t</code> equals the given <code>rng</code>. If <code>t</code> is extended, new entries are set to <code>NaN</code>, or the appropriate Not-A-Number value (see <a href="#TimeSeriesEcon.typenan"><code>typenan</code></a>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.similar-Tuple{MVTSeries}" href="#Base.similar-Tuple{MVTSeries}"><code>Base.similar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">similar(t::MVTSeries, [eltype], [shape])
similar(array, [eltype], shape)
similar(array_type, [eltype], shape)</code></pre><p>Create an uninitialized <a href="#TimeSeriesEcon.MVTSeries"><code>MVTSeries</code></a> with the given element type and <code>shape</code>.</p><p>If the first argument is an <a href="#TimeSeriesEcon.MVTSeries"><code>MVTSeries</code></a> then the element type and shape of the output will match those of the input, unless they are explicitly given in subsequent arguments. If the first argument is another array or an array type, then <code>shape</code> must be given in the form of a tuple where the first element is an MIT range and the second is a list of column names. The element type, <code>eltype</code>, also can be given optionally; if not given it will be deduced from the first argument.</p><p>Example: </p><pre><code class="nohighlight hljs">similar(Array{Float64}, (2000Q1:2001Q4, (:a, :b)))</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.similar-Tuple{TSeries}" href="#Base.similar-Tuple{TSeries}"><code>Base.similar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">similar(t::TSeries, [eltype], [range])
similar(array, [eltype], range)
similar(array_type, [eltype], range)</code></pre><p>Create an uninitialized <a href="#TimeSeriesEcon.TSeries"><code>TSeries</code></a> with the given element type and range.</p><p>If the first argument is a <a href="#TimeSeriesEcon.TSeries"><code>TSeries</code></a> then the element type and range of the output will match those of the input, unless they are explicitly given in subsequent arguments. If the first argument is another array or an array type, then <code>range</code> must be given. The element type, <code>eltype</code>, can be given; if not it will be deduced from the first argument.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.strip-Tuple{TSeries}" href="#Base.strip-Tuple{TSeries}"><code>Base.strip</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">strip(t:TSeries)</code></pre><p>Remove leading and trailing <code>NaN</code> from the given time series. This version creates a new <a href="#TimeSeriesEcon.TSeries"><code>TSeries</code></a> instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.apct-Union{Tuple{TSeries{var&quot;#s10&quot;, T, C} where {var&quot;#s10&quot;&lt;:YPFrequency{N}, T&lt;:Number, C&lt;:AbstractVector{T}}}, Tuple{N}, Tuple{TSeries{var&quot;#s9&quot;, T, C} where {var&quot;#s9&quot;&lt;:YPFrequency{N}, T&lt;:Number, C&lt;:AbstractVector{T}}, Bool}} where N" href="#TimeSeriesEcon.apct-Union{Tuple{TSeries{var&quot;#s10&quot;, T, C} where {var&quot;#s10&quot;&lt;:YPFrequency{N}, T&lt;:Number, C&lt;:AbstractVector{T}}}, Tuple{N}, Tuple{TSeries{var&quot;#s9&quot;, T, C} where {var&quot;#s9&quot;&lt;:YPFrequency{N}, T&lt;:Number, C&lt;:AbstractVector{T}}, Bool}} where N"><code>TimeSeriesEcon.apct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apct(x::TSeries, islog::Bool)</code></pre><p>Annualised percent rate of change in <code>x</code>.</p><p>Examples</p><pre><code class="language-julia-repl hljs">julia&gt; x = TSeries(qq(2018, 1), Vector(1:8));

julia&gt; apct(x)
TSeries{Quarterly} of length 7
2018Q2: 1500.0
2018Q3: 406.25
2018Q4: 216.04938271604937
2019Q1: 144.140625
2019Q2: 107.35999999999999
2019Q3: 85.26234567901243
2019Q4: 70.59558517284461</code></pre><p>See also: <a href="#TimeSeriesEcon.pct"><code>pct</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.colnames-Tuple{MVTSeries}" href="#TimeSeriesEcon.colnames-Tuple{MVTSeries}"><code>TimeSeriesEcon.colnames</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">colnames(x::MVTSeries)</code></pre><p>Return the names of the columns of <code>x</code> as an iterable.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.columns-Tuple{MVTSeries}" href="#TimeSeriesEcon.columns-Tuple{MVTSeries}"><code>TimeSeriesEcon.columns</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">columns(x::MVTSeries)</code></pre><p>Return the columns of <code>x</code> as a dictionary. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.compare" href="#TimeSeriesEcon.compare"><code>TimeSeriesEcon.compare</code></a> — <span class="docstring-category">Function</span></header><section><div><p>@compare x y [options]  compare(x, y [; options])</p><p>Compare two <code>Workspace</code> recursively and print out the differences. <code>MVTSeries</code> and <code>Dict</code> with keys of type <code>Symbol</code> are treated like <code>Workspace</code>. <code>TSeries</code> and other <code>Vector</code> are compared using <code>isapprox</code>, so feel free to supply <code>rtol</code> or <code>atol</code>.</p><p>Optional argument <code>name</code> can be used for the top name. Default is <code>&quot;_&quot;</code>.</p><p>Parameter <code>showequal=true</code> causes the report to include objects that are the same. Default behaviour, with <code>showequal=false</code>, is to report only the differences. </p><p>Parameter <code>ignoremissing=true</code> causes objects that appear in one but not the other workspace to be ignored. That is, they are not printed and do not affect the return value <code>true</code> or <code>false</code>. Default is <code>ignoremissing=false</code> meaning they will be printed and return value will be <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.fconvert-Tuple{Type{var&quot;#s19&quot;} where var&quot;#s19&quot;&lt;:Frequency, TSeries}" href="#TimeSeriesEcon.fconvert-Tuple{Type{var&quot;#s19&quot;} where var&quot;#s19&quot;&lt;:Frequency, TSeries}"><code>TimeSeriesEcon.fconvert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fconvert(F, t)</code></pre><p>Convert the time series <code>t</code> to the desired frequency <code>F</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.fconvert-Union{Tuple{N2}, Tuple{N1}, Tuple{Type{var&quot;#s22&quot;} where var&quot;#s22&quot;&lt;:YPFrequency{N1}, TSeries{var&quot;#s23&quot;, T, C} where {var&quot;#s23&quot;&lt;:YPFrequency{N2}, T&lt;:Number, C&lt;:AbstractVector{T}}}} where {N1, N2}" href="#TimeSeriesEcon.fconvert-Union{Tuple{N2}, Tuple{N1}, Tuple{Type{var&quot;#s22&quot;} where var&quot;#s22&quot;&lt;:YPFrequency{N1}, TSeries{var&quot;#s23&quot;, T, C} where {var&quot;#s23&quot;&lt;:YPFrequency{N2}, T&lt;:Number, C&lt;:AbstractVector{T}}}} where {N1, N2}"><code>TimeSeriesEcon.fconvert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fconvert(F1, x::TSeries{F2}; method) where {F1 &lt;: YPFrequency, F2 &lt;: YPFrequency}</code></pre><p>Convert between frequencies derived from <a href="#TimeSeriesEcon.YPFrequency"><code>YPFrequency</code></a>.</p><p>Currently this works only when the periods per year of the higher frequency is an exact multiple of the periods per year of the lower frequency.</p><p><strong>Converting to Higher Frequency</strong></p><p>The only method available is <code>method=:const</code>, where the value at each period of the higher frequency is the value of the period of the lower frequency it belongs to.</p><pre><code class="nohighlight hljs">x = TSeries(2000Q1:2000Q3, collect(Float64, 1:3))
fconvert(Monthly, x)</code></pre><p><strong>Converting to Lower Frequency</strong></p><p>The range of the result includes periods that are fully included in the range of the input. For each period of the lower frequency we aggregate all periods of the higher frequency within it. We have 4 methods currently available: <code>:mean</code>, <code>:sum</code>, <code>:begin</code>, and <code>:end</code>.  The default is <code>:mean</code>.</p><pre><code class="nohighlight hljs">x = TSeries(2000M1:2000M7, collect(Float64, 1:7))
fconvert(Quarterly, x; method = :sum)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.firstdate-Tuple{TSeries}" href="#TimeSeriesEcon.firstdate-Tuple{TSeries}"><code>TimeSeriesEcon.firstdate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">firstdate(x)</code></pre><p>Return the first date of the range of allocated storage for the given <a href="#TimeSeriesEcon.TSeries"><code>TSeries</code></a> or <a href="#TimeSeriesEcon.MVTSeries"><code>MVTSeries</code></a> instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.frequencyof" href="#TimeSeriesEcon.frequencyof"><code>TimeSeriesEcon.frequencyof</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">frequencyof(x)
frequencyof(T)</code></pre><p>Return the <a href="#TimeSeriesEcon.Frequency"><code>Frequency</code></a> type of the given value <code>x</code> or type <code>T</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.istypenan-Tuple{Any}" href="#TimeSeriesEcon.istypenan-Tuple{Any}"><code>TimeSeriesEcon.istypenan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">istypenan(x)</code></pre><p>Return <code>true</code> if the given <code>x</code> is a not-n-number of its type, otherwise return <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.lag" href="#TimeSeriesEcon.lag"><code>TimeSeriesEcon.lag</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lag(x::TSeries, k=1)</code></pre><p>Shift the dates of <code>x</code> by <code>k</code> period to produce the <code>k</code>-th lag of <code>x</code>. This is the same <a href="#TimeSeriesEcon.shift-Tuple{TSeries, Int64}"><code>shift(x, -k)</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.lag!" href="#TimeSeriesEcon.lag!"><code>TimeSeriesEcon.lag!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lag!(x::TSeries, k=1)</code></pre><p>In-place version of <a href="#TimeSeriesEcon.lag"><code>lag</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.lastdate-Tuple{TSeries}" href="#TimeSeriesEcon.lastdate-Tuple{TSeries}"><code>TimeSeriesEcon.lastdate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lastdate(x)</code></pre><p>Return the last date of the range of allocated storage for the given <a href="#TimeSeriesEcon.TSeries"><code>TSeries</code></a> or <a href="#TimeSeriesEcon.MVTSeries"><code>MVTSeries</code></a> instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.lead" href="#TimeSeriesEcon.lead"><code>TimeSeriesEcon.lead</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lead(x::TSeries, k=1)</code></pre><p>Shift the dates of <code>x</code> by <code>k</code> period to produce the <code>k</code>-th lead of <code>x</code>. This is the same <a href="#TimeSeriesEcon.shift-Tuple{TSeries, Int64}"><code>shift(x, k)</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.lead!" href="#TimeSeriesEcon.lead!"><code>TimeSeriesEcon.lead!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lead!(x::TSeries, k=1)</code></pre><p>In-place version of <a href="#TimeSeriesEcon.lead"><code>lead</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.mit2yp" href="#TimeSeriesEcon.mit2yp"><code>TimeSeriesEcon.mit2yp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mit2yp(x::MIT)</code></pre><p>Recover the year and period from the given <a href="#TimeSeriesEcon.MIT"><code>MIT</code></a> value. This is valid only for frequencies subtyped from <a href="#TimeSeriesEcon.YPFrequency"><code>YPFrequency</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.mm-Tuple{Integer, Integer}" href="#TimeSeriesEcon.mm-Tuple{Integer, Integer}"><code>TimeSeriesEcon.mm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mm(year, period)</code></pre><p>Construct an <code>MIT{Monthly}</code> from an year and a period.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.moving" href="#TimeSeriesEcon.moving"><code>TimeSeriesEcon.moving</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">moving(x, n)</code></pre><p>Compute the moving average of <code>x</code> over a window of <code>n</code> periods. If <code>n &gt; 0</code> the window is backward-looking <code>(-n+1:0)</code> and if <code>n &lt; 0</code> the window is forward-looking <code>(0:-n-1)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.overlay" href="#TimeSeriesEcon.overlay"><code>TimeSeriesEcon.overlay</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">overlay(arg1, args...)</code></pre><p>Return the first argument, from left to right, that is valid. At least one argument must be given. Validity is determined by calling <a href="#TimeSeriesEcon.istypenan-Tuple{Any}"><code>istypenan</code></a>. If it returns <code>true</code>, the observation is not valid; <code>false</code> means it is.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.overlay-Tuple{Vararg{TSeries, N} where N}" href="#TimeSeriesEcon.overlay-Tuple{Vararg{TSeries, N} where N}"><code>TimeSeriesEcon.overlay</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlay([rng,] t1, t2, ...)</code></pre><p>Construct a <a href="#TimeSeriesEcon.TSeries"><code>TSeries</code></a> in which each observation is taken from the first valid observation in the list of arguments. A valid observation is one for which <a href="#TimeSeriesEcon.istypenan-Tuple{Any}"><code>istypenan</code></a> returns <code>false</code>.</p><p>All <a href="#TimeSeriesEcon.TSeries"><code>TSeries</code></a> in the arguments list must be of the same frequency. The data type of the resulting <a href="#TimeSeriesEcon.TSeries"><code>TSeries</code></a> is decided by the standard promotion of numerical types in Julia. Its range is the union of the ranges of the arguments, unless the optional <code>rng</code> is ginven in which case it becomes the range.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.overlay-Tuple{Vararg{Union{Workspace, AbstractDict{Symbol, var&quot;#s70&quot;} where var&quot;#s70&quot;, MVTSeries}, N} where N}" href="#TimeSeriesEcon.overlay-Tuple{Vararg{Union{Workspace, AbstractDict{Symbol, var&quot;#s70&quot;} where var&quot;#s70&quot;, MVTSeries}, N} where N}"><code>TimeSeriesEcon.overlay</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlay(data1, data2, ...)</code></pre><p>When overlaying <code>Workspace</code>s and <code>MVTSeries</code> the result is a <code>Workspace</code> and each member is overlaid recursively.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.pct" href="#TimeSeriesEcon.pct"><code>TimeSeriesEcon.pct</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pct(x; islog=false)</code></pre><p>Observation-to-observation percent rate of change in x.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.period-Tuple{Any}" href="#TimeSeriesEcon.period-Tuple{Any}"><code>TimeSeriesEcon.period</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">period(mit)</code></pre><p>Return the period of an <a href="#TimeSeriesEcon.MIT"><code>MIT</code></a>. This is valid only for frequencies subtyped from <a href="#TimeSeriesEcon.YPFrequency"><code>YPFrequency</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.ppy" href="#TimeSeriesEcon.ppy"><code>TimeSeriesEcon.ppy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ppy(x)
ppy(T)</code></pre><p>Return the periods per year for the frequency associated with the given value <code>x</code> or type <code>T</code>. This is valid only for frequencies subtyped from <a href="#TimeSeriesEcon.YPFrequency"><code>YPFrequency</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.qq-Tuple{Integer, Integer}" href="#TimeSeriesEcon.qq-Tuple{Integer, Integer}"><code>TimeSeriesEcon.qq</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">qq(year, period)</code></pre><p>Construct an <code>MIT{Quarterly}</code> from an year and a period.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.rangeof" href="#TimeSeriesEcon.rangeof"><code>TimeSeriesEcon.rangeof</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rangeof(s)</code></pre><p>Return the stored range of the given <a href="#TimeSeriesEcon.TSeries"><code>TSeries</code></a> or <a href="#TimeSeriesEcon.MVTSeries"><code>MVTSeries</code></a> instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.rangeof-Tuple{Union{Workspace, MVTSeries, TSeries}}" href="#TimeSeriesEcon.rangeof-Tuple{Union{Workspace, MVTSeries, TSeries}}"><code>TimeSeriesEcon.rangeof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rangeof(s; drop::Integer)</code></pre><p>Return the stored range of <code>s</code> adjusted by dropping <code>drop</code> periods. If <code>drop</code> is positive, we drop from the beginning and if <code>drop</code> is negative we drop from the end. This adds convenience when using <a href="#TimeSeriesEcon.@rec-Tuple{Any, Any}"><code>@rec</code></a></p><p>Example</p><pre><code class="nohighlight hljs">julia&gt; q = TSeries(20Q1:21Q4);
julia&gt; rangeof(q; drop=1)
20Q2:21Q4

julia&gt; rangeof(q; drop=-4)
20Q1:20Q4

julia&gt; q[begin:begin+1] .= 1;
julia&gt; @rec rangeof(q; drop=2) q[t] = q[t-1] + q[t-2];
julia&gt; q
8-element TSeries{Quarterly} with range 20Q1:21Q4:
    20Q1 : 1.0
    20Q2 : 1.0
    20Q3 : 2.0
    20Q4 : 3.0
    21Q1 : 5.0
    21Q2 : 8.0
    21Q3 : 13.0
    21Q4 : 21.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.rangeof-Tuple{Workspace}" href="#TimeSeriesEcon.rangeof-Tuple{Workspace}"><code>TimeSeriesEcon.rangeof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rangeof(w)</code></pre><p>Calculate the range of a <a href="#TimeSeriesEcon.Workspace"><code>Workspace</code></a> as the intersection of the ranges of all <a href="#TimeSeriesEcon.TSeries"><code>TSeries</code></a>, <a href="#TimeSeriesEcon.MVTSeries"><code>MVTSeries</code></a> and <a href="#TimeSeriesEcon.Workspace"><code>Workspace</code></a> members of <code>w</code>. If there are objects of different frequencies there will be a mixed-frequency error.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.rawdata-Tuple{TSeries}" href="#TimeSeriesEcon.rawdata-Tuple{TSeries}"><code>TimeSeriesEcon.rawdata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rawdata(t)</code></pre><p>Return the raw storage of <code>t</code>. For a <a href="#TimeSeriesEcon.TSeries"><code>TSeries</code></a> this is a <code>Vector</code>. For an <a href="#TimeSeriesEcon.MVTSeries"><code>MVTSeries</code></a> this is a <code>Matrix</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.reindex" href="#TimeSeriesEcon.reindex"><code>TimeSeriesEcon.reindex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reindex(ts, from =&gt; to; copy = false)
reindex(w, from =&gt; to; copy = false)</code></pre><p>The function <code>reindex</code> re-indexes the <code>TSeries</code> or <code>MVTSeries</code> <code>ts</code> or those contained in the <code>Workspace</code> <code>w</code> so that the <code>MIT</code> <code>from</code> becomes the <code>MIT</code> <code>to</code> leaving the data unchanged. For a <code>Workspace</code>, only the <code>TSeries</code> with the same frequency as the first element of the pair will be reindexed.</p><p>By default, the data is not copied.</p><p>Example: With a <code>TSeries</code> or an <code>MVTSeries</code> </p><pre><code class="nohighlight hljs">ts = MVTSeries(2020Q1,(:y1,:y2),randn(10,2))
ts2 = reindex(ts,2021Q1 =&gt; 1U; copy = true)
ts2.y2[3U] = 9999
ts
ts2</code></pre><p>With a <code>Workspace</code></p><pre><code class="nohighlight hljs">w = Workspace();
w.a = TSeries(2020Q1,randn(10))
w.b = TSeries(2021Q1,randn(10))
w.c = 1
w.d = &quot;string&quot;
w1 = reindex(w, 2021Q1 =&gt; 1U)
w2 = reindex(w, 2021Q1 =&gt; 1U; copy = true)
w.a[2020Q1] = 9999
MVTSeries(; w1_a = w1.a, w2_a = w2.a)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.shift!-Tuple{TSeries, Int64}" href="#TimeSeriesEcon.shift!-Tuple{TSeries, Int64}"><code>TimeSeriesEcon.shift!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shift!(x::TSeries, n)</code></pre><p>In-place version of <a href="#TimeSeriesEcon.shift-Tuple{TSeries, Int64}"><code>shift</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.shift-Tuple{TSeries, Int64}" href="#TimeSeriesEcon.shift-Tuple{TSeries, Int64}"><code>TimeSeriesEcon.shift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shift(x::TSeries, n)</code></pre><p>Shift the dates of <code>x</code> by <code>n</code> periods. By convention positive <code>n</code> gives the lead and negative <code>n</code> gives the lag. <code>shift</code> creates a new <a href="#TimeSeriesEcon.TSeries"><code>TSeries</code></a> and copies the data over. See <a href="#TimeSeriesEcon.shift!-Tuple{TSeries, Int64}"><code>shift!</code></a> for in-place version.</p><p>For example:</p><pre><code class="language-julia-repl hljs">julia&gt; shift(TSeries(2020Q1, 1:4), 1)
TSeries{Quarterly} of length 4
2019Q4: 1.0
2020Q1: 2.0
2020Q2: 3.0
2020Q3: 4.0


julia&gt; shift(TSeries(2020Q1, 1:4), -1)
TSeries{Quarterly} of length 4
2020Q2: 1.0
2020Q3: 2.0
2020Q4: 3.0
2021Q1: 4.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.strip!-Tuple{TSeries}" href="#TimeSeriesEcon.strip!-Tuple{TSeries}"><code>TimeSeriesEcon.strip!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">strip!(t::TSeries)</code></pre><p>Remove leading and training <code>NaN</code> from the given time series. This is done in-place.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.strip!-Tuple{Workspace}" href="#TimeSeriesEcon.strip!-Tuple{Workspace}"><code>TimeSeriesEcon.strip!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">strip!(w::Workspace; recursive=true)</code></pre><p>Apply <a href="#TimeSeriesEcon.strip!-Tuple{TSeries}"><code>strip!</code></a> to all TSeries members of the given workspace. This includes nested workspaces, unless <code>recursive=false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.typenan" href="#TimeSeriesEcon.typenan"><code>TimeSeriesEcon.typenan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">typenan(x)
typenan(T)</code></pre><p>Return a value that indicates not-a-number of the same type as the given <code>x</code> or of the given type <code>T</code>.</p><p>For floating point types, this is <code>NaN</code>. For integer types, we use <code>typemax()</code>. This is not ideal, but it&#39;ll do for now.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.undiff" href="#TimeSeriesEcon.undiff"><code>TimeSeriesEcon.undiff</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">undiff(dvar, [date =&gt; value])
undiff!(var, dvar; fromdate=firstdate(dvar)-1)</code></pre><p>Inverse of <code>diff</code>, i.e. <code>var</code> remains unchanged under <code>undiff!(var, diff(var))</code> or <code>undiff(diff(var), firstdate(var)=&gt;first(var))</code>. This is the same as <code>cumsum</code>, but specific to time series.</p><p>In the case of <code>undiff</code> the second argument is an &quot;anchor&quot; <code>Pair</code> specifying a known value at some time period. Typically this will be the period just before the first date of <code>dvar</code>, but doesn&#39;t have to be. If the date falls outside the <code>rangeof(dvar)</code> we extend dvar with zeros as necessary. If missing, this argument defaults to <code>firstdate(dvar)-1 =&gt; 0</code>.</p><p>In the case of <code>undiff!</code>, the <code>var</code> argument provides the &quot;anchor&quot; value and the storage location for the result. The <code>fromdate</code> parameter specifies the date of the &quot;anchor&quot; and the anchor value is taken from <code>var</code>. See important note below.</p><p>The in-place version (<code>undiff!</code>) works only with <code>TSeries</code>. The other version (<code>undiff</code>) works with <code>MVTSeries</code> as well as <code>TSeries</code>. In the case of <code>MVTSeries</code> the anchor <code>value</code> must be a <code>Vector</code>, or a <code>Martix</code> with 1 row, of the same length as the number of columns of <code>dvar</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In the case of <code>undiff!</code> the meaning of parameter <code>fromdate</code> is different from the meaning of <code>date</code> in the second argument of <code>undiff</code>. This only matters if <code>fromdate</code> falls somewhere in the middle of the range of <code>dvar</code>.</p><p>In the case of <code>undiff!</code>, all values of <code>dvar</code> at, and prior to, <code>fromdate</code> are ignored (considered zero). Effectively, values of <code>var</code> up to, and including, <code>fromdate</code> remain unchanged. </p><p>By contrast, in <code>undiff</code> with <code>date =&gt; value</code> somewhere in the middle of the range of <code>dvar</code>, the operation is applied over the full range of <code>dvar</code>, both before and after <code>date</code>, and then the result is adjusted by adding or subtracting a constant such that in the end we have <code>result[date]=value</code>.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.undiff!" href="#TimeSeriesEcon.undiff!"><code>TimeSeriesEcon.undiff!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">undiff(dvar, [date =&gt; value])
undiff!(var, dvar; fromdate=firstdate(dvar)-1)</code></pre><p>Inverse of <code>diff</code>, i.e. <code>var</code> remains unchanged under <code>undiff!(var, diff(var))</code> or <code>undiff(diff(var), firstdate(var)=&gt;first(var))</code>. This is the same as <code>cumsum</code>, but specific to time series.</p><p>In the case of <code>undiff</code> the second argument is an &quot;anchor&quot; <code>Pair</code> specifying a known value at some time period. Typically this will be the period just before the first date of <code>dvar</code>, but doesn&#39;t have to be. If the date falls outside the <code>rangeof(dvar)</code> we extend dvar with zeros as necessary. If missing, this argument defaults to <code>firstdate(dvar)-1 =&gt; 0</code>.</p><p>In the case of <code>undiff!</code>, the <code>var</code> argument provides the &quot;anchor&quot; value and the storage location for the result. The <code>fromdate</code> parameter specifies the date of the &quot;anchor&quot; and the anchor value is taken from <code>var</code>. See important note below.</p><p>The in-place version (<code>undiff!</code>) works only with <code>TSeries</code>. The other version (<code>undiff</code>) works with <code>MVTSeries</code> as well as <code>TSeries</code>. In the case of <code>MVTSeries</code> the anchor <code>value</code> must be a <code>Vector</code>, or a <code>Martix</code> with 1 row, of the same length as the number of columns of <code>dvar</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In the case of <code>undiff!</code> the meaning of parameter <code>fromdate</code> is different from the meaning of <code>date</code> in the second argument of <code>undiff</code>. This only matters if <code>fromdate</code> falls somewhere in the middle of the range of <code>dvar</code>.</p><p>In the case of <code>undiff!</code>, all values of <code>dvar</code> at, and prior to, <code>fromdate</code> are ignored (considered zero). Effectively, values of <code>var</code> up to, and including, <code>fromdate</code> remain unchanged. </p><p>By contrast, in <code>undiff</code> with <code>date =&gt; value</code> somewhere in the middle of the range of <code>dvar</code>, the operation is applied over the full range of <code>dvar</code>, both before and after <code>date</code>, and then the result is adjusted by adding or subtracting a constant such that in the end we have <code>result[date]=value</code>.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.year-Tuple{Any}" href="#TimeSeriesEcon.year-Tuple{Any}"><code>TimeSeriesEcon.year</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">year(mit)</code></pre><p>Return the year of an <a href="#TimeSeriesEcon.MIT"><code>MIT</code></a>. This is valid only for frequencies subtyped from <a href="#TimeSeriesEcon.YPFrequency"><code>YPFrequency</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.ytypct-Tuple{Any}" href="#TimeSeriesEcon.ytypct-Tuple{Any}"><code>TimeSeriesEcon.ytypct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ytypct(x)</code></pre><p>Year-to-year percent change in x. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.yy" href="#TimeSeriesEcon.yy"><code>TimeSeriesEcon.yy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">yy(year, period)</code></pre><p>Construct an <code>MIT{Yearly}</code> from an year and a period.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.@compare" href="#TimeSeriesEcon.@compare"><code>TimeSeriesEcon.@compare</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>@compare x y [options]  compare(x, y [; options])</p><p>Compare two <code>Workspace</code> recursively and print out the differences. <code>MVTSeries</code> and <code>Dict</code> with keys of type <code>Symbol</code> are treated like <code>Workspace</code>. <code>TSeries</code> and other <code>Vector</code> are compared using <code>isapprox</code>, so feel free to supply <code>rtol</code> or <code>atol</code>.</p><p>Optional argument <code>name</code> can be used for the top name. Default is <code>&quot;_&quot;</code>.</p><p>Parameter <code>showequal=true</code> causes the report to include objects that are the same. Default behaviour, with <code>showequal=false</code>, is to report only the differences. </p><p>Parameter <code>ignoremissing=true</code> causes objects that appear in one but not the other workspace to be ignored. That is, they are not printed and do not affect the return value <code>true</code> or <code>false</code>. Default is <code>ignoremissing=false</code> meaning they will be printed and return value will be <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.@rec-Tuple{Any, Any}" href="#TimeSeriesEcon.@rec-Tuple{Any, Any}"><code>TimeSeriesEcon.@rec</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@rec [index=]range expression</code></pre><p>Compute recursive operations on time series. The first argument is the range and the second argument is an expression to be evaluated over that range.</p><p>The expression is meant to be an assignment, but it doesn&#39;t have to be. </p><p>The range specification can include an optional indexing variable name. If not given, the variable name defaults to <code>t</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; s = TSeries(1U)
Empty TSeries{Unit} starting 5U

julia&gt; s[1U] = s[2U] = 1; s
2-element TSeries{Unit} with range 1U:2U:
      1U : 1.0
      2U : 1.0

julia&gt; @rec t=3U:10U s[t] = s[t-1] + s[t-2]

julia&gt; s
10-element TSeries{Unit} with range 1U:10U:
      1U : 1.0
      2U : 1.0
      3U : 2.0
      4U : 3.0
      5U : 5.0
      6U : 8.0
      7U : 13.0
      8U : 21.0
      9U : 34.0
     10U : 55.0</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="TimeSeriesEcon.@showall-Tuple{Any}" href="#TimeSeriesEcon.@showall-Tuple{Any}"><code>TimeSeriesEcon.@showall</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@showall X</code></pre><p>Print all data in <code>X</code> without truncating the output to fit the size of the   screen.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../Tutorials/4.FRB-US/main/">« FRB/US</a><a class="docs-footer-nextpage" href="../ModelBaseEcon/">ModelBaseEcon »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Thursday 7 April 2022 19:12">Thursday 7 April 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
