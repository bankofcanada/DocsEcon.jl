<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ModelBaseEcon · StateSpaceEcon</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="StateSpaceEcon logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">StateSpaceEcon</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../Tutorials/">Introduction</a></li><li><a class="tocitem" href="../../Tutorials/README/">README</a></li><li><a class="tocitem" href="../../Tutorials/TimeSeriesEcon/main/">Time Series</a></li><li><a class="tocitem" href="../../Tutorials/simple_RBC/main/">Simple RBC Model</a></li><li><a class="tocitem" href="../../Tutorials/US_SW07/main/">Smets and Wouters 2007</a></li><li><a class="tocitem" href="../../Tutorials/FRB-US/main/">FRB/US</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../TimeSeriesEcon/">TimeSeriesEcon</a></li><li class="is-active"><a class="tocitem" href>ModelBaseEcon</a><ul class="internal"><li><a class="tocitem" href="#Options"><span>Options</span></a></li><li><a class="tocitem" href="#Timer"><span>Timer</span></a></li><li><a class="tocitem" href="#ModelBaseEcon"><span>ModelBaseEcon</span></a></li></ul></li><li><a class="tocitem" href="../StateSpaceEcon/">StateSpaceEcon</a></li></ul></li><li><span class="tocitem">Design Papers</span><ul><li><a class="tocitem" href="../../DesignPapers/">Design Papers</a></li><li><a class="tocitem" href="../../DesignPapers/final_conditions/">Final Conditions</a></li><li><a class="tocitem" href="../../DesignPapers/log_variables/">Log-variables</a></li></ul></li><li><a class="tocitem" href="../../indexpage/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>ModelBaseEcon</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ModelBaseEcon</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/bankofcanada/DocsEcon.jl/blob/master/src/Reference/ModelBaseEcon.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ModelBaseEcon-Reference"><a class="docs-heading-anchor" href="#ModelBaseEcon-Reference">ModelBaseEcon Reference</a><a id="ModelBaseEcon-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#ModelBaseEcon-Reference" title="Permalink"></a></h1><ul></ul><h2 id="Options"><a class="docs-heading-anchor" href="#Options">Options</a><a id="Options-1"></a><a class="docs-heading-anchor-permalink" href="#Options" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.OptionsMod" href="#ModelBaseEcon.OptionsMod"><code>ModelBaseEcon.OptionsMod</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">OptionsMod</code></pre><p>Sub-module of ModelBaseEcon, although it can be used independently. Implements the <a href="#ModelBaseEcon.OptionsMod.Options"><code>Options</code></a> data structure.</p><p><strong>Contents</strong></p><ul><li><a href="#ModelBaseEcon.OptionsMod.Options"><code>Options</code></a></li><li><a href="#ModelBaseEcon.OptionsMod.getoption"><code>getoption</code></a> - read the value of an option</li><li><a href="#ModelBaseEcon.OptionsMod.getoption!"><code>getoption!</code></a> - if not present, also create an option</li><li><a href="#ModelBaseEcon.OptionsMod.setoption!"><code>setoption!</code></a> - create or update the value of an option </li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.OptionsMod.Options" href="#ModelBaseEcon.OptionsMod.Options"><code>ModelBaseEcon.OptionsMod.Options</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Options</code></pre><p>A collection of key-value pairs representing the options controlling the behaviour or the definition of a Model object. The key is the option name and is always a Symbol, or converted to Symbol, while the value can be anything.</p><p>The options can be accessed using dot notation. Functions <a href="#ModelBaseEcon.OptionsMod.getoption"><code>getoption</code></a> and <a href="#ModelBaseEcon.OptionsMod.setoption!"><code>setoption!</code></a> are also provided. They can be used for programmatic processing of options as well as when the option name is not a valid Julia identifier.</p><p>See also: <a href="#ModelBaseEcon.OptionsMod.Options"><code>Options</code></a>, <a href="#ModelBaseEcon.OptionsMod.getoption"><code>getoption</code></a>, <a href="#ModelBaseEcon.OptionsMod.getoption!"><code>getoption!</code></a>, <a href="#ModelBaseEcon.OptionsMod.setoption!"><code>setoption!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; o = Options(maxiter=20, tol=1e-7)
Options:
    maxiter=20
    tol=1.0e-7

julia&gt; o.maxiter = 25
25

julia&gt; o
Options:
    maxiter=25
    tol=1.0e-7
</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.OptionsMod.Options-Tuple{Options}" href="#ModelBaseEcon.OptionsMod.Options-Tuple{Options}"><code>ModelBaseEcon.OptionsMod.Options</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Options(::Options)</code></pre><p>Construct an Options instance as an exact copy of an existing instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.OptionsMod.Options-Tuple{}" href="#ModelBaseEcon.OptionsMod.Options-Tuple{}"><code>ModelBaseEcon.OptionsMod.Options</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Options(key=value, ...)
Options(:key=&gt;value, ...)</code></pre><p>Construct an Options instance with key-value pairs given as keyword arguments or as a list of pairs. If the latter is used, each key must be a <code>Symbol</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.OptionsMod.getoption" href="#ModelBaseEcon.OptionsMod.getoption"><code>ModelBaseEcon.OptionsMod.getoption</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getoption(o::Options; name=default [, name=default, ...])
getoption(o::Options, name, default)</code></pre><p>Retrieve the value of an option or a set of options.  The provided defaults are used when the option doesn&#39;t exit.</p><p>The return value is the value of the option requested or, if the option doesn&#39;t exist, the default. In the first version of the function, if there are more than one options requested, the return value is a tuple.</p><p>In the second version, the name could be a symbol or a string, which can be helpful if the name of the option is not a valid identifier.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.OptionsMod.getoption!" href="#ModelBaseEcon.OptionsMod.getoption!"><code>ModelBaseEcon.OptionsMod.getoption!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getoption!(o::Options; name=default [, name=default, ...])
getoption!(o::Options, name, default)</code></pre><p>Retrieve the value of an option or a set of options. If the name does not match an existing option, the Options instance is updated by inserting the given name and default value.</p><p>The return value is the value of the option requested (or the default). In the first version of the function, if there are more than one options requested, the return value is a tuple.</p><p>In the second version, the name could be a symbol or a string, which can be helpful if the name of the option is not a valid identifier.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.OptionsMod.setoption!" href="#ModelBaseEcon.OptionsMod.setoption!"><code>ModelBaseEcon.OptionsMod.setoption!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setoption!(o::Options; name=default [, name=default, ...])
setoption!(o::Options, name, default)</code></pre><p>Retrieve the value of an option or a set of options. If the name does not match an existing option, the Options instance is updated by inserting the given name and default value.</p><p>The return value is the value of the option requested (or the default). In the first version of the function, if there are more than one options requested, the return value is a tuple.</p><p>In the second version, the name could be a symbol or a string, which can be helpful if the name of the option is not a valid identifier.</p></div></section></article><h2 id="Timer"><a class="docs-heading-anchor" href="#Timer">Timer</a><a id="Timer-1"></a><a class="docs-heading-anchor-permalink" href="#Timer" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.Timer" href="#ModelBaseEcon.Timer"><code>ModelBaseEcon.Timer</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">Timer</code></pre><p>A sub-module of ModelBaseEcon, although it can be used independently. Provides functionality for measuring the aggregate time spent in individual lines or blocks of code.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The implementation here is quick-and-dirty and is intended for getting a rough idea of where the bottlenecks are. It is best used for timing blocks of code that are passed through relatively few times and each pass takes a relatively long time. In the opposite extreme case (fast code that is called many times), the current implementation of <code>@timer</code> might add extreme overhead.</p></div></div><p><strong>Contents</strong></p><ul><li><a href="#ModelBaseEcon.Timer.inittimer-Tuple{}"><code>inittimer</code></a>       - Enable collection of timer data.</li><li><a href="#ModelBaseEcon.Timer.stoptimer-Tuple{}"><code>stoptimer</code></a>       - Disable collection of timer data.</li><li><a href="#ModelBaseEcon.Timer.printtimer"><code>printtimer</code></a>      - Display timer data.</li><li><a href="#ModelBaseEcon.Timer.@timer-Tuple"><code>@timer</code></a>          - Measure the runtime taken by the given code.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; true
[...]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.Timer.inittimer-Tuple{}" href="#ModelBaseEcon.Timer.inittimer-Tuple{}"><code>ModelBaseEcon.Timer.inittimer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inittimer()</code></pre><p>Enable the collection of timing data. Existing timing data is lost. By default, collection of timing data is disabled.</p><p>See also: <a href="#ModelBaseEcon.Timer.stoptimer-Tuple{}"><code>stoptimer</code></a>, <a href="#ModelBaseEcon.Timer.@timer-Tuple"><code>@timer</code></a>, <a href="#ModelBaseEcon.Timer.printtimer"><code>printtimer</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.Timer.printtimer" href="#ModelBaseEcon.Timer.printtimer"><code>ModelBaseEcon.Timer.printtimer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">printtimer(io::IO=Base.stdout)</code></pre><p>Display timing data.</p><p>Timing data is displayed in a table with each row containing the number of calls, total time in seconds, and the source line or block tag. Rows are sorted in order of decreasing total time.</p><p>See also: <a href="#ModelBaseEcon.Timer.@timer-Tuple"><code>@timer</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.Timer.stoptimer-Tuple{}" href="#ModelBaseEcon.Timer.stoptimer-Tuple{}"><code>ModelBaseEcon.Timer.stoptimer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stoptimer()</code></pre><p>Disable the collection of timing data. Existing data is lost. By default, collection of timing data is disabled.</p><p>See also: <a href="#ModelBaseEcon.Timer.inittimer-Tuple{}"><code>inittimer</code></a>, <a href="#ModelBaseEcon.Timer.@timer-Tuple"><code>@timer</code></a>, <a href="#ModelBaseEcon.Timer.printtimer"><code>printtimer</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.Timer.@timer-Tuple" href="#ModelBaseEcon.Timer.@timer-Tuple"><code>ModelBaseEcon.Timer.@timer</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@timer(code)
@timer(tag::String, code)</code></pre><p>Measure the number of calls and the total time taken by the given code.</p><p>If a <code>tag</code> string is not provided, one is generated from the source file and line. The return value of this macro call is the return value of the code.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Important limitation is that the code must not contain a <code>return</code>, <code>break</code>, <code>continue</code>, or any other jump out of it. If it does, the program would run correctly, but the timing data collected would be incorrect.</p></div></div><p>See also: <a href="#ModelBaseEcon.Timer.inittimer-Tuple{}"><code>inittimer</code></a>, <a href="#ModelBaseEcon.Timer.stoptimer-Tuple{}"><code>stoptimer</code></a>, <a href="#ModelBaseEcon.Timer.printtimer"><code>printtimer</code></a></p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; inittimer()

julia&gt; @timer Base.sleep(1.0)

julia&gt; printtimer()
[...]</code></pre></div></section></article><h2 id="ModelBaseEcon"><a class="docs-heading-anchor" href="#ModelBaseEcon">ModelBaseEcon</a><a id="ModelBaseEcon-1"></a><a class="docs-heading-anchor-permalink" href="#ModelBaseEcon" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.ModelBaseEcon" href="#ModelBaseEcon.ModelBaseEcon"><code>ModelBaseEcon.ModelBaseEcon</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">ModelBaseEcon</code></pre><p>This package is part of the StateSpaceEcon ecosystem.  It contains the basic elements needed for model definition. StateSpaceEcon works with model objects defined with ModelBaseEcon.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.Equation" href="#ModelBaseEcon.Equation"><code>ModelBaseEcon.Equation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Equation &lt;: AbstractEquation</code></pre><p>Data structure representing a single equation in our state space model.</p><p><strong>Methods (for users)</strong></p><ul><li>TODO</li></ul><p><strong>Implementation (for developers)</strong></p><p>During the phase of definition of the Model, this type simply stores the expression entered by the user. During @initialize(), the true data structure is constructed. We need this, because the construction of the equation requires information from the Model object, which may not be available at the time the equation expression is first read.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.LinearizationError" href="#ModelBaseEcon.LinearizationError"><code>ModelBaseEcon.LinearizationError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearizationError &lt;: ModelErrorBase</code></pre><p>A concrete error type used when a model cannot be linearized for some reason.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.LogTransform" href="#ModelBaseEcon.LogTransform"><code>ModelBaseEcon.LogTransform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LogTransform &lt;: Transformation</code></pre><p>The <code>log</code> transformation. The inverse is of course <code>exp</code>. This is the default for variables declared with <code>@log</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.Model" href="#ModelBaseEcon.Model"><code>ModelBaseEcon.Model</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Model &lt;: AbstractModel</code></pre><p>Data structure that represents a macroeconomic state space model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.ModelError" href="#ModelBaseEcon.ModelError"><code>ModelBaseEcon.ModelError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ModelError &lt;: ModelErrorBase</code></pre><p>Concrete error type used when no specific error description is available.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.ModelErrorBase" href="#ModelBaseEcon.ModelErrorBase"><code>ModelBaseEcon.ModelErrorBase</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ModelErrorBase</code></pre><p>Abstract error type, base for specific error types used in ModelBaseEcon.</p><p><strong>Implementation (note for developers)</strong></p><p>When implementing a derived error type, override two functions:</p><ul><li><code>msg(e::SomeModelError)</code> returning a string with the error message;</li><li><code>hint(e::SomeModelError)</code> returning a string containing a suggestion of how to fix the problem. Optional, if not implemented for a type, the fallback implementation returns an empty string.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.ModelNotInitError" href="#ModelBaseEcon.ModelNotInitError"><code>ModelBaseEcon.ModelNotInitError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ModelNotInitError &lt;: ModelErrorBase</code></pre><p>Specific error type used when there&#39;s an attempt to use a Model object that has not been initialized.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.ModelParam" href="#ModelBaseEcon.ModelParam"><code>ModelBaseEcon.ModelParam</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct ModelParam</code></pre><p>Contains a model parameter. For a simple parameter it simply stores its value. For a link or an alias, it stores the link information and also caches the current value for speed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.NegLogTransform" href="#ModelBaseEcon.NegLogTransform"><code>ModelBaseEcon.NegLogTransform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NegLogTransform &lt;: Transformation</code></pre><p>The <code>log(-x)</code>, with the inverse being <code>-exp(x)</code>. Use this when the variable is negative with exponential behaviour (toward -∞).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.NoTransform" href="#ModelBaseEcon.NoTransform"><code>ModelBaseEcon.NoTransform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoTransform &lt;: Transformation</code></pre><p>The identity transformation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.NotImplementedError" href="#ModelBaseEcon.NotImplementedError"><code>ModelBaseEcon.NotImplementedError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NotImplementedError &lt;: ModelErrorBase</code></pre><p>Specific error type used when a feature is planned but not yet implemented. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.Parameters" href="#ModelBaseEcon.Parameters"><code>ModelBaseEcon.Parameters</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Parameters &lt;: AbstractDict{Symbol, Any}</code></pre><p>Container for model parameters. It functions as a <code>Dict</code> where the keys are the parameter names. Simple parameter values are stored directly. Special parameters depend on other parameters are are wrapped in the appropriate data structures to keep track of such dependencies. There are two types of special parameters - aliases and links.</p><p>Individual parameters can be accessed in two different ways - dot and bracket notation.</p><p>Read access by dot notation calls <a href="#ModelBaseEcon.peval-Tuple{Any, Any}"><code>peval</code></a> while bracket notation doesn&#39;t. This makes no difference for simple parameters. For special parameters, access by bracket notation returns its internal structure, while access by dot notation returns its current value depending on other parameters.</p><p>Write access is the same in both dot and bracket notation. The new parameter value is assigned directly in the case of simple parameter. To create an alias parameter, use the <a href="#ModelBaseEcon.@alias-Tuple{Any}"><code>@alias</code></a> macro. To create a link parameter use the <a href="#ModelBaseEcon.@link-Tuple{Any}"><code>@link</code></a> macro.</p><p>See also: <a href="#ModelBaseEcon.ModelParam"><code>ModelParam</code></a>, <a href="#ModelBaseEcon.peval-Tuple{Any, Any}"><code>peval</code></a>, <a href="#ModelBaseEcon.@alias-Tuple{Any}"><code>@alias</code></a>, <a href="#ModelBaseEcon.@link-Tuple{Any}"><code>@link</code></a>, <a href="#ModelBaseEcon.update_links!-Tuple{ModelBaseEcon.AbstractModel}"><code>update_links!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.Parameters" href="#ModelBaseEcon.Parameters"><code>ModelBaseEcon.Parameters</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Parameters([mod::Module])</code></pre><p>When creating an instance of <code>Parameters</code>, optionally one can specify the module in which parameter expressions will be evaluated. This only matters if there are any link parameters that depend on custom functions or global variables/constants. In this case, the <code>mod</code> argument should be the module in which these definitions exist.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.SteadyStateData" href="#ModelBaseEcon.SteadyStateData"><code>ModelBaseEcon.SteadyStateData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SteadyStateData</code></pre><p>Data structure that holds information about the steady state solution of the Model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.SteadyStateEquation" href="#ModelBaseEcon.SteadyStateEquation"><code>ModelBaseEcon.SteadyStateEquation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SteadyStateEquation &lt;: AbstractEquation</code></pre><p>Data structure representing an individual steady state equation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.Transformation" href="#ModelBaseEcon.Transformation"><code>ModelBaseEcon.Transformation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Transformation end</code></pre><p>The base class for all variable transformations.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.add_equation!-Tuple{Model, Expr}" href="#ModelBaseEcon.add_equation!-Tuple{Model, Expr}"><code>ModelBaseEcon.add_equation!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_equation!(model::Model, expr::Expr; modelmodule::Module)</code></pre><p>Process the given expression in the context of the given module, create the Equation() instance for it and add it to the model instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.alleqns-Tuple{SteadyStateData}" href="#ModelBaseEcon.alleqns-Tuple{SteadyStateData}"><code>ModelBaseEcon.alleqns</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alleqns(ssd::SteadyStateData)</code></pre><p>Return a list of all steady state equations.</p><p>The list contains all equations derived from the dynamic system and all explicitly added steady state constraints.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.assign_parameters!-Tuple{Union{ModelBaseEcon.AbstractModel, Parameters}}" href="#ModelBaseEcon.assign_parameters!-Tuple{Union{ModelBaseEcon.AbstractModel, Parameters}}"><code>ModelBaseEcon.assign_parameters!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">assign_parameters!(model, collection; [options])
assign_parameters!(model; [options], param=value, ...)</code></pre><p>Assign values to model parameters. New parameters can be given as key-value pairs in the function call, or in a collection, such as a <code>Dict</code> or a <code>NamedTuple</code>. Individual parameters can be assigned directly to the <code>model</code> using dot-notation. This function should be more convenient when all parameters values are loaded from a file and available in a dictionary or some other key-value collection.</p><p>There are two options that control the behaviour.</p><ul><li><code>preserve_links=true</code> - if set to <code>true</code> new values for link-parameters are ignored and the link is updated automatically from the new values of parameters it depends on. If set to <code>false</code> any link parameters are overwritten and become non-link parameters set to the given new values.</li><li><code>check=true</code> - if a parameter with the given name does not exist we ignore it. When <code>check</code> is set to <code>true</code> we issue a warning, when set to <code>false</code> we ignore it silently.</li></ul><p>Example</p><pre><code class="nohighlight hljs">julia&gt; @using_example E1
julia&gt; assign_parameters(E1.model; α=0.3, β=0.7)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.eval_R!" href="#ModelBaseEcon.eval_R!"><code>ModelBaseEcon.eval_R!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eval_R!(res::AbstractArray{Float64,1}, point::AbstractArray{Float64, 2}, ::MED) where MED &lt;: AbstractModelEvaluationData</code></pre><p>Evaluate the model residual at the given point using the given model evaluation structure. The residual is stored in the provided vector.</p><p><strong>Implementation details (for developers)</strong></p><p>When creating a new type of model evaluation data, you must define a method of this function specialized to it.</p><p>The <code>point</code> argument will be a 2d array, with the number of rows equal to <code>maxlag+maxlead+1</code> and the number of columns equal to the number of <code>variables+shocks+auxvars</code> of the model. The <code>res</code> vector will have the same length as the number of equations + auxiliary equations. Your implementation must not modify <code>point</code> and must update <code>res</code>.</p><p>See also: <a href="#ModelBaseEcon.eval_RJ"><code>eval_RJ</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.eval_RJ" href="#ModelBaseEcon.eval_RJ"><code>ModelBaseEcon.eval_RJ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eval_RJ(point::AbstractArray{Float64, 2}, ::MED) where MED &lt;: AbstractModelEvaluationData</code></pre><p>Evaluate the model residual and its Jacobian at the given point using the given model evaluation structure. Return a tuple, with the first element being the residual and the second element being the Jacobian.</p><p><strong>Implementation details (for developers)</strong></p><p>When creating a new type of model evaluation data, you must define a method of this function specialized to it.</p><p>The <code>point</code> argument will be a 2d array, with the number of rows equal to <code>maxlag+maxlead+1</code> and the number of columns equal to the number of <code>variables+shocks+auxvars</code> of the model. Your implementation must not modify <code>point</code> and must return the tuple of (residual, Jacobian) evaluated at the given <code>point</code>. The Jacobian is expected to be <code>SparseMatrixCSC</code> (<em>this might change in the future</em>).</p><p>See also: <a href="#ModelBaseEcon.eval_R!"><code>eval_R!</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.export_model" href="#ModelBaseEcon.export_model"><code>ModelBaseEcon.export_model</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">export_model(model, name, file::IO)
export_model(model, name, path::String)</code></pre><p>Export the model into a module file. The <code>name</code> parameter is used for the name of the module as well as the module file. The module file is created in the directory specified by the optional third argument.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.geteqn-Tuple{Integer, SteadyStateData}" href="#ModelBaseEcon.geteqn-Tuple{Integer, SteadyStateData}"><code>ModelBaseEcon.geteqn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">geteqn(i, ssd::SteadyStateData)</code></pre><p>Return the i-th steady state equation. Index i is interpreted as in the output of <code>alleqns</code>. Calling <code>geteqn(i, sdd)</code> has the same effect as <code>alleqn(ssd)[i]</code>, but it&#39;s more efficient.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Iterate all equations like this:
for i = 1:neqns(ssd)
    eqn = geteqn(i, ssd)
    # do something awesome with `eqn` and `i`
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.inverse_transformation" href="#ModelBaseEcon.inverse_transformation"><code>ModelBaseEcon.inverse_transformation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inverse_transformation(::Type{&lt;:Transformation})</code></pre><p>Return a <code>Function</code> that will be called to transform the simulation data after solving. See also <a href="#ModelBaseEcon.transformation"><code>transformation</code></a>.</p><p>It is expected that <code>transformation(T) ∘ inverse_transformation(T) == identity</code> and <code>inverse_transformation(T) ∘ transformation(T) == identity</code>, but these is not verified.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.islinearized-Tuple{Model}" href="#ModelBaseEcon.islinearized-Tuple{Model}"><code>ModelBaseEcon.islinearized</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">islinearized(m::Model)</code></pre><p>Return <code>true</code> if the given model is linearized and <code>false</code> otherwise.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.issssolved-Tuple{SteadyStateData}" href="#ModelBaseEcon.issssolved-Tuple{SteadyStateData}"><code>ModelBaseEcon.issssolved</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">issssolved(sstate::SteadyStateData)</code></pre><p>Return <code>true</code> if the steady state has been solved, or <code>false</code> otherwise.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.linearize!" href="#ModelBaseEcon.linearize!"><code>ModelBaseEcon.linearize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">linearize!(model::Model; &lt;keyword arguments&gt;)</code></pre><p>Transform model into its linear approximation about its steady state.</p><p><strong>Keyword arguments</strong></p><ul><li><code>sstate</code> - linearize about the provided steady state solution</li><li><code>deviation</code>::Bool - whether or not the linearized model will treat data passed to it as deviation from the steady state</li></ul><p>See also: <a href="#ModelBaseEcon.linearized-Tuple{Model}"><code>linearized</code></a> and <a href="#ModelBaseEcon.with_linearized-Tuple{Function, Model}"><code>with_linearized</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.linearized-Tuple{Model}" href="#ModelBaseEcon.linearized-Tuple{Model}"><code>ModelBaseEcon.linearized</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">linearized(model::Model; &lt;arguments&gt;)</code></pre><p>Create a new model that is the linear approximation of the given model about its steady state.</p><p><strong>Keyword arguments</strong></p><ul><li><code>sstate</code> - linearize about the provided steady state solution</li><li><code>deviation</code>::Bool - whether or not the linearized model will tread data passed </li></ul><p>to is as deviation from the steady state</p><p>See also: <a href="#ModelBaseEcon.linearize!"><code>linearize!</code></a> and <a href="#ModelBaseEcon.with_linearized-Tuple{Function, Model}"><code>with_linearized</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.logm-Tuple{Any}" href="#ModelBaseEcon.logm-Tuple{Any}"><code>ModelBaseEcon.logm</code></a> — <span class="docstring-category">Method</span></header><section><div><p>logm(x) = log(-x)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.mexp-Tuple{Any}" href="#ModelBaseEcon.mexp-Tuple{Any}"><code>ModelBaseEcon.mexp</code></a> — <span class="docstring-category">Method</span></header><section><div><p>mexp(x) = -exp(x)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.neqns-Tuple{SteadyStateData}" href="#ModelBaseEcon.neqns-Tuple{SteadyStateData}"><code>ModelBaseEcon.neqns</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neqns(ssd::SteadyStateData)</code></pre><p>Return the total number of equations in the steady state system, including the ones derived from the dynamic system and the ones added explicitly as steady state constraints.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.peval-Tuple{Any, Any}" href="#ModelBaseEcon.peval-Tuple{Any, Any}"><code>ModelBaseEcon.peval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">peval(params, what)</code></pre><p>Evaluate the given expression in the context of the given parameters.</p><p>If <code>what</code> is a <code>ModelParam</code>, its current value is returned. If there&#39;s a chance it might be out of date, call <a href="#ModelBaseEcon.update_links!-Tuple{ModelBaseEcon.AbstractModel}"><code>update_links!</code></a>.</p><p>If <code>what</code> is a Symbol or an Expr, all mentions of parameter names are substituted by their values and the the expression is evaluated.</p><p>If <code>what is any other value, it is returned unchanged.</code></p><p>See also: <a href="#ModelBaseEcon.Parameters"><code>Parameters</code></a>, <a href="#ModelBaseEcon.@alias-Tuple{Any}"><code>@alias</code></a>, <a href="#ModelBaseEcon.@link-Tuple{Any}"><code>@link</code></a>, <a href="#ModelBaseEcon.ModelParam"><code>ModelParam</code></a>, <a href="#ModelBaseEcon.update_links!-Tuple{ModelBaseEcon.AbstractModel}"><code>update_links!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.printsstate-Tuple{IO, ModelBaseEcon.AbstractModel}" href="#ModelBaseEcon.printsstate-Tuple{IO, ModelBaseEcon.AbstractModel}"><code>ModelBaseEcon.printsstate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">printsstate([io::IO,] ssd::SteadyStateData)</code></pre><p>Display steady state solution.</p><p>Steady state solution is presented in a table, where the first column is the name of the variable, the second and third columns are the corresponding values of the level and the slope. If the value is not determined (as per its <code>mask</code> value) then it is displayed as &quot;*&quot;.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.selective_linearize!-Tuple{ModelBaseEcon.AbstractModel}" href="#ModelBaseEcon.selective_linearize!-Tuple{ModelBaseEcon.AbstractModel}"><code>ModelBaseEcon.selective_linearize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">selective_linearize!(model)</code></pre><p>Instruct the model instance to use selective linearization. Only equations annotated with <code>@lin</code> in the model definition will be linearized about the current steady state solution while the rest of the eq</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.transformation" href="#ModelBaseEcon.transformation"><code>ModelBaseEcon.transformation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transformation(::Type{&lt;:Transformation})</code></pre><p>Return a <code>Function</code> that will be substituted into the model equations and will be called to transform the input data before solving. See also <a href="#ModelBaseEcon.inverse_transformation"><code>inverse_transformation</code></a>.</p><p>It is expected that <code>transformation(T) ∘ inverse_transformation(T) == identity</code> and <code>inverse_transformation(T) ∘ transformation(T) == identity</code>, but these is not verified.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.update_links!-Tuple{ModelBaseEcon.AbstractModel}" href="#ModelBaseEcon.update_links!-Tuple{ModelBaseEcon.AbstractModel}"><code>ModelBaseEcon.update_links!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_links!(model)
update_links!(params)</code></pre><p>Recompute the current values of all parameters.</p><p>Typically when a new value of a parameter is assigned, all parameter links and aliases that depend on it are updated recursively. If a parameter is mutable, e.g. a Vector or another collection, its value can be updated in place without re-assigning it, thus the automatic update does not happen. In this case, it is necessary to call <code>update_links!</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.with_linearized-Tuple{Function, Model}" href="#ModelBaseEcon.with_linearized-Tuple{Function, Model}"><code>ModelBaseEcon.with_linearized</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">with_linearized(F::Function, model::Model; &lt;arguments&gt;)</code></pre><p>Apply the given function on a new model that is the linear approximation  of the given model about its steady state.  This is meant to be used with the <code>do</code> syntax, as in the example below.</p><p><strong>Keyword arguments</strong></p><ul><li><code>sstate</code> - linearize about the provided steady state solution</li><li><code>deviation</code>::Bool - whether or not the linearized model will tread data passed </li></ul><p>to is as deviation from the steady state</p><p>See also: <a href="#ModelBaseEcon.linearize!"><code>linearize!</code></a> and <a href="#ModelBaseEcon.with_linearized-Tuple{Function, Model}"><code>with_linearized</code></a></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">with_linearized(m) do lm
    # do something awesome with linearized model `lm`
end
# model `m` is still non-linear.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@alias-Tuple{Any}" href="#ModelBaseEcon.@alias-Tuple{Any}"><code>ModelBaseEcon.@alias</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@alias name

Create a parameter alias. Use `@alias` in the [`@parameters`](@ref) section of your</code></pre><p>model definition.</p><pre><code class="nohighlight hljs">@parameters model begin
    a = 5
    b = @alias a
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@autoexogenize-Tuple{Any, Vararg{Expr, N} where N}" href="#ModelBaseEcon.@autoexogenize-Tuple{Any, Vararg{Expr, N} where N}"><code>ModelBaseEcon.@autoexogenize</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@autoexogenize model begin
    varname = shkname
    ...
end</code></pre><p>Define a mapping between variables and shocks that can be used to conveniently  swap exogenous and endogenous variables.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@autoshocks" href="#ModelBaseEcon.@autoshocks"><code>ModelBaseEcon.@autoshocks</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@autoshocks model</code></pre><p>Create a list of shocks that matches the list of variables.  Each shock name is created from a variable name by appending &quot;_shk&quot;.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@d-Tuple" href="#ModelBaseEcon.@d-Tuple"><code>ModelBaseEcon.@d</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">$</code></pre><p>Interpolation operator for interpolating into e.g. <a href="Reference/@ref string-interpolation">strings</a> and <a href="Reference/@ref man-expression-interpolation">expressions</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; name = &quot;Joe&quot;
&quot;Joe&quot;

julia&gt; &quot;My name is $name.&quot;
&quot;My name is Joe.&quot;</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@dlog-Tuple" href="#ModelBaseEcon.@dlog-Tuple"><code>ModelBaseEcon.@dlog</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">$</code></pre><p>Interpolation operator for interpolating into e.g. <a href="Reference/@ref string-interpolation">strings</a> and <a href="Reference/@ref man-expression-interpolation">expressions</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; name = &quot;Joe&quot;
&quot;Joe&quot;

julia&gt; &quot;My name is $name.&quot;
&quot;My name is Joe.&quot;</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@equations-Tuple{Any, Expr}" href="#ModelBaseEcon.@equations-Tuple{Any, Expr}"><code>ModelBaseEcon.@equations</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Usage example:</p><pre><code class="nohighlight hljs">@equations model begin
    y[t] = a * y[t-1] + b * y[t+1] + y_shk[t]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@initialize-Tuple{Symbol}" href="#ModelBaseEcon.@initialize-Tuple{Symbol}"><code>ModelBaseEcon.@initialize</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@initialize model</code></pre><p>Prepare a model instance for analysis. Call this macro after all variable names, shock names and equations have been defined.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@lag-Tuple" href="#ModelBaseEcon.@lag-Tuple"><code>ModelBaseEcon.@lag</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">$</code></pre><p>Interpolation operator for interpolating into e.g. <a href="Reference/@ref string-interpolation">strings</a> and <a href="Reference/@ref man-expression-interpolation">expressions</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; name = &quot;Joe&quot;
&quot;Joe&quot;

julia&gt; &quot;My name is $name.&quot;
&quot;My name is Joe.&quot;</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@lead-Tuple" href="#ModelBaseEcon.@lead-Tuple"><code>ModelBaseEcon.@lead</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">$</code></pre><p>Interpolation operator for interpolating into e.g. <a href="Reference/@ref string-interpolation">strings</a> and <a href="Reference/@ref man-expression-interpolation">expressions</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; name = &quot;Joe&quot;
&quot;Joe&quot;

julia&gt; &quot;My name is $name.&quot;
&quot;My name is Joe.&quot;</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@link-Tuple{Any}" href="#ModelBaseEcon.@link-Tuple{Any}"><code>ModelBaseEcon.@link</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@link expr</code></pre><p>Create a parameter link. Use <code>@link</code> in the <a href="#ModelBaseEcon.@parameters-Tuple{Any, Vararg{Expr, N} where N}"><code>@parameters</code></a> section of your model definition.</p><p>If your parameter depends on other parameters, then you use <code>@link</code> to declare that. The expression can be any valid Julia code.</p><pre><code class="nohighlight hljs">@parameters model begin
    a = 5
    b = @link a + 1
end</code></pre><p>When a parameter the link depends on is assigned a new value, the link that depends on it gets updated automatically.</p><div class="admonition is-info"><header class="admonition-header">Important note</header><div class="admonition-body"><p>There are two cases in which the value of a link does not get updated automatically. If the parameter it depends on is mutable, e.g. a <code>Vector</code>, it is possible for it to get updated in place. The other case is when the link contains global variable or custom function.</p><p>In such case, it is necessary to call <a href="#ModelBaseEcon.update_links!-Tuple{ModelBaseEcon.AbstractModel}"><code>update_links!</code></a>.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@load_example-Tuple{Any}" href="#ModelBaseEcon.@load_example-Tuple{Any}"><code>ModelBaseEcon.@load_example</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Deprecated. Use <code>@using_example</code> instead.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@movav-Tuple" href="#ModelBaseEcon.@movav-Tuple"><code>ModelBaseEcon.@movav</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">$</code></pre><p>Interpolation operator for interpolating into e.g. <a href="Reference/@ref string-interpolation">strings</a> and <a href="Reference/@ref man-expression-interpolation">expressions</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; name = &quot;Joe&quot;
&quot;Joe&quot;

julia&gt; &quot;My name is $name.&quot;
&quot;My name is Joe.&quot;</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@movsum-Tuple" href="#ModelBaseEcon.@movsum-Tuple"><code>ModelBaseEcon.@movsum</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">$</code></pre><p>Interpolation operator for interpolating into e.g. <a href="Reference/@ref string-interpolation">strings</a> and <a href="Reference/@ref man-expression-interpolation">expressions</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; name = &quot;Joe&quot;
&quot;Joe&quot;

julia&gt; &quot;My name is $name.&quot;
&quot;My name is Joe.&quot;</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@parameters-Tuple{Any, Vararg{Expr, N} where N}" href="#ModelBaseEcon.@parameters-Tuple{Any, Vararg{Expr, N} where N}"><code>ModelBaseEcon.@parameters</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@parameters model begin
    name = value
    ...
end</code></pre><p>Declare and define the model parameters. </p><p>The parameters must have values. Provide the information in a series of assignment statements wrapped inside a begin-end block. The names can be used in equations as if they were regular variables.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@parameters-Tuple{}" href="#ModelBaseEcon.@parameters-Tuple{}"><code>ModelBaseEcon.@parameters</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">params = @parameters</code></pre><p>When called without any arguments, return an empty <a href="#ModelBaseEcon.Parameters"><code>Parameters</code></a> container, with its evaluation module set to the module in which the macro is being called.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@shocks-Tuple{Any, Expr}" href="#ModelBaseEcon.@shocks-Tuple{Any, Expr}"><code>ModelBaseEcon.@shocks</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@shocks model names...
@shocks model begin
    names...
end</code></pre><p>Define the names of transition shocks in the model.</p><p><strong>Example</strong></p><p>```jldoctest @shocks model a<em>shk b</em>shk c_shk</p><p><strong>If the list is long, use a begin-end block separating names with newline or semicolon</strong></p><p>@shocks model begin     a<em>shk; b</em>shk     c_shk end ````</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@steadystate-Tuple{Any, Symbol, Expr}" href="#ModelBaseEcon.@steadystate-Tuple{Any, Symbol, Expr}"><code>ModelBaseEcon.@steadystate</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@steadystate model [type] equation</code></pre><p>Add a steady state equation to the model.</p><p>The steady state system of the model is automatically derived from the dynamic system. Use this macro to define additional equations for the steady state. This is particularly useful in the case of a non-linear model that might have multiple steady state, or the steady state might be difficult to solve for, to help the steady state solver find the one you want to use.</p><ul><li><code>model</code> is the model instance you want to update</li><li><code>type</code> (optional) is the type of constraint you want to add. This can be <code>level</code></li></ul><p>or <code>slope</code>. If missing, the default is <code>level</code></p><ul><li><code>equation</code> is the expression defining the steady state constraint. In the</li></ul><p>equation, use variables and shocks from the model, but without any t-references.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@using_example-Tuple{Any}" href="#ModelBaseEcon.@using_example-Tuple{Any}"><code>ModelBaseEcon.@using_example</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@using_example name</code></pre><p>Load models from the package examples/ folder. The <code>@load_example</code> version is deprecated - stop using it now.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@variables-Tuple{Any, Expr}" href="#ModelBaseEcon.@variables-Tuple{Any, Expr}"><code>ModelBaseEcon.@variables</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@variables model names...
@variables model begin
    names...
end</code></pre><p>Define the names of transition variables in the model.</p><p><strong>Example</strong></p><p>```jldoctest @variables model a b c</p><p><strong>If the list is long, use a begin-end block separating names with newline or semicolon</strong></p><p>@variables model begin     a; b     c end ````</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../TimeSeriesEcon/">« TimeSeriesEcon</a><a class="docs-footer-nextpage" href="../StateSpaceEcon/">StateSpaceEcon »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Wednesday 30 March 2022 15:26">Wednesday 30 March 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
