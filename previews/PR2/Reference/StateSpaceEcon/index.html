<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>StateSpaceEcon · StateSpaceEcon</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="StateSpaceEcon logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">StateSpaceEcon</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../Tutorials/">Introduction</a></li><li><a class="tocitem" href="../../Tutorials/README/">README</a></li><li><a class="tocitem" href="../../Tutorials/TimeSeriesEcon/main/">TimeSeriesEcon</a></li><li><a class="tocitem" href="../../Tutorials/simple_RBC/main/">Simple RBC Model</a></li><li><a class="tocitem" href="../../Tutorials/US_SW07/main/">Smets and Wouters 2007</a></li><li><a class="tocitem" href="../../Tutorials/FRB-US/main/">FRB/US</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../TimeSeriesEcon/">TimeSeriesEcon</a></li><li><a class="tocitem" href="../ModelBaseEcon/">ModelBaseEcon</a></li><li class="is-active"><a class="tocitem" href>StateSpaceEcon</a><ul class="internal"><li><a class="tocitem" href="#Steady-state-solver"><span>Steady state solver</span></a></li><li><a class="tocitem" href="#Plans"><span>Plans</span></a></li><li><a class="tocitem" href="#Stacked-time-solver"><span>Stacked time solver</span></a></li><li><a class="tocitem" href="#Various"><span>Various</span></a></li></ul></li></ul></li><li><span class="tocitem">Design Papers</span><ul><li><a class="tocitem" href="../../DesignPapers/">Design Papers</a></li><li><a class="tocitem" href="../../DesignPapers/final_conditions/">Final Conditions</a></li><li><a class="tocitem" href="../../DesignPapers/log_variables/">Log-variables</a></li></ul></li><li><a class="tocitem" href="../../indexpage/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>StateSpaceEcon</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>StateSpaceEcon</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/bankofcanada/DocsEcon.jl/blob/master/src/Reference/StateSpaceEcon.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="StateSpaceEcon-Reference"><a class="docs-heading-anchor" href="#StateSpaceEcon-Reference">StateSpaceEcon Reference</a><a id="StateSpaceEcon-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#StateSpaceEcon-Reference" title="Permalink"></a></h1><ul></ul><h2 id="Steady-state-solver"><a class="docs-heading-anchor" href="#Steady-state-solver">Steady state solver</a><a id="Steady-state-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Steady-state-solver" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver" href="#StateSpaceEcon.SteadyStateSolver"><code>StateSpaceEcon.SteadyStateSolver</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">SteadyStateSolver</code></pre><p>A module that is part of StateSpaceEcon package. Contains methods for finding a steady state of a model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.check_sstate-Tuple{Model}" href="#StateSpaceEcon.SteadyStateSolver.check_sstate-Tuple{Model}"><code>StateSpaceEcon.SteadyStateSolver.check_sstate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_sstate(model; &lt;options&gt;)</code></pre><p>Run a diagnostic test to determine if the steady state solution stored within the given model object is indeed a solution of the steady state system of equations.</p><p>Return the number of steady state equations that are violated by the current steady state solution. If <code>verbose=true</code>, also display diagnostic information in the form of listing all bad equations and their residuals.</p><p><strong>Options</strong></p><p>Standard options (default values from <code>model.options</code>)</p><ul><li><code>verbose</code> </li><li><code>tol</code> - an equation is considered satisfied if its residual, in absolute value, is smaller than this number.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.clear_sstate!-Tuple{Model}" href="#StateSpaceEcon.SteadyStateSolver.clear_sstate!-Tuple{Model}"><code>StateSpaceEcon.SteadyStateSolver.clear_sstate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clear_sstate!(model; lvl=0.1, slp=0.0, &lt;options&gt;)</code></pre><p>Set the steady state values to the provided defaults and presolve.</p><p><strong>Arguments</strong></p><ul><li><code>model</code> - the model instance</li><li><code>lvl</code>, <code>slp</code> - the initial guess for the level and the slope. Each could be a number or a vector of length equal to the number of variable in the mode.</li></ul><p><strong>Options</strong></p><p>Standard options (default values are taken from <code>model.options</code>)</p><ul><li><code>verbose</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.diagnose_sstate-Tuple{Model}" href="#StateSpaceEcon.SteadyStateSolver.diagnose_sstate-Tuple{Model}"><code>StateSpaceEcon.SteadyStateSolver.diagnose_sstate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diagnose_sstate([point,] model)</code></pre><p>Run diagnostics on the steady state of the given model. If <code>point</code> is not given, then we check the steady state solution stored inside the given model.</p><p>Return a tuple of &quot;bad&quot; equations and &quot;bad&quot; variables. </p><p>The set of &quot;bad&quot; equations is one that is inconsistent, i.e. there is no solution. This might happen if the system is overdetermined.</p><p>The set of &quot;bad&quot; variables contains variables that cannot be solved uniquely. This might happen if the system is underdetermined. In this case, try adding steady state constraints until you get a unique solution. See <a href="../ModelBaseEcon/#ModelBaseEcon.@steadystate-Tuple{Any, Symbol, Expr}"><code>@steadystate</code></a> in ModelBaseEcon.</p><div class="admonition is-warning"><header class="admonition-header">Internal function</header><div class="admonition-body"><p>The output from this function may be difficult to read.&lt;br&gt; Call <a href="#StateSpaceEcon.SteadyStateSolver.check_sstate-Tuple{Model}"><code>check_sstate</code></a> instead.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.initial_sstate!-Tuple{Model, AbstractVector{Float64}}" href="#StateSpaceEcon.SteadyStateSolver.initial_sstate!-Tuple{Model, AbstractVector{Float64}}"><code>StateSpaceEcon.SteadyStateSolver.initial_sstate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_sstate!(model, init; &lt;options&gt;)</code></pre><p>Set the steady state values from the given vector and presolve.</p><p>Call this function to specify initial guesses for the iterative steady state solver. If the value of a steady state variable is known, it is better to use <a href="../ModelBaseEcon/#ModelBaseEcon.@steadystate-Tuple{Any, Symbol, Expr}"><code>@steadystate</code></a> to add that as a steady state constraint.</p><p><strong>Arguments</strong></p><ul><li><code>model</code> - the model.</li><li><code>init</code> - a vector of length equal to twice the number of variables in the model. The level and slope values are staggered, i.e., the level and slope of variable j are in init[2j-1] and init[2j].</li></ul><p><strong>Options</strong></p><p>Standard options (default values are taken from <code>model.options</code>)</p><ul><li><code>verbose</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.sssolve!-Tuple{Model}" href="#StateSpaceEcon.SteadyStateSolver.sssolve!-Tuple{Model}"><code>StateSpaceEcon.SteadyStateSolver.sssolve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sssolve!(model; &lt;options&gt;)</code></pre><p>Solve the steady state problem for the given model.</p><p><strong>Options</strong></p><p>Standard options (default values are taken from <code>model.options</code>)</p><ul><li><code>verbose</code></li><li><code>tol</code>, <code>maxiter</code> - control the stopping criteria of the solver</li></ul><p>Specific options</p><ul><li><code>presolve::Bool</code> - whether or not to use a presolve pass. Default is <code>true</code>.</li><li><code>method::Symbol</code> - choose the solution algorithm. Valid options are <code>:nr</code> for Newton-Raphson, <code>:lm</code> for Levenberg-Marquardt, and <code>:auto</code>. The <code>:auto</code> method starts with the LM algorithm and automatically switches to NR when it starts to converge. Default is <code>:nr</code>.</li></ul></div></section></article><h2 id="Plans"><a class="docs-heading-anchor" href="#Plans">Plans</a><a id="Plans-1"></a><a class="docs-heading-anchor-permalink" href="#Plans" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans" href="#StateSpaceEcon.Plans"><code>StateSpaceEcon.Plans</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">Plans</code></pre><p>Module part of StateSpaceEcon. This module implements the <code>Plan</code> data structure, which is used in simulations. The plan object contains information about the range of the simulation and which variables and shocks are exogenous or endogenous at each period of the range.</p><p><strong>Constructors</strong></p><ul><li><a href="#StateSpaceEcon.Plans.Plan"><code>Plan(model, range)</code></a></li></ul><p><strong>Modify the plan</strong></p><ul><li><a href="#StateSpaceEcon.Plans.exogenize!-Tuple{Plan, Any, Any}"><code>exogenize!</code></a>, <a href="#StateSpaceEcon.Plans.endogenize!-Tuple{Plan, Any, Any}"><code>endogenize!</code></a> - make variables exogenous or endogenous</li><li><a href="#StateSpaceEcon.Plans.exog_endo!-Tuple{Plan, Any, Any, Any}"><code>exog_endo!</code></a>, <a href="#StateSpaceEcon.Plans.endo_exog!-Tuple{Plan, Any, Any, Any}"><code>endo_exog!</code></a> - swap exogenous and endogenous variables</li><li><a href="#StateSpaceEcon.Plans.autoexogenize!-Tuple{Plan, Model, Any}"><code>autoexogenize!</code></a> - exogenize and endogenize variables according to the list in the model</li></ul><p><strong>Prepare data for simulation</strong></p><ul><li><a href="Reference/@ref"><code>zeroarray</code></a>, <a href="Reference/@ref"><code>zerodict</code></a>, <a href="Reference/@ref"><code>zerodata</code></a> - prepare a matrix or a dictionary or a <a href="Reference/@ref"><code>SimData</code></a> of data for the simulation containing zeros.</li><li><a href="Reference/@ref"><code>steadystatearray</code></a>, <a href="Reference/@ref"><code>steadystatedict</code></a>, <a href="Reference/@ref"><code>steadystatedata</code></a> - prepare a matrix or a dictionary or a <a href="Reference/@ref"><code>SimData</code></a> of data for the simulation containing the steady state.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.Plan" href="#StateSpaceEcon.Plans.Plan"><code>StateSpaceEcon.Plans.Plan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Plan{T &lt;: MIT}</code></pre><p>A data structure representing the simulation plan. It holds information about the time range of the simulation and which variables/shocks are exogenous at each period.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.Plan-Tuple{Model, AbstractUnitRange}" href="#StateSpaceEcon.Plans.Plan-Tuple{Model, AbstractUnitRange}"><code>StateSpaceEcon.Plans.Plan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Plan(model, range)</code></pre><p>Create a default simulation plan for the given model over the given range. The range of the plan is augmented to include periods before and after the given range, over which initial and final conditions will be applied. </p><p>Instead of a range, one could also pass in a single moment in time (<a href="../TimeSeriesEcon/#TimeSeriesEcon.MIT"><code>MIT</code></a>) instance, in which case it is interpreted as a range of length 1.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.autoexogenize!-Tuple{Plan, Model, Any}" href="#StateSpaceEcon.Plans.autoexogenize!-Tuple{Plan, Model, Any}"><code>StateSpaceEcon.Plans.autoexogenize!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>autoexogenize!(plan, model, date)</p><p>Modify the given plan according to the &quot;autoexogenize&quot; protocol defined in the given model. All variables in the autoexogenization list become endogenous and their corresponding shocks become exogenous over the given date or range. <code>date</code> can be a moment in time (same frequency as the given plan), a range, an iterable, or a container.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.endo_exog!-Tuple{Plan, Any, Any, Any}" href="#StateSpaceEcon.Plans.endo_exog!-Tuple{Plan, Any, Any, Any}"><code>StateSpaceEcon.Plans.endo_exog!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">endo_exog!(plan, endo_vars, exog_vars, date)</code></pre><p>Modify the given plan so that the given variables listed in <code>exog_vars</code> will be exogenous and the variables listed in <code>endo_vars</code> will be endogenous on the given dates. <code>exog_vars</code> and <code>endo_vars</code> can each be a <code>Symbol</code> or a <code>String</code> or a <code>Vector</code> of such. <code>date</code> can be a moment in time (same type as the plan), or a range or an iterable or a container.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.endogenize!-Tuple{Plan, Any, Any}" href="#StateSpaceEcon.Plans.endogenize!-Tuple{Plan, Any, Any}"><code>StateSpaceEcon.Plans.endogenize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">endogenize!(plan, vars, date)</code></pre><p>Modify the given plan so that the given variables will be endogenous on the given dates. <code>vars</code> can be a <code>Symbol</code> or a <code>String</code> or a <code>Vector</code> of such. <code>date</code> can be a moment in time (same type as the plan), or a range or an iterable or a container.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.exog_endo!-Tuple{Plan, Any, Any, Any}" href="#StateSpaceEcon.Plans.exog_endo!-Tuple{Plan, Any, Any, Any}"><code>StateSpaceEcon.Plans.exog_endo!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exog_endo!(plan, exog_vars, endo_vars, date)</code></pre><p>Modify the given plan so that the given variables listed in <code>exog_vars</code> will be exogenous and the variables listed in <code>endo_vars</code> will be endogenous on the given dates. <code>exog_vars</code> and <code>endo_vars</code> can each be a <code>Symbol</code> or a <code>String</code> or a <code>Vector</code> of such. <code>date</code> can be a moment in time (same type as the plan), or a range or an iterable or a container.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.exogenize!-Tuple{Plan, Any, Any}" href="#StateSpaceEcon.Plans.exogenize!-Tuple{Plan, Any, Any}"><code>StateSpaceEcon.Plans.exogenize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exogenize!(plan, vars, date)</code></pre><p>Modify the given plan so that the given variables will be exogenous on the given dates. <code>vars</code> can be a <code>Symbol</code> or a <code>String</code> or a <code>Vector</code> of such. <code>date</code> can be a moment in time (same type as the plan), or a range or an iterable or a container.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.plansum-Tuple{Model, Plan}" href="#StateSpaceEcon.Plans.plansum-Tuple{Model, Plan}"><code>StateSpaceEcon.Plans.plansum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plansum(model, plan)</code></pre><p>Return the total number of exogenous variables in the simulation plan. Periods over which initial and final conditions are imposed are not counted in this sum.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.setexog!-Tuple{Plan, Int64, Any}" href="#StateSpaceEcon.Plans.setexog!-Tuple{Plan, Int64, Any}"><code>StateSpaceEcon.Plans.setexog!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setexog!(plan, t, vinds)</code></pre><p>Modify the plan at time t such that <code>vinds</code> are exogenous and the rest are endogenous.</p></div></section></article><h2 id="Stacked-time-solver"><a class="docs-heading-anchor" href="#Stacked-time-solver">Stacked time solver</a><a id="Stacked-time-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Stacked-time-solver" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver" href="#StateSpaceEcon.StackedTimeSolver"><code>StateSpaceEcon.StackedTimeSolver</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">StackedTimeSolver</code></pre><p>A module that is part of StateSpaceEcon package. Contains methods for solving the dynamic system of equations for the model and running simulations.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.array2data" href="#StateSpaceEcon.StackedTimeSolver.array2data"><code>StateSpaceEcon.StackedTimeSolver.array2data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">array2data(matrix, vars, range)
array2data(matrix, model, plan)
array2workspace(matrix, vars, range)
array2workspace(matrix, model, plan)
data2array(simdata)
data2workspace(simdata)
workspace2array(w, vars, range)
workspace2array(w, model, plan)
workspace2data(w, vars, range)
workspace2data(w, model, plan)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.array2workspace" href="#StateSpaceEcon.StackedTimeSolver.array2workspace"><code>StateSpaceEcon.StackedTimeSolver.array2workspace</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">array2data(matrix, vars, range)
array2data(matrix, model, plan)
array2workspace(matrix, vars, range)
array2workspace(matrix, model, plan)
data2array(simdata)
data2workspace(simdata)
workspace2array(w, vars, range)
workspace2array(w, model, plan)
workspace2data(w, vars, range)
workspace2data(w, model, plan)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.data2array" href="#StateSpaceEcon.StackedTimeSolver.data2array"><code>StateSpaceEcon.StackedTimeSolver.data2array</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">array2data(matrix, vars, range)
array2data(matrix, model, plan)
array2workspace(matrix, vars, range)
array2workspace(matrix, model, plan)
data2array(simdata)
data2workspace(simdata)
workspace2array(w, vars, range)
workspace2array(w, model, plan)
workspace2data(w, vars, range)
workspace2data(w, model, plan)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.data2workspace" href="#StateSpaceEcon.StackedTimeSolver.data2workspace"><code>StateSpaceEcon.StackedTimeSolver.data2workspace</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">array2data(matrix, vars, range)
array2data(matrix, model, plan)
array2workspace(matrix, vars, range)
array2workspace(matrix, model, plan)
data2array(simdata)
data2workspace(simdata)
workspace2array(w, vars, range)
workspace2array(w, model, plan)
workspace2data(w, vars, range)
workspace2data(w, model, plan)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.dictoverlay" href="#StateSpaceEcon.StackedTimeSolver.dictoverlay"><code>StateSpaceEcon.StackedTimeSolver.dictoverlay</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dictoverlay(d1, d2)</code></pre><p>Merge two dictionaries. Common key where the values are <a href="../TimeSeriesEcon/#TimeSeriesEcon.TSeries"><code>TSeries</code></a> of the same frequency are overlayed. Otherwise, a common key takes the value of the last Dict containing it.</p><div class="admonition is-info"><header class="admonition-header">Deprecation Note</header><div class="admonition-body"><p>This function will be removed. Use <code>TimeSeriesEcon.overlay</code> instead. An important difference is that <code>TimeSeriesEcon.overlay</code> keeps the values from the first argument where the key appears, while <code>dictoverlay</code> keeps it from the last.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.seriesoverlay" href="#StateSpaceEcon.StackedTimeSolver.seriesoverlay"><code>StateSpaceEcon.StackedTimeSolver.seriesoverlay</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">seriesoverlay(ts1, ts2)</code></pre><p>Return a new <a href="../TimeSeriesEcon/#TimeSeriesEcon.TSeries"><code>TSeries</code></a> over the full range of both arguments. The overlapping part contains values from the last argument.</p><div class="admonition is-info"><header class="admonition-header">Deprecation Note</header><div class="admonition-body"><p>This function will be removed in the future. Use <code>TimeSeriesEcon.overlay</code> instead.  Note the important difference that in <code>TimeSeriesEcon.overlay</code> the values in the overlay come from the <em>first</em> series where the value exists, as opposed to <code>seriesoverlay</code> where it was from the last one.</p></div></div><p>See also: <a href="#StateSpaceEcon.StackedTimeSolver.dictoverlay"><code>dictoverlay</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.shockdecomp-Tuple{Model, Plan, MVTSeries{F, Float64, C} where {F&lt;:Frequency, C&lt;:AbstractMatrix{Float64}}}" href="#StateSpaceEcon.StackedTimeSolver.shockdecomp-Tuple{Model, Plan, MVTSeries{F, Float64, C} where {F&lt;:Frequency, C&lt;:AbstractMatrix{Float64}}}"><code>StateSpaceEcon.StackedTimeSolver.shockdecomp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shockdecomp(model, plan, exog_data; control, fctype, [options])</code></pre><p>Compute the shock decomposition for the given model, plan, exogenous (shocks) data and control solution.</p><p>If <code>control</code> option is not specified we use the steady state solution stored in the model instance. The algorithm assumes that <code>control</code> is a solution to the dynamic model for the given plan range and final condition. We verify the residual and issue a warning, but do not enforce this. See <a href="Reference/@ref"><code>steadystatedata</code></a>.</p><p>As part of the algorithm we run a simulation with the given <code>plan</code>,  <code>exog_data</code> and <code>fctype</code>.  See <a href="#StateSpaceEcon.StackedTimeSolver.simulate"><code>simulate</code></a> for other options.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For now only the case of <code>anticipate=true</code> works. Shock decomp with unanticipated shocks is coming soon.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.simulate" href="#StateSpaceEcon.StackedTimeSolver.simulate"><code>StateSpaceEcon.StackedTimeSolver.simulate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simulate(model, plan, data; &lt;options&gt;)</code></pre><p>Run a simulation for the given model, simulation plan and exogenous data.</p><p><strong>Arguments</strong></p><ul><li><code>model</code> - the <a href="../ModelBaseEcon/#ModelBaseEcon.Model"><code>Model</code></a> instance to simulate.</li><li><code>plan</code> - the <a href="#StateSpaceEcon.Plans.Plan"><code>Plan</code></a> for the simulation.</li><li><code>data</code> - a 2D <code>Array</code> containing the exogenous data. This includes the initial and final conditions.</li></ul><p><strong>Options as keyword arguments</strong></p><ul><li><code>fctype::</code><a href="Reference/@ref"><code>FCType</code></a> - set the desired final condition type for the simulation. The default value is <code>fcgiven</code>. Other possible values include <code>fclevel</code> and <code>fcslope</code>.</li><li><code>initial_guess::AbstractMatrix{Float64}</code> - a 2D <code>Array</code> containing the initial guess for the solution. This is used to start the Newton-Raphson algorithm. The default value is an empty array (<code>zeros(0,0)</code>), in which case we use the exogenous data for the initial condition. You can use the steady state solution using <a href="#StateSpaceEcon.steadystatearray"><code>steadystatearray</code></a>.</li><li><code>deviation::Bool</code> - set to <code>true</code> if the <code>data</code> is given in deviations from the steady state. In this case the simulation result is also returned as a deviation from the steady state. Default value is <code>false</code>.</li><li><code>anticipate::Bool</code> - set to <code>false</code> to instruct the solver that all shocks are unanticilated by the agents. Default value is <code>true</code>.</li><li><code>verbose::Bool</code> - control whether or not to print progress information. Default value is taken from <code>model.options</code>.</li><li><code>tol::Float64</code> - set the desired accuracy. Default value is taken from <code>model.options</code>.</li><li><code>maxiter::Int</code> - algorithm fails if the desired accuracy is not reached within this maximum number of iterations. Default value is taken from <code>model.options</code>.</li></ul><p><strong>See also:</strong></p><p><strong>Examples</strong></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.workspace2array" href="#StateSpaceEcon.StackedTimeSolver.workspace2array"><code>StateSpaceEcon.StackedTimeSolver.workspace2array</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">array2data(matrix, vars, range)
array2data(matrix, model, plan)
array2workspace(matrix, vars, range)
array2workspace(matrix, model, plan)
data2array(simdata)
data2workspace(simdata)
workspace2array(w, vars, range)
workspace2array(w, model, plan)
workspace2data(w, vars, range)
workspace2data(w, model, plan)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.workspace2data" href="#StateSpaceEcon.StackedTimeSolver.workspace2data"><code>StateSpaceEcon.StackedTimeSolver.workspace2data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">array2data(matrix, vars, range)
array2data(matrix, model, plan)
array2workspace(matrix, vars, range)
array2workspace(matrix, model, plan)
data2array(simdata)
data2workspace(simdata)
workspace2array(w, vars, range)
workspace2array(w, model, plan)
workspace2data(w, vars, range)
workspace2data(w, model, plan)</code></pre></div></section></article><h2 id="Various"><a class="docs-heading-anchor" href="#Various">Various</a><a id="Various-1"></a><a class="docs-heading-anchor-permalink" href="#Various" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StateSpaceEcon" href="#StateSpaceEcon.StateSpaceEcon"><code>StateSpaceEcon.StateSpaceEcon</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">StateSpaceEcon</code></pre><p>A package for Macroeconomic modelling.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SimData" href="#StateSpaceEcon.SimData"><code>StateSpaceEcon.SimData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimData</code></pre><p>Data structure containing the time series data for a simulation.</p><p>It is a collection of <a href="../TimeSeriesEcon/#TimeSeriesEcon.TSeries"><code>TSeries</code></a> of the same frequency and containing data for the same range. When used for simulation, the range must include the initial conditions, the simulation range and the final conditions, although it could extend beyond that. It must contain time series for all variables and shocks in the model, although it might contain other time series.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.printmatrix-Tuple{AbstractMatrix{T} where T, Vararg{Any, N} where N}" href="#StateSpaceEcon.printmatrix-Tuple{AbstractMatrix{T} where T, Vararg{Any, N} where N}"><code>StateSpaceEcon.printmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">printmatrix(mat [, Val(F), colnames])</code></pre><p>Display a matrix in full while controlling the formatting of each value and optionally showing the column names.</p><ul><li><code>Val(F)</code> - display each number in the given format <code>F</code>. The format is in the form of a decimal point number where the whole part indicates the total width and the fractional part is the number of digits printed after the decimal point. Default is <code>Val(12.7)</code></li><li><code>colnames</code> - a list of names to display in the first row. The names are displayed as given, possibly with padding to match the width given in the <code>Val</code> argument. If any names are longer than that, they will not be truncated and so the display will not be aligned properly. Sorry about that!</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.steadystatearray" href="#StateSpaceEcon.steadystatearray"><code>StateSpaceEcon.steadystatearray</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">zeroarray(model, plan)
steadystatearray(model, plan; [ref=firstdate(plan) + m.maxlag)</code></pre><p>Create a <code>Matrix{Float64}</code> of the proper dimension for a simulation with the given model with the given plan. It is initialized to 0 or the steady state.</p><p>This function returns a <code>Matrix</code>. We recommend using <a href="#StateSpaceEcon.zerodata"><code>zerodata</code></a>. See also <a href="#StateSpaceEcon.zeroworkspace-Tuple{Model, Plan}"><code>zeroworkspace</code></a></p><ul><li>In the case of steady state solution that is not stationary in time (i.e., constant rate of change or constant rate of growth) use the <code>ref</code> option to specify the period in which the steady state level is given. The default is the first simulation period.</li></ul><div class="admonition is-info"><header class="admonition-header">Deprecation Note</header><div class="admonition-body"><p><code>zeroarray(model, range)</code> will be removed in future versions. Always create a simulation <code>Plan</code> explicitly.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.zeroarray" href="#StateSpaceEcon.zeroarray"><code>StateSpaceEcon.zeroarray</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">zeroarray(model, plan)
steadystatearray(model, plan; [ref=firstdate(plan) + m.maxlag)</code></pre><p>Create a <code>Matrix{Float64}</code> of the proper dimension for a simulation with the given model with the given plan. It is initialized to 0 or the steady state.</p><p>This function returns a <code>Matrix</code>. We recommend using <a href="#StateSpaceEcon.zerodata"><code>zerodata</code></a>. See also <a href="#StateSpaceEcon.zeroworkspace-Tuple{Model, Plan}"><code>zeroworkspace</code></a></p><ul><li>In the case of steady state solution that is not stationary in time (i.e., constant rate of change or constant rate of growth) use the <code>ref</code> option to specify the period in which the steady state level is given. The default is the first simulation period.</li></ul><div class="admonition is-info"><header class="admonition-header">Deprecation Note</header><div class="admonition-body"><p><code>zeroarray(model, range)</code> will be removed in future versions. Always create a simulation <code>Plan</code> explicitly.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.zerodata" href="#StateSpaceEcon.zerodata"><code>StateSpaceEcon.zerodata</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">zerodata(model, plan)</code></pre><p>Create a [<code>SimData</code>] for a simulation with the given <code>model</code> and <code>plan</code>. Columns correspond to the model variables and shocks in the correct order. Data is initialized with 0 or the steady state. </p><ul><li>In the case of steady state solution that is not stationary in time (i.e., constant rate of change or constant rate of growth) use the <code>ref</code> option to specify the period in which the steady state level is given. The default is the first simulation period.</li></ul><p>See also <a href="#StateSpaceEcon.zeroarray"><code>zeroarray</code></a> and <a href="#StateSpaceEcon.zeroworkspace-Tuple{Model, Plan}"><code>zeroworkspace</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.zerodict" href="#StateSpaceEcon.zerodict"><code>StateSpaceEcon.zerodict</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">zerodict(model, plan)
steadystatedict(model, plan; [ref=firstdate(plan) + m.maxlag))</code></pre><div class="admonition is-info"><header class="admonition-header">Deprecation Note</header><div class="admonition-body"><p>This function will be removed in a future version. Use <a href="#StateSpaceEcon.zeroworkspace-Tuple{Model, Plan}"><code>zeroworkspace</code></a><code>(model, plan)</code>.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.zeroworkspace-Tuple{Model, Plan}" href="#StateSpaceEcon.zeroworkspace-Tuple{Model, Plan}"><code>StateSpaceEcon.zeroworkspace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zeroworkspace(model, plan)
steadystateworkspace(model, plan; [ref=firstdate(plan) + m.maxlag))</code></pre><p>Create a <a href="../TimeSeriesEcon/#TimeSeriesEcon.Workspace"><code>TimeSeriesEcon.Workspace</code></a> containing a <code>TSeries</code> for each variable/shock in the given <code>model</code>. They are initialized to 0 or the steady state solution.</p><ul><li>In the case of steady state solution that is not stationary in time (i.e., constant rate of change or constant rate of growth) use the <code>ref</code> option to specify the period in which the steady state level is given. The default is the first simulation period.</li></ul><p>We recommend using <a href="#StateSpaceEcon.zerodata"><code>zerodata</code></a>. See also <a href="#StateSpaceEcon.zeroarray"><code>zeroarray</code></a>.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ModelBaseEcon/">« ModelBaseEcon</a><a class="docs-footer-nextpage" href="../../DesignPapers/">Design Papers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Friday 18 March 2022 17:25">Friday 18 March 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
