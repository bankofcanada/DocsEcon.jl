var documenterSearchIndex = {"docs":
[{"location":"indexpage/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"indexpage/","page":"Index","title":"Index","text":"","category":"page"},{"location":"Tutorials/README/#README","page":"README","title":"README","text":"","category":"section"},{"location":"Tutorials/README/","page":"README","title":"README","text":"This project contains a list of tutorials demonstrating the use of StateSpaceEcon group of Julia packages. Each tutorial is in its own subdirectory. They are meant to run in a Julia REPL session running in the root directory of the project (which is what happens in VSCode), not in the subdirectory of the specific tutorial.  ","category":"page"},{"location":"Tutorials/README/#Installation","page":"README","title":"Installation","text":"","category":"section"},{"location":"Tutorials/README/","page":"README","title":"README","text":"The tutorials are designed to run in the Julia environment in the root of the project. Before the first use, make sure to instantiate the environment.","category":"page"},{"location":"Tutorials/README/","page":"README","title":"README","text":"] activate .\n] instantiate","category":"page"},{"location":"Tutorials/README/","page":"README","title":"README","text":"After that, make sure the environment is active when you run the tutorial codes.","category":"page"},{"location":"Tutorials/README/#List-of-tutorials","page":"README","title":"List of tutorials","text":"","category":"section"},{"location":"Tutorials/README/","page":"README","title":"README","text":"Each tutorial is in its own subdirectory containing a main.jl and main.md in addition to other files. The two main files contain the same code and explanations. If running the tutorial code yourself, you should use the .jl file.","category":"page"},{"location":"Tutorials/README/","page":"README","title":"README","text":"Smets and Wouters 2007\nFRB-US with VAR-based Expectations\nTimeSeriesEcon","category":"page"},{"location":"Tutorials/US_SW07/main/#Smets-and-Wouters-2007","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"You can follow the tutorial by reading this page and copying and pasting code into your Julia REPL session. In this case, you will need the model file, SW07.jl.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"All the code contained here is also available in this file: main.jl.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Pages = [\"main.md\"]\nDepth = 3","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"using StateSpaceEcon\nusing ModelBaseEcon\nusing TimeSeriesEcon\n\nusing Test\nusing Plots\nusing Random\nusing Distributions\n\n# Fix the random seed for reproducibility.\nRandom.seed!(1234);\n\n# We need the model file SW07.jl to be on the search path for modules.\nunique!(push!(LOAD_PATH, realpath(\".\"))) # hide\n","category":"page"},{"location":"Tutorials/US_SW07/main/#Part-1:-The-model","page":"Smets and Wouters 2007","title":"Part 1: The model","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/#Loading-the-model","page":"Smets and Wouters 2007","title":"Loading the model","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The model is described in its own dedicated module, which is contained in its own file, SW07.jl. We can load the module with using SW07; the model itself is a global variable called model within that module.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"using SW07\nm = SW07.model","category":"page"},{"location":"Tutorials/US_SW07/main/#Examining-the-model","page":"Smets and Wouters 2007","title":"Examining the model","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"This model is too big to fit all of its details in the REPL window, so only summary information is displayed. We can see the entire model with fullprint.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"fullprint(m)","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We can also examine individual components using the commands parameters, variables, shocks, equations.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"parameters(m)","category":"page"},{"location":"Tutorials/US_SW07/main/#Setting-the-model-parameters","page":"Smets and Wouters 2007","title":"Setting the model parameters","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We must not change any part of the model in the active Julia session except for the model parameters and steady state constraints. If we want to add variables, shocks, or equations, we must do so in the model module file and restart Julia to load the new model.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"When it comes to the model parameters, we can access them by their names from the model object using dot notation.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"m.crr # read a parameter value\nm.cgy = 0.5187 # modify a parameter value","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"note: Note\nIn this model the values of the parameters have been set according to the replication data.","category":"page"},{"location":"Tutorials/US_SW07/main/#Model-flags-and-options","page":"Smets and Wouters 2007","title":"Model flags and options","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"In addition to model parameters, which are values that appear in the model equations, the model object also holds two other sets of parameters, namely flags and options.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Flags are (usually boolean) values which characterize the type of model we have. For example, a linear model should have its linear flag set to true. Typically, this is done in the model file before calling @initialize.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"m.flags","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Options are values that adjust the operations of the algorithms. For example, we have tol and maxiter, which set the desired accuracy and maximum number of iterations for the iterative solvers. These can be adjusted as needed at any time. Another useful option is verbose, which controls the level of verbosity of the different commands.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Many functions in StateSpaceEcon have optional arguments of the same name as a model option. When the argument is not explicitly given in the function call, these functions will use the value from the model option of the same name.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"m.verbose = true\nm.options","category":"page"},{"location":"Tutorials/US_SW07/main/#Part-2:-The-steady-state-solution","page":"Smets and Wouters 2007","title":"Part 2: The steady state solution","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The steady state is a special solution of the dynamic system that remains constant over time. It is important on its own, but also it can be useful in several ways. For example, linearizing the model requires a particular solution about which to linearize, and the steady state is typically used for this purpose.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"In addition to the steady state, we also consider another kind of special solution which grows linearly in time. If we know that the steady state solution is constant (i.e., its slope is zero), we can set the model flag ssZeroSlope to true. This is not required; however in a large model it might help the steady state solver converge faster to the solution.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The model object m stores information about the steady state. This includes the steady state solution itself, as well as a (possibly empty) set of additional constraints that apply only to the steady state. This information can be accessed via m.sstate.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"m.sstate","category":"page"},{"location":"Tutorials/US_SW07/main/#steady_state_constraints","page":"Smets and Wouters 2007","title":"Steady state constraints","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Sometimes the steady state is not unique, and we can use steady state constraints to specify the particular steady state we want. Also, if the model is non-linear, these constraints can be used to help the steady state solver converge. Steady state constraints can be added with the @steadystate macro. The constraint can be as simple as giving a specific value; we can also write an equation with multiple variables. We're allowed to use model parameters in these equations as well.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"@steadystate m a = 5\nm.sstate","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We can clean up the constraints by emptying the constraints container.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"empty!(m.sstate.constraints)\nm.sstate","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"note: Important note\nSteady state constraints that are always valid can be pre-defined in the model file. In that case, all calls to the @steadystate macro must be made after calling @initialize.","category":"page"},{"location":"Tutorials/US_SW07/main/#Solving-for-the-steady-state","page":"Smets and Wouters 2007","title":"Solving for the steady state","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The steady state solution is stored within the model object. Before solving, we have to specify an initial condition. If the model is linear, this makes no difference, but in a non-linear model a good or a bad initial guess might be the difference between success and failure of the steady state solver.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We specify the initial guess by calling clear_sstate!. This call removes any previously stored solution, sets the initial guess, and runs the pre-solve pass of the steady state solver. The initial guess can be given with the lvl and slp arguments; if not provided, an initial guess is chosen automatically.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Once that's done, we call sssolve! to find the steady state. This function returns a Vector{Float64} containing the steady state solution, and it also writes that solution into the model object. The vector is of length 2*nvariables(m) and contains the level and the slope for each variable.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"clear_sstate!(m)\nsssolve!(m);","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"If in doubt, we can use check_sstate to make sure the steady state solution stored in the model object indeed satisfies the steady state system of equations. This function returns the number of equations that are not satisfied. A value of 0 is what we want to see. In verbose mode, it also lists the problematic equations and their residuals.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"check_sstate(m)","category":"page"},{"location":"Tutorials/US_SW07/main/#Examining-the-steady-state","page":"Smets and Wouters 2007","title":"Examining the steady state","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We can access the steady state solution via m.sstate using the dot notation.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"m.sstate.dc","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We can also assign new values to the steady state solution, but we should be careful to make sure it remains a valid steady state solution.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"m.sstate.dc.level = 0.43121\n@test check_sstate(m) > 0","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"As the code above shows, a wrong steady state solution (based on the specified precision in the tol option) will result in one or more equation not being satisfied. Let's put back the correct value.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"m.sstate.dc.level = 0.4312\n@test check_sstate(m) == 0","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We can examine the entire steady state solution with printsstate.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"printsstate(m)","category":"page"},{"location":"Tutorials/US_SW07/main/#Part-3:-Impulse-response","page":"Smets and Wouters 2007","title":"Part 3: Impulse response","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/#Simulation-plan","page":"Smets and Wouters 2007","title":"Simulation plan","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Before we can simulate the model, we have to decide on the length of the simulation and what data is available for each period, i.e., what values are known (exogenous). This is done with an object of type Plan.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"To create a plan, all we need is the model object and a range for the simulation.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"sim_rng = 2000Q1:2039Q4\np = Plan(m, sim_rng)","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The plan shows us the list of exogenous values (variable or shocks) for each period or sub-range of the simulation. By default, all shocks are exogenous and all variables are endogenous.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We also see that the range of the plan has been extended before and after the simulation range. This is necessary because we need to set initial and final conditions. The number of periods for initial conditions is equal to the largest lag in the model. Similarly, final conditions have to be imposed over as many periods as the largest lead.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"p.range          # the full range of the plan\ninit_rng = first(p.range):first(sim_rng)-1   # the range for initial conditions\nfinal_rng = last(sim_rng)+1:last(p.range)     # the range for final conditions\n@test length(init_rng) == m.maxlag\n@test length(final_rng) == m.maxlead","category":"page"},{"location":"Tutorials/US_SW07/main/#Exogenous-data","page":"Smets and Wouters 2007","title":"Exogenous data","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We have to provide the data for the simulation. We start with all zeros and fill in the external data, which must include initial conditions for all variable and shocks, exogenous values (according to the plan), and possibly final conditions.","category":"page"},{"location":"Tutorials/US_SW07/main/#Initial-conditions","page":"Smets and Wouters 2007","title":"Initial conditions","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"In this example, we want to simulate an impulse response, so it makes sense to start from the steady state, so that is what we set as the initial condition. We leave the initial conditions for the shocks at 0.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"exog = zerodata(m, p);\nfor var in variables(m)\n    exog[init_rng, var] .= m.sstate[var].level\nend\nexog","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"tip: Pro tip\nThe above works because the steady state is stationary, i.e., all slopes are zero. If we had a model with linear growth steady state, we could do something like the following (see @rec):for var in variables(m)\n    ss = m.sstate[var]\n    exog[init_rng, var] = ss.level\n    if ss.slope != 0\n        # recursively update by adding the slope each period\n        @rec init_rng[2:end] exog[t, var] = exog[t - 1, var] + ss.slope\n    end\nend","category":"page"},{"location":"Tutorials/US_SW07/main/#Final-conditions","page":"Smets and Wouters 2007","title":"Final conditions","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"For the final conditions we can use the steady state again, because we expect that the economy will eventually return to it if the simulation is sufficiently long past the last shock. We can do this by assigning the values of the steady state to the final periods after the simulation, similarly to what we did with the initial conditions.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Alternatively, we can specify that we want to use the steady state in the call to simulate by passing fctype=fclevel. Yet another possibility is to set the final condition so that the solution slope matches the slope of the steady state by setting fctype=fcslope. In both cases, we do not need to set anything in the exogenous data array because those values would be ignored.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"tip: Pro tip\nIn the Smets and Wouters 2007 model the two ways of using the steady state for final conditions (level or slope) are equivalent, because the steady state here is stationary and unique. In models where the steady state has non-zero slope, or the steady state has zero slope but the level is not unique, we should use fctype=fcslope.","category":"page"},{"location":"Tutorials/US_SW07/main/#A-quick-sanity-check","page":"Smets and Wouters 2007","title":"A quick sanity check","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"If we were to run a simulation where the economy started in the steady state and there were no shocks at all, we'd expect that the economy would remain in steady state forever.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"ss = simulate(m, p, exog; fctype=fcslope);","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The simulated data, ss, should equal (up to the accuracy of the solution) the steady state data. Similar to zerodata, we can use steadystatedata to create a data set containing the steady state solution.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"@test ss ≈ steadystatedata(m, p)","category":"page"},{"location":"Tutorials/US_SW07/main/#Exogenous-data-2","page":"Smets and Wouters 2007","title":"Exogenous data","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"All shocks are exogenous by default. All we have left to do is to set the value of the shock.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Let's say that we want to shock epinf for the first four quarters by 0.1.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"exog[sim_rng[1:4], :epinf] .= 0.1;\nexog[shocks(m)]","category":"page"},{"location":"Tutorials/US_SW07/main/#Running-the-simulation","page":"Smets and Wouters 2007","title":"Running the simulation","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We call simulate, providing the model, the exogenous data, and the plan. We also specify the type of final condition we want to impose.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"irf = simulate(m, p, exog; fctype=fcslope);","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We can now take a look at how some of the observable variables in the model have responded to this shock. We use plot from the Plots package to for that. We specify the variables we want to plot using vars and the names of the datasets being plotted (for the legend) in the names option.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"plot(ss, irf,\n     vars=(:pinfobs, :dy, :labobs, :robs),\n     names=(\"SS\", \"IRF\"),\n     legend=[true false false false],\n     size=(600, 400)\n    );","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"savefig(\"irf.png\")","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"(Image: Impulse Response Graph)","category":"page"},{"location":"Tutorials/US_SW07/main/#Part-4:-Stochastic-shocks-simulation","page":"Smets and Wouters 2007","title":"Part 4: Stochastic shocks simulation","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Now let's run a simulation with stochastic shocks. We will have random shocks over two years and then have no shocks for several years afterwards to allow time for the economy to return to its steady state.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"sim_rng = 2000Q1:2049Q4      # simulate 50 years starting 2000\nshk_rng = 2004Q1 .+ (0:7)    # shock 8 quarters starting in 2004\np = Plan(m, sim_rng)\ninit_rng = first(p.range):first(sim_rng) - 1\nfinal_rng = last(sim_rng) + 1:last(p.range)\nexog = zerodata(m, p);\nfor v in variables(m)\n    exog[init_rng, v] .= m.sstate[v].level\nend","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The distributions of the shocks are assumed normal with mean zero and standard deviations that have been estimated in the replication data. We use packages Distributions and Random to draw the necessary random values.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"shk_dist = (ea = Normal(0.0, 0.4618),\n            eb = Normal(0.0, 1.8513),\n            eg = Normal(0.0, 0.6090),\n            eqs = Normal(0.0, 0.6017),\n            em = Normal(0.0, 0.2397),\n            epinf = Normal(0.0, 0.1455),\n            ew = Normal(0.0, 0.2089));\nfor (shk, dist) in pairs(shk_dist)\n    exog[shk_rng, shk] .= rand(dist, length(shk_rng))\nend\nexog[shk_rng, shocks(m)]","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Now we are ready to simulate. We can set the shocks to be anticipated or unanticipated by setting the anticipate parameter in simulate.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"sim_a = simulate(m, p, exog; fctype=fcslope, anticipate=true);\nsim_u = simulate(m, p, exog; fctype=fcslope, anticipate=false);","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"As before, we can review the responses of the observed variables to these shocks using plot.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"observed = (:dy, :dc, :dinve, :labobs, :pinfobs, :dw, :robs);\nss = steadystatedata(m, p);\nplot(ss, sim_a, sim_u,\n     vars=observed,\n     names=(\"SS\", \"Anticipated\", \"Unanticipated\"),\n     legend=[true (false for i = 1:6)...],\n     linewidth=1.5,   # hide\n     size=(900, 600)  # hide\n    );","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"savefig(\"stoch_shk.png\")","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"(Image: Stochastic Shock Response Graph)","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We see that when the shocks are anticipated, the variables start to react to them right away; in the unanticipated case, there is no movement until the shocks actually hit.","category":"page"},{"location":"Tutorials/US_SW07/main/#Part-5:-Backing-out-historical-shocks","page":"Smets and Wouters 2007","title":"Part 5: Backing out historical shocks","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Now let's pretend that the simulated values are historical data and that we do not know the magnitude of the shocks. We can treat the observed (simulated) values of the variables as known by making them exogenous. At the same time we will make the shocks endogenous, so that we can solve for their values during the simulation.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The \"historic\" (simulated, assumed observed) range is from the first period of the simulation until the last shock in the previous exercise.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"hist_rng = first(sim_rng):last(shk_rng)","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We use exogenize! and endogenize! to set up a plan in which observed variables are exogenous and shocks are endogenous throughout the historic range.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"endogenize!(p, shocks(m), hist_rng);\nexogenize!(p, observed, hist_rng);\np","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"As we can see above, the plan now reflects our intentions.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Finally, we need to set up the exogenous data. This time we do not specify the shocks; instead, we assign the known data for the observed variables for the historic range. We start with initial conditions.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"exog = zerodata(m, p);\nfor v in variables(m)\n    exog[init_rng, v] .= m.sstate[v].level\nend","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We take the observed data from the simulation above. We show the anticipated version first.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"for v in observed\n    exog[hist_rng, v] .= sim_a[v]\nend\nback_a = simulate(m, p, exog; fctype=fcslope, anticipate=true);","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Now we show the unanticipated case.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"for v in observed\n    exog[hist_rng, v] .= sim_u[v]\nend\nback_u = simulate(m, p, exog; fctype=fcslope, anticipate=false);","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"If we did everything correctly, the shocks we recovered must match exactly the shocks we used when we simulated the \"historical\" data.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"@test sim_a[shocks(m)] ≈ back_a[shocks(m)]\n@test sim_u[shocks(m)] ≈ back_u[shocks(m)]","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Moreover, we must have the unobserved variables match as well. In fact, all the data must match over the entire simulation range.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"@test sim_a ≈ back_a\n@test sim_u ≈ back_u","category":"page"},{"location":"Tutorials/US_SW07/main/#Appendix","page":"Smets and Wouters 2007","title":"Appendix","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/#replication_data","page":"Smets and Wouters 2007","title":"Replication Data","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The replication data can be downloaded from http://doi.org/10.3886/E116269V1","category":"page"},{"location":"Tutorials/US_SW07/main/#References","page":"Smets and Wouters 2007","title":"References","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Smets, F., Wouters, R., 2007. Shocks and frictions in US business cycles: A bayesian DSGE approach. The American Economic Review 97(3), 586–606.","category":"page"},{"location":"DesignPapers/final_conditions/#Final-Conditions","page":"Final Conditions","title":"Final Conditions","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"This article describes the different types of final conditions supported in StateSpaceEcon, the relevant mathematical derivations, as well as some implementation details.","category":"page"},{"location":"DesignPapers/final_conditions/#Introduction","page":"Final Conditions","title":"Introduction","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"In the stacked time algorithm all equations for all time periods are solved simultaneously as one, very large system of equations. Because of lags in some of the variables, we must impose initial conditions, i.e. values for the variables before the first period of the simulation. This is not unique to stacked time algorithm - all solution methods require initial conditions.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Similarly, because of leads in some of the variables, we must provide final conditions. Final conditions are equations in terms of variables at times beyond the last period of the simulation.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"As a running example, consider a model with one variable y_t, one shock sy_t, and one equation involving one lag and one lead:","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    f(y_t-1 y_t y_t+1 s_t) = 0","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Suppose we want to simulate 3 periods. Let's use indices t=24 for the simulation periods. In the stacked time algorithm we have to solve the following system of equations:","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"beginaligned\n    f(y_1 y_2 y_3 s_2) = 0 \n    f(y_2 y_3 y_4 s_3) = 0 \n    f(y_3 y_4 y_5 s_4) = 0\nendaligned","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"We see that we have 3 equations with 5 unknowns - we assume that the values of the shocks (s_t) are given as exogenous data. In order to find a unique solution for y_t for all t=15, we need two more equations. The first one is the initial condition.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"y_1 = Y_1","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"where Y_1 is a known value of y at time t=1. The last equation is the final condition, which would help us solve for y_5.","category":"page"},{"location":"DesignPapers/final_conditions/#Types-of-Final-Conditions","page":"Final Conditions","title":"Types of Final Conditions","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"There are four types of final conditions currently implemented in StateSpaceEcon.","category":"page"},{"location":"DesignPapers/final_conditions/#fcgiven","page":"Final Conditions","title":"fcgiven","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"This is the simplest one of them. It can be used when the values of the variable after the end of the simulation are known and we simply assign them.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"In our running example, the following equation corresponds to fcgiven.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"y_5 = Y_5","category":"page"},{"location":"DesignPapers/final_conditions/#fclevel","page":"Final Conditions","title":"fclevel","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"This is almost the same as fcgiven in that here again we simply assign known values to the variables in the final conditions. This time the values come from the steady state solution of the system. This works if the steady state of y_t is a constant.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"y_5 = ssY_5","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Where ssY is the steady state of y. Note that the steady state is not necessarily a constant. In the case of balanced growth path and more than one final conditions period, we still assign the known values of ssY_t as computed from its known level and slope.","category":"page"},{"location":"DesignPapers/final_conditions/#fcslope","page":"Final Conditions","title":"fcslope","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"In this case we write an equation which sets the first difference of y_t at the end of the simulation (for all final conditions periods) to the slope of the steady state. This works if the steady state solution of y_t is a balanced path with linear growth. It can also be used with constant steady state - in that case the \"linear growth\" has slope 0.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"y_5 - y_4 = ssY_5 - ssY_4","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Note that ssY_t+1 - ssY_t = ssY_slope is simply the slope of the steady state - a constant that does not depend on t.","category":"page"},{"location":"DesignPapers/final_conditions/#fcnatural","page":"Final Conditions","title":"fcnatural","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"This is the case when we believe that the solution path beyond the end of the simulation is a straight line, but we don't know its slope, i.e., we allow the slope to be solved for. Practically, this final condition imposes the constraint that the second difference of the variable is zero after the last simulation period.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"   y_5 - 2 y_4 + y_3 = 0","category":"page"},{"location":"DesignPapers/final_conditions/#The-Stacked-Time-System-of-Equations","page":"Final Conditions","title":"The Stacked Time System of Equations","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Once we stack all equations for all simulation time periods into a single system of equations, we get a system with more unknowns than equations, as we saw above. In addition to initial and final conditions, we also have to impose exogenous constraints.","category":"page"},{"location":"DesignPapers/final_conditions/#Vector-of-Unknowns","page":"Final Conditions","title":"Vector of Unknowns","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Let us denote by x the vector of all unknowns. To be specific, the variables and shocks are assigned consecutive and unique indices from 1 to N. Also, the time periods of the simulation, together with the necessary number of time periods before (initial conditions) and after (final conditions) the simulation, are numbered sequentially starting from 1 to T. Thus vector x has N T components. We have adopted the convention that the first T components correspond to values of the first variable, components from T+1 to 2T are for variable 2 and so on.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"We divide the unknowns into three groups based on how they are treated by the solver. The first group contains the unknowns whose values are already known. These include initial conditions and exogenous constraints. We denote these x_e.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"The second group is the set of \"active unknowns\". These are the ones we are actually solving for in the simulation. We denote them x_s.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"The third group consists of the unknowns determined by final conditions. We denote that vector x_c.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"In our example, the vectors of unknowns would look like this:","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"beginaligned\n    x = y_1 y_2 y_3 y_4 y_5 s_1 s_2 s_3 s_4 s_5 \n    x_e = y_1 s_1 s_2 s_3 s_3 s_4 s_5 \n    x_s = y_2 y_3 y_4 \n    x_c = y_5\nendaligned","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"In what follows, we will renumber the unknowns in x such that x_e are in the beginning, x_s are in the middle and x_c are at the end. In the code we don't actually do this, but it makes it easier to discuss the linear algebra in the following sections.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    x =  x_e  x_s  x_c ","category":"page"},{"location":"DesignPapers/final_conditions/#Equations","page":"Final Conditions","title":"Equations","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"The equations are also grouped into the same three groups and for the purpose of this exposition we put them in the same order as we did with the unknowns above.","category":"page"},{"location":"DesignPapers/final_conditions/#The-System-of-Equations","page":"Final Conditions","title":"The System of Equations","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Without loss of generality we have a system of equations F(x) = 0. Starting with an initial guess x^0, the Newton-Raphson method consists in the iteration","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    x^n+1 = x^n - J(x^n)^-1 F(x^n)qquadmathrmfor n=012","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"where J(x^n) is the Jacobian of F evaluated at x^n.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"warning: Important\nWe need to distinguish between initial condition and initial guess. The former refers to the values of the model variables prior to the simulation range. The latter is the vector of unknowns at the start of the iterative solution method. To distinguish the two, we use upper index (superscript) to denote the successive iterations of the Newton-Raphson method, while the lower index (subscript) is used to denote the variable group e, s, or c.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"The computational step here consists in solving the linear system with matrix J and right hand side F. We can write this system into a 3-by-3 block-matrix form, with rows corresponding to equations and columns corresponding to unknowns split into the three groups.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    beginbmatrix I  0  0  E_s  S  C_s  E_c  S_c  C endbmatrix\n    cdot\n    beginbmatrix delta x_e  delta x_s  delta x_c endbmatrix\n    =\n    beginbmatrix 0  F_s  F_c endbmatrix","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"The first row corresponds to exogenous and initial conditions. Notice that the unknown here is not x but the update delta x. If we assign the correct exogenous and initial values in x^0 then the residuals of this group of equations will be all zeros, F_e = 0, and so the update delta x_e will also be always zero.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Therefore the entire system reduces to solving the following:","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    beginbmatrix S  C_s  S_c  C endbmatrix\n    cdot\n    beginbmatrix delta x_s  delta x_c endbmatrix\n    =\n    beginbmatrix F_s  F_c endbmatrix","category":"page"},{"location":"DesignPapers/final_conditions/#Solution-Method","page":"Final Conditions","title":"Solution Method","text":"","category":"section"},{"location":"DesignPapers/final_conditions/#Case-1:-fcgiven","page":"Final Conditions","title":"Case 1: fcgiven","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"In this case we have","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    beginbmatrix S  C_s  0  I endbmatrix\n    cdot\n    beginbmatrix delta x_s  delta x_c endbmatrix\n    =\n    beginbmatrix F_s  0 endbmatrix","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Once again we assume that the correct values for x_c are assigned in the initial guess, x^0. Therefore the update delta x_c is always zero. Therefore in this case we simply solve","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    S cdot delta x_s = F_s","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Note that even though we are not explicitly solving for delta x_e and delta x_c, the matrix S and the right hand side F_s here depend on the values x_e and x_c, since they are part of x^n when evaluating F(x^n) and J(n^n).","category":"page"},{"location":"DesignPapers/final_conditions/#Case-2:-fclevel","page":"Final Conditions","title":"Case 2: fclevel","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"This is identical to case 1.","category":"page"},{"location":"DesignPapers/final_conditions/#Case-3:-fcslope","page":"Final Conditions","title":"Case 3: fcslope","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"This is an interesting case. Pay attention because this part is tricky.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"We have the following equations.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"beginaligned\n    S cdot delta x_s + C_s cdot delta x_c = F_s \n    S_c cdot delta x_s + C cdot delta x_c = F_c\nendaligned","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"We eliminate delta x_c from the system. To do so, we multiply the second equation by C_s C^-1 and subtract the result from the first equation.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    left( S - C_s C^-1 S_c right) cdot delta x_s = F_s - C_s C^-1 F_c","category":"page"},{"location":"DesignPapers/final_conditions/#Solve-for-\\delta-x_s","page":"Final Conditions","title":"Solve for delta x_s","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Suppose that F_c = 0. We will discuss later how we make sure that's the case. Then the solution for delta x_s is given by","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    left( S - C_s C^-1 S_c right) cdot delta x_s = F_s","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"The only difference with case 1 and 2 is that the system matrix is modified by subtracting C_s C^-1 S_c. The matrix C^-1 S_c is constant. This matrix is specific to the fcslope type of final conditions for the given model. It only depends on the number of variables and the number of final conditions periods. It can be pre-computed and stored.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"The matrix C_s on the other hand depends on x^n and so it needs to be re-computed at every iteration.","category":"page"},{"location":"DesignPapers/final_conditions/#Solve-for-\\delta-x_c","page":"Final Conditions","title":"Solve for delta x_c","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"How do we make sure that F_c = 0? Remember that the final conditions equation in our example model is","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"y_5 - y_4 = ssY_slope","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Imagine how this would generalize to an arbitrary model. Now notice that the residual F_c depends on x^n and the slope of the steady state ssY_slope. Since we know the x^n_s part of x^n prior to solving the system, we can set the x^n_c part of x^n so that the final conditions are satisfied. In other words, this would make sure that F_c = 0. One way to do this is to simply start from the values of the variables at the last period of the simulation (which are in x^n_s; that's y_4 in our example) and compute all future values (which are in x^n_c,; that's y_5 in the example) by adding the corresponding steady state slope (that is y_5 = y_4 + ssY_slope). We must do this on every iteration before we evaluate F(x^n) and J(x^n).","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Actually, that's not true. It turns out that we only need to do this to the initial guess x^0. After that, once we compute delta x_s by solving the above system, we can solve the following system for delta x_c.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    C cdot delta x_c = - S_c cdot delta x_s","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"With delta x computed this way, the resulting x^n+1 will produce F_c=0 at the next iteration. This can be verified directly.","category":"page"},{"location":"DesignPapers/final_conditions/#The-Matrices:-C,-S_c-and-C{-1}S_c","page":"Final Conditions","title":"The Matrices: C, S_c and C^-1S_c","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"These matrices have 0 everywhere except for some non-zero blocks, which we discuss here.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Our running example has only one period of final conditions and a single variable, which is a trivial case. In order to see what happens in a more general case, suppose we have 4 periods of final conditions and several variables. In matrix C we will have a block, C_b, like the one below for each variable in the model. Each C_b will be the same square block with as many rows and columns as the number of final condition periods.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"C_b = beginbmatrix\n    1  0  0  0  -1  1  0  0  0  -1  1  0  0  0  -1  1\n    endbmatrix","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Matrix S_c also contains identical blocks S_cb for each variable. The number of rows is the same as C_b, while the number of columns equals the number of simulation periods. The -1 in the top-right corner is in the column corresponding to the last period of the simulation. (In our trivial example above that would be t=4)","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"S_cb = beginbmatrix\n            0  cdots  0  -1 \n            0  cdots  0  0 \n            0  cdots  0  0 \n            0  cdots  0  0\n          endbmatrix","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Now it is straightforward to compute C^-1 S_c. It also has block-structure with blocks like this:","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":" left(C^-1S_cright)_b = beginbmatrix\n            0  cdots  0  -1 \n            0  cdots  0  -1 \n            0  cdots  0  -1 \n            0  cdots  0  -1 \n        endbmatrix","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"The column with -1 again corresponds to the last period of the simulation.","category":"page"},{"location":"DesignPapers/final_conditions/#Case-4:-fcnatural","page":"Final Conditions","title":"Case 4: fcnatural","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"This case is identical to case 3. The only thing that changes is the matrices.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"This time for our example we will use 5 periods of final conditions, so that the patterns would be more obvious. We have the following.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"C_b = beginbmatrix\n    -1   0   0   0   0 \n     2  -1   0   0   0 \n    -1   2  -1   0   0 \n     0  -1   2  -1   0 \n     0   0  -1   2  -1 \n    endbmatrix","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"For S_c this time we have non-zeros in two columns corresponding to the last two periods of the simulation.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"S_cb = beginbmatrix\n            0  cdots  0  -1  2 \n            0  cdots  0  0  -1 \n            0  cdots  0  0   0 \n            0  cdots  0  0   0 \n            0  cdots  0  0   0 \n          endbmatrix","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Finally, we have","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":" left(C^-1S_cright)_b = beginbmatrix\n            0  cdots  0  1  -2 \n            0  cdots  0  2  -3 \n            0  cdots  0  3  -4 \n            0  cdots  0  4  -5 \n            0  cdots  0  5  -6 \n        endbmatrix","category":"page"},{"location":"DesignPapers/final_conditions/#Handling-of-log-variables","page":"Final Conditions","title":"Handling of log-variables","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"If we have log variables the final conditions the cases of fclevel and fcgiven are the same as above.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"In the case of fcslope the balanced growth path solution is actually a geometric sequence. What we call its \"slope\" here is actually the common ratio, that is ssY_slope = ssY_t  ssY_t-1 for all t. We have final condition equations that look like this:","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    y_5  y_4 = ssY_slope","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"In the case of fcnatural, we again impose the condition that the solution must be a geometric sequence, although this time the common ratio is unknown and we must solve for it. We have final conditions like this","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    y_5  y_4 = y_4  y_3","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"In both cases it is better to work with an equivalent formulation in terms of logs.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"beginaligned\n    log(y_5) = log(y_4) + log(ssY_slope) qquad  mathrmfor fcslope \n    log(y_5) = 2 log(y_4) - log(y_3) qquad  mathrmfor fcnatural\nendaligned","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"If we were to implement this directly, the matrix blocks C_b and S_cb corresponding to log-variables would not be constant (as they were above for non-log variables), because they would contain the derivatives of the above log functions and would therefore need to be re-computed on each iteration.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"However, in our implementation of log-variables, we apply the log-transformation and so the unknowns we actually solve for are log(y_t). Thus, the final conditions are in fact identical to the ones for non-log variables and we don't need to do anything special here.","category":"page"},{"location":"DesignPapers/final_conditions/#Conclusion","page":"Final Conditions","title":"Conclusion","text":"","category":"section"},{"location":"Tutorials/TimeSeriesEcon/main/#TimeSeriesEcon","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"","category":"section"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"All the code contained here is also available in this file: main.jl.","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"Pages = [\"main.md\"]\nDepth = 3","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"using TimeSeriesEcon\nusing Plots","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/#Part-1:-MIT-and-TSeries","page":"TimeSeriesEcon","title":"Part 1: MIT and TSeries","text":"","category":"section"},{"location":"Tutorials/TimeSeriesEcon/main/#Initialize-MITs-and-TSeries","page":"TimeSeriesEcon","title":"Initialize MITs and TSeries","text":"","category":"section"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"MIT (Moment-in-Time) is a primitive type based on 64-bit signed integers that  represents discrete dates. There are two ways to initialize  MITs: ","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"(1) directly 2020M8, or \n(2) using the functional form mm(2020, 8).","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"Internally, MIT contains Frequency information - more on this in the next section. ","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"mit_integer = 2000U  # ii(2000)\n\nmit_monthly = 2020M8 # mm(2020, 8)\n\nmit_quarterly = 2020Q3 # qq(2020, 3)\n\nmit_yearly = 2020Y  # yy(2020)","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"TSeries is subtype of AbstractVector and represents 1-dimensional time-series. A key feature of TSeries is the ability to use MITs as indices to get and set values. ","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"note: Note\nTSeries converts all values to Float64. The automatic conversion feature might be changed in the future.","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"series_monthly = TSeries(2020M1, rand(1:10, 6))","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"There are various ways to initialize TSeries - here, we provided an MIT that represents the first date in the series and a vector of random values.","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"As you can see, the frequency of MIT carries over to a TSeries instance.","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/#Frequency","page":"TimeSeriesEcon","title":"Frequency","text":"","category":"section"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"Every instance of MIT and TSeries is equipped with Frequency information, which is stored as a parameter.","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"frequencyof(2020M8)\nfrequencyof(series_monthly)","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"As such, we can avoid performing operations on TSeries or MITs of different frequencies. Also, having Frequency parameter simplifies the retrieval of frequency specific information.","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"year(2020M8)\nperiod(2020M8)\n\nppy(2020M8) # number of periods per year","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/#Part-2:-Indexing-using-MITs","page":"TimeSeriesEcon","title":"Part 2: Indexing using MITs","text":"","category":"section"},{"location":"Tutorials/TimeSeriesEcon/main/#Access","page":"TimeSeriesEcon","title":"Access","text":"","category":"section"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"Just as integers are used to index into Julia vectors, MITs are used to index into TSeries. ","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"Indexing using a single MIT returns a float value associated with that date.\nIndexing using a range of MITs will return another TSeries instance","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"series_monthly\n\nseries_monthly[2020M1]\nseries_monthly[2020M1:2020M3]","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/#Assign","page":"TimeSeriesEcon","title":"Assign","text":"","category":"section"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"series_monthly[2020M1] = -1;\nseries_monthly\n\nseries_monthly[2020M2:end] = -1;\nseries_monthly","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"You can also assign values outside of the bounds that were initially declared.","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"series_monthly[end + 2] = -1;\nseries_monthly","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/#Part-3:-Plots-and-helpful-functions","page":"TimeSeriesEcon","title":"Part 3: Plots and helpful functions","text":"","category":"section"},{"location":"Tutorials/TimeSeriesEcon/main/#Plotting-support","page":"TimeSeriesEcon","title":"Plotting support","text":"","category":"section"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"Using the Plots package, we can plot multiple TSeries with varying frequency.","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"plot(TSeries(2000Q1, rand(1:3, 10)), \n     TSeries(2000M1, rand(4:6, 30)),\n     legend=true, \n     title=\"TSeries Plot\", \n     label=[\"Quarterly\" \"Monthly\"],\n     size=(600, 400)\n    );","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"savefig(\"tseries.png\")","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"(Image: TSeries Graph)","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/#Conversions","page":"TimeSeriesEcon","title":"Conversions","text":"","category":"section"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"Note that support for frequency conversions is under development. ","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"tsmonthly = TSeries(2020M1, collect(Float64, 1:12))\n# Monthly -> Quarterly (high to low by mean (default method))\ntsquarterly = fconvert(Quarterly, tsmonthly)\n# Monthly -> Quarterly (high to low by sum)\nfconvert(Quarterly, tsmonthly; method = :sum)\n# Monthly -> Quarterly (high to low by first value)\nfconvert(Quarterly, tsmonthly; method = :begin)\n# Monthly -> Quarterly (high to low by last value)\nfconvert(Quarterly, tsmonthly; method = :end)\n# Quarterly -> Monthly (low to high by piecewise-constant)\nfconvert(Monthly, tsquarterly)","category":"page"},{"location":"DesignPapers/log_variables/#Log-variables","page":"Log-variables","title":"Log-variables","text":"","category":"section"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"This article describes the intended meaning of declaring a variable using the @log annotation, and the internal handling of such variables.","category":"page"},{"location":"DesignPapers/log_variables/#What-is-a-log-variable","page":"Log-variables","title":"What is a log-variable","text":"","category":"section"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"A variable should be declared using the @log annotation when its balanced growth path is exponential growth or decay. Specifically this means that","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"X_t = c X_t-1","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"for some c, which we call its slope. The balanced growth path forms a geometric sequence with common ratio c. The growth rate, let's call it r, is related to the slope as c = 1 + r.","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"This has implications to how we solve for the steady state of such variable and also to how we impose final conditions of type fcslope and fcnatural.","category":"page"},{"location":"DesignPapers/log_variables/#Implementation-details","page":"Log-variables","title":"Implementation details","text":"","category":"section"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"Internally we work with the log transformation of log variables. All equations and data provided by the user should be in terms of the declared variable. This log transformation is done internally, automatically, and should be completely transparent to the user.","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"It is not strictly necessary to use such transformation. However, this approach simplifies several aspects of the implementation. In addition, a log-variable is always positive and usually appears as argument to logarithms, fractional powers and division, which might produce domain errors if the argument becomes negative or zero, for example during the solver iterations. By working with the log of the variable, which is allowed to be any real number, we avoid such problems.","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"Applying this transformation affects the following parts of the implementation.","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"Transform the dynamic equations and their corresponding steady state equations.\nTransform the steady-state constraints.\nApply appropriate final conditions in the case of fcslope and fcnatural.\nTransform the linearization about a solution with log-variables.","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"We also need to transform the user provided data before running the solution algorithms and then transform the solution back by applying the inverse transformation before returning it to the user. This includes","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"initial conditions,\nexogenous data,\nsteady state solution,\nsimulation result,\ndata given in deviation from the steady state.","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"We address each of these in the remainder of this article.","category":"page"},{"location":"DesignPapers/log_variables/#Transformations-of-the-equations","page":"Log-variables","title":"Transformations of the equations","text":"","category":"section"},{"location":"DesignPapers/log_variables/#Dynamic-equations","page":"Log-variables","title":"Dynamic equations","text":"","category":"section"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"When a mention of a variable is encountered in an equation, we replace that mention by a new symbol whose name is made up from the name of the variable and the lag or lead value. For example, equation Y[t] = Y[t-1] + 0.1 becomes #Y#0# = #Y#-1# + 0.1, where #Y#0# and #Y#-1# are the new variable names corresponding to the contemporaneous and lag 1 values of Y.","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"When a variable is declared @log X, the new symbols created for the different lags have the meaning of the log of that variable. For example, equation X[t] / X[t-1] = 1.01 becomes exp(#logX#0#) / exp(#logX#-1#) = 1.01.","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"All we have to do from this point on is to make sure that the data values for these variables are transformed accordingly. In particular, there is no need to do anything about transforming the gradients of the equation residual functions, since they are automatically computed from the transformed equation by automatic differentiation.","category":"page"},{"location":"DesignPapers/log_variables/#Steady-state-equations-derived-from-dynamic-equations","page":"Log-variables","title":"Steady state equations derived from dynamic equations","text":"","category":"section"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"For regular variables we substitute","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"Y_t = lvl_Y + (t-t_ref) * slp_Y","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"in the dynamic equations. t_ref is a reference time: time at which Y[t_ref] = lvl_Y. All lags and leads of Y are unknowns in the dynamic system, while here, in the steady state system, we have two unknowns, namely lvl_Y and slp_Y. For this reason, we take each equation at two different values of t.","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"In the case of @log X variable, we have the steady state substitution","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"X_t = exp(lvl_logX + (t-t_ref) * slp_logX)","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"Since the dynamic equations have already been transformed in terms of log(X_t), we actually have to do the substitution","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"log(X_t) = lvl_logX + (t-t_ref) slp_logX","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"which is the same as for non-log variables. So once again we don't need to do anything to the equations, we only need to transform the data.","category":"page"},{"location":"DesignPapers/log_variables/#Steady-state-constraints","page":"Log-variables","title":"Steady state constraints","text":"","category":"section"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"Here we expect the user to provide equations in terms of the original meaning of the log-variable. When X is mentioned in a level type constraint, we replace it by exp(lvl_logX) and similarly in a slope type constraint we replace is by exp(slp_logX).","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"This works well when the constraint is simply assigning a known value. The user must keep in mind that we interpret the slope as the common ratio of the geometric sequence and provide values in these terms.","category":"page"},{"location":"DesignPapers/log_variables/#Final-conditions","page":"Log-variables","title":"Final conditions","text":"","category":"section"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"This is discussed at the end of the article on final conditions. TLDR: we don't need to do anything special since we're working with the log-transformed variables.","category":"page"},{"location":"DesignPapers/log_variables/#Linearization","page":"Log-variables","title":"Linearization","text":"","category":"section"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"TODO","category":"page"},{"location":"DesignPapers/log_variables/#Transforming-the-data","page":"Log-variables","title":"Transforming the data","text":"","category":"section"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"Every value of user-provided data for a log-variable we must apply log() before using it internally. Also, every value we compute for a log-variable, we must apply exp() before returning it to the user.","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"There is nothing special about this, we just have to make sure to do it.","category":"page"},{"location":"DesignPapers/log_variables/#Data-provided-in-deviation","page":"Log-variables","title":"Data provided in deviation","text":"","category":"section"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"TODO","category":"page"},{"location":"Tutorials/FRB-US/main/#FRB/US-with-VAR-based-Expectations","page":"FRB/US","title":"FRB/US with VAR-based Expectations","text":"","category":"section"},{"location":"Tutorials/FRB-US/main/#Getting-started","page":"FRB/US","title":"Getting started","text":"","category":"section"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"If you wish to run the code of this tutorial, or to experiment for yourself, make sure to follow the instructions in Introduction/Getting_started.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"using StateSpaceEcon\nusing ModelBaseEcon\nusing TimeSeriesEcon\n\nusing Test\nusing Plots\nusing Random\n\n# Fix the random seed for reproducibility.\nRandom.seed!(1234);\n\n# We need the model file FRBUS_VAR.jl to be on the search path for modules.\nunique!(push!(LOAD_PATH, realpath(\"./models\"))) # hide\n","category":"page"},{"location":"Tutorials/FRB-US/main/#The-Model-File","page":"FRB/US","title":"The Model File","text":"","category":"section"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"We recommend placing the model definition in its own Julia module in a separate source file. Although this is not strictly necessary, it helps to keep the code well organized and it also allows us to take advantage of pre-compilation. The first time we load the model file it takes some time to compile, and after that loading is much faster.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"The FRB/US model we will be working with is located in models/FRBUS_VAR.jl.  This file was automatically generated from the model.xml file contained within frbus_package.zip.","category":"page"},{"location":"Tutorials/FRB-US/main/#Some-Notes-About-the-Julia-Model-File","page":"FRB/US","title":"Some Notes About the Julia Model File","text":"","category":"section"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Some variables are declared as log variables using the @log declaration within a @variables block. For example\n@variables model begin\n    # ... #\n    \"Investment in equipment, current \\$\" @log ebfin\n    \"Personal consumption expenditures, current \\$ (NIPA definition)\" @log ecnian\n    # ... #\nend\nA full discussion of log variables is beyond the scope of this tutorial.  However a very simplified explanation is that this improves the stability of  the numerical solver for variables which are always positive.\nVariables which do not have an associated equation, and for which data is always given, are declared exogenous using an @exogenous block. For example\n@exogenous model begin\n    # Exogenous variables:\n    \"Potential government employment ratio (relative to business)\" adjlegrt\n    \"Dummy, post-1979 indicator\" d79a\n    \"Dummy, 1980-1995 indicator\" d8095\n    # ... #\nend\nThe EViews syntax is translated to Julia syntax. EViews functions d() and dlog() are replaced with their equivalent StateSpaceEcon meta functions @d() and @dlog(). EViews @movav() is left alone, because a meta function by the same name already exists in StateSpaceEcon, and does the same thing. Finally, the EViews @recode() is replaced with the equivalent Julia function ifelse(), or where appropriate with a min() or a max().\nSeveral equations contain expressions matching the pattern 1 / (1 + exp(-cx)), where c is a large constant (usually 25) and x is some expression. This sigmoid function is a smooth approximation of the Heaviside step function for large values of c. While mathematically the derivative of this function is well defined and converges to approximately zero everywhere outside a very small interval containing 0, numerically it causes problems because it results in either 0/0 or ∞/∞. To remedy this situation, we replace such patterns with equivalent calls to heaviside(cx), where the function heaviside() is defined in the model file.\nexport heaviside\n\"Heaviside step function\" @inline heaviside(x) = convert(typeof(x), x>zero(x))","category":"page"},{"location":"Tutorials/FRB-US/main/#Regenerating-the-Model-File","page":"FRB/US","title":"Regenerating the Model File","text":"","category":"section"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"We have included the script update_models.jl. It is not necessary for running the code below, but it may be helpful for further experimentation.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"If the model file is missing, for some reason or another, this script will automatically download frbus_package.zip and process the model.xml within it to re-generate model/FRBUS_VAR.jl. This could also be useful if you make modifications to model.xml (including not only the equations, but also the parameter values), or if you want to use a different FRBUS package from the one posted on the FRBUS website. In this case, simply place your frbus_package.zip in the models/ directory and run update_models.jl. Of course such modifications can also be done directly into the existing models/FRBUS_VAR.jl file.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Note that after updating models/FRBUS_VAR.jl, it'd be best to restart the REPL. The first time you load the new model module it'll take a bit longer due to pre-compilation.","category":"page"},{"location":"Tutorials/FRB-US/main/#Load-the-Model","page":"FRB/US","title":"Load the Model","text":"","category":"section"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Assuming that the models/ directory is already in the LOAD_PATH list, we can load the model by using its module. Once loaded, the module contains a variable model which represents the model object.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"using FRBUS_VAR\nm = FRBUS_VAR.model","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"We see that the model has a number of variables, shocks, equations, and parameters. The total number of variables include exogenous variables.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"m.variables","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"We also see that the model object includes a number of auxiliary equations. These equations (and variables) are automatically added as substitutions for expressions that must be positive.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"m.auxeqns","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"For example, we see that variable aux1 was added with the first equation in the above list. At the same time, in equation for dpgap, the expression log(phr[t] * pxp[t]) has been replaced by aux1[t].","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"m.equations[2]","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"A detailed discussion of auxiliary variables and equations is beyond the scope of this tutorial. It suffices to say that we can safely ignore their presence for now.","category":"page"},{"location":"Tutorials/FRB-US/main/#Load-the-Longbase-Data","page":"FRB/US","title":"Load the Longbase Data","text":"","category":"section"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Unfortunately the longbase data is available only in EViews format, which cannot be read automatically by open source software (at least to our knowledge). For convenience, here we have included the version of longbase from 23-07-2020 in a csv format and a function that loads that data. The function is defined in file load_longbase.jl. Note that this is not a module, so we load it by calling include(), not using.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"include(\"load_longbase.jl\")\nlongbase = load_longbase(\"longbase_23072020.csv\")\n@test size(longbase) == (834, 659) # hide","category":"page"},{"location":"Tutorials/FRB-US/main/#Load-set_policy.jl","page":"FRB/US","title":"Load set_policy.jl","text":"","category":"section"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"The model contains a number of switch variables to control which monetary policy function is used and which fiscal policy function is used at each period of the simulation. For convenience, we have included functions set_mp!() and set_fp!(), which are defined in set_policy.jl.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"include(\"set_policy.jl\")\n@doc set_mp!\n\ndmp_switches\n\n@doc set_fp!\n\ndfp_switches","category":"page"},{"location":"Tutorials/FRB-US/main/#Prepare-the-Simulation-Plan","page":"FRB/US","title":"Prepare the Simulation Plan","text":"","category":"section"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"The simulation is controlled by a Plan object. The plan is defined by a model object and a simulation range. The full range handled by the plan contains additional periods before and after the simulation range, which account for initial and final conditions. By default, the simulation plan is setup such that all shocks are exogenous and all variables are endogenous, except for the variables that are declared either in an @exogenous block or with the @exog declaration within an @variables block in the model file.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"sim = 2020Q1:2025Q4     # simulation range\np = Plan(m, sim)        # the plan object\n\nini = firstdate(p):first(sim) - 1      # range of initial conditions\nfin = last(sim) + 1:lastdate(p)        # range of final conditions","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Note that the fin range is actually empty. This is because this model doesn't have any leads.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"isempty(fin)","category":"page"},{"location":"Tutorials/FRB-US/main/#Prepare-the-Exogenous-Data","page":"FRB/US","title":"Prepare the Exogenous Data","text":"","category":"section"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"We start by pre-allocating simulation data that is set to 0 everywhere.  Then we assign within it the data from longbase using Julia's .= operator.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"ed = zerodata(m, p);\ned .= longbase[p.range];","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Next we set the monetary policy, the fiscal policy and a few other switches.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"# set monetary policy\nset_mp!(ed, :dmpintay);\n\n# turn off zero bound and policy thresholds;\n# hold policy maker's perceived equilibrium real interest rate\ned.dmptrsh .= 0.0;\ned.rffmin .= -9999;\ned.drstar .= 0.0;\n\n# set fiscal policy\nset_fp!(ed, :dfpsrp);\n\n@test all(sum(abs, ed[dmp_switches], dims=2) .== 1) # hide\n@test all(sum(abs, ed[dfp_switches], dims=2) .== 1) # hide\n","category":"page"},{"location":"Tutorials/FRB-US/main/#Back-out-the-Shocks","page":"FRB/US","title":"Back out the Shocks","text":"","category":"section"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"The first simulation test is to compute the shocks given the variable paths from longbase. To do this, we swap the variables and shocks, making variables exogenous and shocks endogenous. The mapping between variables and their corresponding shocks is declared in the model file, so we can simply call autoexogenize!. We make a copy of the plan p, so that the original plan would not be modified. We also make a copy of the exogenous data, ed, so that the original would remain unchanged.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"p_0 = autoexogenize!(copy(p), m, sim)\ned_0 = copy(ed)","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Now we run the simulate command. Note that the first time we run a function in Julia it takes a bit longer due to compilation time. In this case, it takes much longer because the model is very large and each and every equation gets compiled together with its automatic derivative.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"sol_0 = @time simulate(m, p_0, ed_0; verbose=true, tol=1e-12);\n@test sol_0[m.variables] ≈ ed[m.variables]","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"The compilation is done once and the compiled code is used in every call after that. So the second call to simulate is much, much faster.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"sol_0 = @time simulate(m, p_0, ed_0; verbose=true, tol=1e-12);","category":"page"},{"location":"Tutorials/FRB-US/main/#Recover-the-Baseline-Case","page":"FRB/US","title":"Recover the Baseline Case","text":"","category":"section"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Next simulation is a sanity check test. If we run a simulation with the shocks set to the values we just backed out, the resulting variable paths must match the ones we started with.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Once again we start with an exogenous data set everywhere to 0. Then we assign only the initial conditions and the shocks we just backed out.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"p_r = Plan(m, sim);\ned_r = zerodata(m, p_r);\n\n# initial conditions for the variables are taken from longbase\ned_r[ini, m.variables] .= longbase[ini, m.variables];\n\n# shocks are taken from from sol_0\ned_r[p_r.range, m.shocks] .= sol_0[p_r.range, m.shocks];\n\n# exogenous variables are also taken  from sol_0\nexogenous = Symbol[v for v in m.variables if isexog(v)];\ned_r[p_r.range, exogenous] .= sol_0[p_r.range, exogenous];","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Now, the only thing left is to set the initial guess for the endogenous variables. If we leave it at 0, that would be an initial guess too far from the solution and the Newton-Raphson will likely diverge. If we set it to the known solution, that would diminish this exercise to merely verifying that it is indeed a solution (we already know that). So, to make things a bit more interesting, we add a bit of noise to the true solution.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"endogenous = Symbol[v for v in m.variables if !isexog(v)];\ned_r[sim, endogenous] .= longbase[sim, endogenous] .+ 0.03.*randn(length(sim), length(endogenous));","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Once again we have to set the monetary policy and the fiscal policy rules, as well as the values of some of the other switches.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"set_mp!(ed_r, :dmpintay);\ned_r.dmptrsh .= 0.0;\ned_r.rffmin .= -9999;\ned_r.drstar .= 0.0;\nset_fp!(ed_r, :dfpsrp);","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"And finally we can run the simulation and check to make sure that indeed the recovered simulation matches the base case.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"sol_r = @time simulate(m, p_r, ed_r; verbose=true, tol=1e-9);\n@test sol_r ≈ sol_0","category":"page"},{"location":"Tutorials/FRB-US/main/#Simulate-a-shock","page":"FRB/US","title":"Simulate a shock","text":"","category":"section"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"The last exercise is to simulate the impulse response to a unit shock in rffintay.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"m.rffintay","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"We start with the base case and add 1 to the rffintay_a shock at the first period of the simulation.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"p_1 = Plan(m, sim);\ned_1 = copy(sol_0);\n\ned_1.rffintay_a[first(sim)] += 1;\nsol_1 = @time simulate(m, p_1, ed_1; verbose=true, tol=1e-9);\n","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Finally, we can plot the impulse response function to see what we've done.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"# compute the differences between the base case and the shocked simulation.\ndd = hcat(SimData(p.range),\n    d_rff=sol_1.rff - sol_0.rff,\n    d_rg10=sol_1.rg10 - sol_0.rg10,\n    d_lur=sol_1.lur - sol_0.lur,\n    d_pic4=sol_1.pic4 - sol_0.pic4,\n);\n\n# produce the plot\nplot(dd[sim], vars=(:d_rff, :d_rg10, :d_lur, :d_pic4), \n     legend=false, size=(600, 400));","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"savefig(\"irf.png\")","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"(Image: Impulse Response Graph)","category":"page"},{"location":"Tutorials/LICENSE/","page":"-","title":"-","text":"BSD 3-Clause License","category":"page"},{"location":"Tutorials/LICENSE/","page":"-","title":"-","text":"Copyright (c) 2020, Bank of Canada All rights reserved.","category":"page"},{"location":"Tutorials/LICENSE/","page":"-","title":"-","text":"Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:","category":"page"},{"location":"Tutorials/LICENSE/","page":"-","title":"-","text":"Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.","category":"page"},{"location":"Tutorials/LICENSE/","page":"-","title":"-","text":"THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","category":"page"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon-Reference","page":"TimeSeriesEcon","title":"TimeSeriesEcon Reference","text":"","category":"section"},{"location":"Reference/TimeSeriesEcon/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"Modules = [TimeSeriesEcon]","category":"page"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.Duration","page":"TimeSeriesEcon","title":"TimeSeriesEcon.Duration","text":"MIT{F <: Frequency}, Duration{F <: Frequency}\n\nTwo types representing a  moment in time (like 2020Q1 or 2020-01-01) and duration (the quantity of time between two moments).\n\nBoth of these have a Frequency as a type parameter and both  internally are represented by integer values.\n\nIf you imagine a time axis of the given Frequency, MIT values are ordinal (correspond to points) while Duration values are cardinal  (correspond to distances). \n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.Frequency","page":"TimeSeriesEcon","title":"TimeSeriesEcon.Frequency","text":"abstract type Frequency end\n\nThe abstract supertype for all frequencies. See also: Unit and YPFrequency\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.MIT","page":"TimeSeriesEcon","title":"TimeSeriesEcon.MIT","text":"MIT{F <: Frequency}, Duration{F <: Frequency}\n\nTwo types representing a  moment in time (like 2020Q1 or 2020-01-01) and duration (the quantity of time between two moments).\n\nBoth of these have a Frequency as a type parameter and both  internally are represented by integer values.\n\nIf you imagine a time axis of the given Frequency, MIT values are ordinal (correspond to points) while Duration values are cardinal  (correspond to distances). \n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.MIT-Union{Tuple{F}, Tuple{N}, Tuple{Integer, Integer}} where {N, F<:YPFrequency{N}}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.MIT","text":"MIT{F}(year, period) where {F <: YPFrequency}\n\nConstruct an MIT instance from year and period. This is valid only for frequencies subtyped from YPFrequency.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.Monthly","page":"TimeSeriesEcon","title":"TimeSeriesEcon.Monthly","text":"Yearly, Quarterly, Monthly\n\nFrequencies corresponding to 1, 4, and 12 periods per year. See also: YPFrequency\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.Quarterly","page":"TimeSeriesEcon","title":"TimeSeriesEcon.Quarterly","text":"Yearly, Quarterly, Monthly\n\nFrequencies corresponding to 1, 4, and 12 periods per year. See also: YPFrequency\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.TSeries","page":"TimeSeriesEcon","title":"TimeSeriesEcon.TSeries","text":"mutable struct TSeries{F, T, C} <: AbstractVector{T}\n    firstdate::MIT{F}\n    values::C\nend\n\nTime series with frequency F with values of type T stored in a container of type C. By default the type is Float64 and the container is Vector{Float64}.\n\nConstruction:     ts = TSeries(args...)\n\nThe standard construction is `TSeries(firstdate::MIT, values::AbstractVector)`\n\nIf the first argument is an MIT-range (instead or an MIT), then the length\nof the `values` container must match the length of the given range.\n\nIn the case of a range argument, the `values` can be omitted, in which case\nthe container is initializes with `undef`. Or you can also pass a constant\nand then the `values` will be filled with that constant. To accomplish this,\nyou can also use `fill`, e.g., `TSeries(20Q1:20Q4, 5)` is the same as\n`fill(5, 20Q1:20Q4)`.\n\nIf only a `firstdate::MIT` is given, the `values` container is initialized\nto an empty `Vector`.\n\nIf only an `n::Integer` is given, it is the same as passing the range\n`0U .+ (1:n)`. An initialization argument is not allowed in this case.\n\nA `TSeries` can also be constructed with `copy`, `similar`, and `fill`.\n\nIndexing:\n\nIndexing with an `MIT` or a range of `MIT` works as you'd expect.\n\nIndexing with `Integer`s works the same as with `Vector`.\n\nIndexing with `Bool`-array works as you'd expect. For example,\n`s[s .< 0.0] .*= -1` multiplies in place the negative entries of `s` by -1,\nso effectively it's the same as `s .= abs.(s)`.\n\nThere are important differences between indexing with MIT and not\nusing MIT (i.e., using Integer or Bool-array).\n\n* with MIT-range we return a TSeries with the given range, otherwise we\n  return a `Vector`\n\n* the range can be extended (the TSeries resized appropriately) by assigning\n  outside the current range. This works only with MIT (you get a BoundsError\n  if you try to assign outside the Integer range).\n\n* `begin` and `end` are MIT, so either use both or none of them. For example\n  `s[2:end]` doesn't work because 2 is an `Int` and `end` is an `MIT`. You\n  should use `s[begin+1:end]`.\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.Unit","page":"TimeSeriesEcon","title":"TimeSeriesEcon.Unit","text":"struct Unit <: Frequency end\n\nRepresents a non-dimensional frequency (not associated with the calendar). See also: YPFrequency\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.Workspace","page":"TimeSeriesEcon","title":"TimeSeriesEcon.Workspace","text":"struct Workspace … end\n\nA collection of variables.\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.YPFrequency","page":"TimeSeriesEcon","title":"TimeSeriesEcon.YPFrequency","text":"abstract type YPFrequency{N} <: Frequency end;\n\nRepresents a calendar frequency based on a number of periods in a year.  The type parameter N is the number of periods and must be a positive integer. See also: Yearly, Quarterly, Monthly\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.Yearly","page":"TimeSeriesEcon","title":"TimeSeriesEcon.Yearly","text":"Yearly, Quarterly, Monthly\n\nFrequencies corresponding to 1, 4, and 12 periods per year. See also: YPFrequency\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.apct-Union{Tuple{TSeries{var\"#s10\", T, C} where {var\"#s10\"<:YPFrequency{N}, T<:Number, C<:AbstractVector{T}}}, Tuple{N}, Tuple{TSeries{var\"#s9\", T, C} where {var\"#s9\"<:YPFrequency{N}, T<:Number, C<:AbstractVector{T}}, Bool}} where N","page":"TimeSeriesEcon","title":"TimeSeriesEcon.apct","text":"apct(x::TSeries, islog::Bool)\n\nCalculate annualised percent rate of change in x.\n\nNote: The implementation is similar to IRIS.\n\nExamples\n\njulia> x = TSeries(qq(2018, 1), Vector(1:8));\n\njulia> apct(x)\nTSeries{Quarterly} of length 7\n2018Q2: 1500.0\n2018Q3: 406.25\n2018Q4: 216.04938271604937\n2019Q1: 144.140625\n2019Q2: 107.35999999999999\n2019Q3: 85.26234567901243\n2019Q4: 70.59558517284461\n\nSee also: pct\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.compare","page":"TimeSeriesEcon","title":"TimeSeriesEcon.compare","text":"@compare x y [options] \ncompare(x, y [; options])\n\nCompare two Workspace recursively and print out the differences. MVTSeries and Dict with keys of type Symbol are treated like Workspace. TSeries and other Vector are compared using isapprox, so feel free to supply rtol or atol.\n\nOptional argument name can be used for the top name. Default is \"_\".\n\nParameter showequal=true causes the report to include objects that are the same. Default behaviour, with showequal=false, is to report only the differences. \n\nParameter ignoremissing=true causes objects that appear in one but not the other workspace to be ignored. That is, they are not printed and do not affect the return value true or false. Default is ignoremissing=false meaning they will be printed and return value will be false.\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.fconvert-Tuple{Type{var\"#s9\"} where var\"#s9\"<:Frequency, TSeries}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.fconvert","text":"fconvert(F, t)\n\nConvert the time series t to the desired frequency F.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.fconvert-Union{Tuple{N2}, Tuple{N1}, Tuple{Type{var\"#s22\"} where var\"#s22\"<:YPFrequency{N1}, TSeries{var\"#s23\", T, C} where {var\"#s23\"<:YPFrequency{N2}, T<:Number, C<:AbstractVector{T}}}} where {N1, N2}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.fconvert","text":"fconvert(F1, t::TSeries{F2}; method) where {F1 <: YPFrequency, F2 <: YPFrequency}\n\nConvert between frequencies of the YPFrequency variety.\n\nTODO: describe method when converting to a higher frequency (interpolation) TODO: describe method when converting to a lower frequency (aggregation)\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.firstdate","page":"TimeSeriesEcon","title":"TimeSeriesEcon.firstdate","text":"firstdate(ts), lastdate(ts)\n\nReturn the first and last date of the allocated data for the given TSeries. These are identical to firstindex and lastindex.\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.frequencyof","page":"TimeSeriesEcon","title":"TimeSeriesEcon.frequencyof","text":"frequencyof(x), frequencyof(T)\n\nReturn the Frequency type of the given value x or type T.\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.lag","page":"TimeSeriesEcon","title":"TimeSeriesEcon.lag","text":"shift(x, n)\nshift!(x, n)\nlag(x, n=1)\nlag!(x, n=1)\nlead(x, n=1)\nlead!(x, n=1)\n\nShift, lag or lead the TSeries x by n periods.      By convention shift is the same as lead while lag(x,n) is the same as shift(x, -n). The versions ending in ! do it in place, while the others create a new TSeries instance.\n\nExamples\n\njulia> shift(TSeries(2020Q1, 1:4), 1)\nTSeries{Quarterly} of length 4\n2019Q4: 1.0\n2020Q1: 2.0\n2020Q2: 3.0\n2020Q3: 4.0\n\n\njulia> shift(TSeries(2020Q1, 1:4), -1)\nTSeries{Quarterly} of length 4\n2020Q2: 1.0\n2020Q3: 2.0\n2020Q4: 3.0\n2021Q1: 4.0\n\njulia> x = TSeries(2020Q1, 1:4);\n\njulia> shift!(x, 1);\n\njulia> x\nTSeries{Quarterly} of length 4\n2019Q4: 1.0\n2020Q1: 2.0\n2020Q2: 3.0\n2020Q3: 4.0\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.lag!","page":"TimeSeriesEcon","title":"TimeSeriesEcon.lag!","text":"shift(x, n)\nshift!(x, n)\nlag(x, n=1)\nlag!(x, n=1)\nlead(x, n=1)\nlead!(x, n=1)\n\nShift, lag or lead the TSeries x by n periods.      By convention shift is the same as lead while lag(x,n) is the same as shift(x, -n). The versions ending in ! do it in place, while the others create a new TSeries instance.\n\nExamples\n\njulia> shift(TSeries(2020Q1, 1:4), 1)\nTSeries{Quarterly} of length 4\n2019Q4: 1.0\n2020Q1: 2.0\n2020Q2: 3.0\n2020Q3: 4.0\n\n\njulia> shift(TSeries(2020Q1, 1:4), -1)\nTSeries{Quarterly} of length 4\n2020Q2: 1.0\n2020Q3: 2.0\n2020Q4: 3.0\n2021Q1: 4.0\n\njulia> x = TSeries(2020Q1, 1:4);\n\njulia> shift!(x, 1);\n\njulia> x\nTSeries{Quarterly} of length 4\n2019Q4: 1.0\n2020Q1: 2.0\n2020Q2: 3.0\n2020Q3: 4.0\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.lastdate","page":"TimeSeriesEcon","title":"TimeSeriesEcon.lastdate","text":"firstdate(ts), lastdate(ts)\n\nReturn the first and last date of the allocated data for the given TSeries. These are identical to firstindex and lastindex.\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.lead","page":"TimeSeriesEcon","title":"TimeSeriesEcon.lead","text":"shift(x, n)\nshift!(x, n)\nlag(x, n=1)\nlag!(x, n=1)\nlead(x, n=1)\nlead!(x, n=1)\n\nShift, lag or lead the TSeries x by n periods.      By convention shift is the same as lead while lag(x,n) is the same as shift(x, -n). The versions ending in ! do it in place, while the others create a new TSeries instance.\n\nExamples\n\njulia> shift(TSeries(2020Q1, 1:4), 1)\nTSeries{Quarterly} of length 4\n2019Q4: 1.0\n2020Q1: 2.0\n2020Q2: 3.0\n2020Q3: 4.0\n\n\njulia> shift(TSeries(2020Q1, 1:4), -1)\nTSeries{Quarterly} of length 4\n2020Q2: 1.0\n2020Q3: 2.0\n2020Q4: 3.0\n2021Q1: 4.0\n\njulia> x = TSeries(2020Q1, 1:4);\n\njulia> shift!(x, 1);\n\njulia> x\nTSeries{Quarterly} of length 4\n2019Q4: 1.0\n2020Q1: 2.0\n2020Q2: 3.0\n2020Q3: 4.0\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.lead!","page":"TimeSeriesEcon","title":"TimeSeriesEcon.lead!","text":"shift(x, n)\nshift!(x, n)\nlag(x, n=1)\nlag!(x, n=1)\nlead(x, n=1)\nlead!(x, n=1)\n\nShift, lag or lead the TSeries x by n periods.      By convention shift is the same as lead while lag(x,n) is the same as shift(x, -n). The versions ending in ! do it in place, while the others create a new TSeries instance.\n\nExamples\n\njulia> shift(TSeries(2020Q1, 1:4), 1)\nTSeries{Quarterly} of length 4\n2019Q4: 1.0\n2020Q1: 2.0\n2020Q2: 3.0\n2020Q3: 4.0\n\n\njulia> shift(TSeries(2020Q1, 1:4), -1)\nTSeries{Quarterly} of length 4\n2020Q2: 1.0\n2020Q3: 2.0\n2020Q4: 3.0\n2021Q1: 4.0\n\njulia> x = TSeries(2020Q1, 1:4);\n\njulia> shift!(x, 1);\n\njulia> x\nTSeries{Quarterly} of length 4\n2019Q4: 1.0\n2020Q1: 2.0\n2020Q2: 3.0\n2020Q3: 4.0\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.mit2yp","page":"TimeSeriesEcon","title":"TimeSeriesEcon.mit2yp","text":"mit2yp(x::MIT)\n\nRecover the year and period from a given MIT value. This is valid only if the frequency is subtyped from YPFrequency.\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.mm","page":"TimeSeriesEcon","title":"TimeSeriesEcon.mm","text":"mm(year, period), qq(year, period), yy(year, period=1)\n\nIRIS type constructors for MIT values with frequencies that have year and period. \n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.moving","page":"TimeSeriesEcon","title":"TimeSeriesEcon.moving","text":"moving(x, n)\n\nCompute the moving average of x over a window of n periods. If n > 0 the window is backward-looking (-n+1:0) and if n < 0 the window is forward-looking (0:-n-1).\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.overlay-Tuple{AbstractRange{var\"#s9\"} where var\"#s9\"<:MIT, Vararg{TSeries, N} where N}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.overlay","text":"overlay(rng, t1, t2, ...)\n\nIf the first argument is a range (must be of the same frequency), that becomes the range of the resulting TSeries.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.overlay-Tuple{Vararg{TSeries, N} where N}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.overlay","text":"overlay(t1, t2, ...)\n\nConstruct a TSeries in which each observation is taken from the first non-missing observation in the list of arguments. A missing observation is one for which istypenan returns true.\n\nAll TSeries in the argument list must be of the same frequency. The data type of the resulting TSeries is computed by the standard promotion of numerical types in Julia. Its range is the union of the ranges of the arguments.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.period","page":"TimeSeriesEcon","title":"TimeSeriesEcon.period","text":"year(x::MIT), period(x::MIT)\n\nReturn the year and period of an MIT value x. This only makes sense if the frequency of x is subtyped from YPFrequency.\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.qq","page":"TimeSeriesEcon","title":"TimeSeriesEcon.qq","text":"mm(year, period), qq(year, period), yy(year, period=1)\n\nIRIS type constructors for MIT values with frequencies that have year and period. \n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.rangeof-Tuple{TSeries}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.rangeof","text":"rangeof(s)\n\nReturn the stored range of the given time series object.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.rangeof-Tuple{Union{MVTSeries, TSeries}}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.rangeof","text":"rangeof(s; drop::Integer)\n\nReturn the stored range of s adjusted by dropping drop periods. If drop is positive, we drop from the beginning and if drop is negative we drop from the end. This adds convenience when using @rec\n\nExample\n\njulia> q = TSeries(20Q1:21Q4); rangeof(q; drop=1)\n20Q2:21Q4\n\njulia> rangeof(q; drop=-4)\n20Q1:20Q4\n\njulia> q[begin:begin+1] .= 1; @rec rangeof(q; drop=2) q[t] = q[t-1] + q[t-2]; q\n8-element TSeries{Quarterly} with range 20Q1:21Q4:\n    20Q1 : 1.0\n    20Q2 : 1.0\n    20Q3 : 2.0\n    20Q4 : 3.0\n    21Q1 : 5.0\n    21Q2 : 8.0\n    21Q3 : 13.0\n    21Q4 : 21.0\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.shift","page":"TimeSeriesEcon","title":"TimeSeriesEcon.shift","text":"shift(x, n)\nshift!(x, n)\nlag(x, n=1)\nlag!(x, n=1)\nlead(x, n=1)\nlead!(x, n=1)\n\nShift, lag or lead the TSeries x by n periods.      By convention shift is the same as lead while lag(x,n) is the same as shift(x, -n). The versions ending in ! do it in place, while the others create a new TSeries instance.\n\nExamples\n\njulia> shift(TSeries(2020Q1, 1:4), 1)\nTSeries{Quarterly} of length 4\n2019Q4: 1.0\n2020Q1: 2.0\n2020Q2: 3.0\n2020Q3: 4.0\n\n\njulia> shift(TSeries(2020Q1, 1:4), -1)\nTSeries{Quarterly} of length 4\n2020Q2: 1.0\n2020Q3: 2.0\n2020Q4: 3.0\n2021Q1: 4.0\n\njulia> x = TSeries(2020Q1, 1:4);\n\njulia> shift!(x, 1);\n\njulia> x\nTSeries{Quarterly} of length 4\n2019Q4: 1.0\n2020Q1: 2.0\n2020Q2: 3.0\n2020Q3: 4.0\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.shift!","page":"TimeSeriesEcon","title":"TimeSeriesEcon.shift!","text":"shift(x, n)\nshift!(x, n)\nlag(x, n=1)\nlag!(x, n=1)\nlead(x, n=1)\nlead!(x, n=1)\n\nShift, lag or lead the TSeries x by n periods.      By convention shift is the same as lead while lag(x,n) is the same as shift(x, -n). The versions ending in ! do it in place, while the others create a new TSeries instance.\n\nExamples\n\njulia> shift(TSeries(2020Q1, 1:4), 1)\nTSeries{Quarterly} of length 4\n2019Q4: 1.0\n2020Q1: 2.0\n2020Q2: 3.0\n2020Q3: 4.0\n\n\njulia> shift(TSeries(2020Q1, 1:4), -1)\nTSeries{Quarterly} of length 4\n2020Q2: 1.0\n2020Q3: 2.0\n2020Q4: 3.0\n2021Q1: 4.0\n\njulia> x = TSeries(2020Q1, 1:4);\n\njulia> shift!(x, 1);\n\njulia> x\nTSeries{Quarterly} of length 4\n2019Q4: 1.0\n2020Q1: 2.0\n2020Q2: 3.0\n2020Q3: 4.0\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.strip!-Tuple{Workspace}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.strip!","text":"strip!(w::Workspace; recursive=true)\n\nApply strip! to all TSeries members of the given workspace. This includes nested workspaces, unless recursive=false.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.typenan","page":"TimeSeriesEcon","title":"TimeSeriesEcon.typenan","text":"typenan(x), typenan(T)\n\nReturn a value that indicates Not-A-Number of the same type as the given x or of the given type T.\n\nFor floating point types, this is the IEEE-defined NaN. For integer types, we use typemax(). This is not ideal, but it'll do for now.\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.undiff","page":"TimeSeriesEcon","title":"TimeSeriesEcon.undiff","text":"undiff(dvar, [date => value])\nundiff!(var, dvar; fromdate=firstdate(dvar)-1)\n\nInverse of diff, i.e. var remains unchanged under undiff!(var, diff(var)) or undiff(diff(var), firstdate(var)=>first(var)). This is the same as cumsum, but specific to time series.\n\nIn the case of undiff the second argument is an \"anchor\" Pair specifying a known value at some time period. Typically this will be the period just before the first date of dvar, but doesn't have to be. If the date falls outside the rangeof(dvar) we extend dvar with zeros as necessary. If missing, this argument defaults to firstdate(dvar)-1 => 0.\n\nIn the case of undiff!, the var argument provides the \"anchor\" value and the storage location for the result. The fromdate parameter specifies the date of the \"anchor\" and the anchor value is taken from var. See important note below.\n\nThe in-place version (undiff!) works only with TSeries. The other version (undiff) works with MVTSeries as well as TSeries. In the case of MVTSeries the anchor value must be a Vector, or a Martix with 1 row, of the same length as the number of columns of dvar.\n\nnote: Note\nIn the case of undiff! the meaning of parameter fromdate is different from the meaning of date in the second argument of undiff. This only matters if fromdate falls somewhere in the middle of the range of dvar.In the case of undiff!, all values of dvar at, and prior to, fromdate are ignored (considered zero). Effectively, values of var up to, and including, fromdate remain unchanged. By contrast, in undiff with date => value somewhere in the middle of the range of dvar, the operation is applied over the full range of dvar, both before and after date, and then the result is adjusted by adding or subtracting a constant such that in the end we have result[date]=value.\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.undiff!","page":"TimeSeriesEcon","title":"TimeSeriesEcon.undiff!","text":"undiff(dvar, [date => value])\nundiff!(var, dvar; fromdate=firstdate(dvar)-1)\n\nInverse of diff, i.e. var remains unchanged under undiff!(var, diff(var)) or undiff(diff(var), firstdate(var)=>first(var)). This is the same as cumsum, but specific to time series.\n\nIn the case of undiff the second argument is an \"anchor\" Pair specifying a known value at some time period. Typically this will be the period just before the first date of dvar, but doesn't have to be. If the date falls outside the rangeof(dvar) we extend dvar with zeros as necessary. If missing, this argument defaults to firstdate(dvar)-1 => 0.\n\nIn the case of undiff!, the var argument provides the \"anchor\" value and the storage location for the result. The fromdate parameter specifies the date of the \"anchor\" and the anchor value is taken from var. See important note below.\n\nThe in-place version (undiff!) works only with TSeries. The other version (undiff) works with MVTSeries as well as TSeries. In the case of MVTSeries the anchor value must be a Vector, or a Martix with 1 row, of the same length as the number of columns of dvar.\n\nnote: Note\nIn the case of undiff! the meaning of parameter fromdate is different from the meaning of date in the second argument of undiff. This only matters if fromdate falls somewhere in the middle of the range of dvar.In the case of undiff!, all values of dvar at, and prior to, fromdate are ignored (considered zero). Effectively, values of var up to, and including, fromdate remain unchanged. By contrast, in undiff with date => value somewhere in the middle of the range of dvar, the operation is applied over the full range of dvar, both before and after date, and then the result is adjusted by adding or subtracting a constant such that in the end we have result[date]=value.\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.year","page":"TimeSeriesEcon","title":"TimeSeriesEcon.year","text":"year(x::MIT), period(x::MIT)\n\nReturn the year and period of an MIT value x. This only makes sense if the frequency of x is subtyped from YPFrequency.\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.ytypct-Tuple{Any}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.ytypct","text":"ytypct(x)\n\nYear-to-year percent change in x. \n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.yy","page":"TimeSeriesEcon","title":"TimeSeriesEcon.yy","text":"mm(year, period), qq(year, period), yy(year, period=1)\n\nIRIS type constructors for MIT values with frequencies that have year and period. \n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.@compare","page":"TimeSeriesEcon","title":"TimeSeriesEcon.@compare","text":"@compare x y [options] \ncompare(x, y [; options])\n\nCompare two Workspace recursively and print out the differences. MVTSeries and Dict with keys of type Symbol are treated like Workspace. TSeries and other Vector are compared using isapprox, so feel free to supply rtol or atol.\n\nOptional argument name can be used for the top name. Default is \"_\".\n\nParameter showequal=true causes the report to include objects that are the same. Default behaviour, with showequal=false, is to report only the differences. \n\nParameter ignoremissing=true causes objects that appear in one but not the other workspace to be ignored. That is, they are not printed and do not affect the return value true or false. Default is ignoremissing=false meaning they will be printed and return value will be false.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.@rec-Tuple{Any, Any}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.@rec","text":"@rec [index=]range expression\n\nComputes recursive operations on time series. The first argument is the range and the second argument is an expression to be evaluated over that range.\n\nThe expression is meant to be an assignment, but it doesn't have to be. \n\nThe the range can specify an optional indexing variable (as in a for loop). If not given, the variable is assumed to be t.\n\nExamples\n\njulia> s = TSeries(1U)\nEmpty TSeries{Unit} starting 5U\n\njulia> s[1U] = s[2U] = 1; s\n2-element TSeries{Unit} with range 1U:2U:\n      1U : 1.0\n      2U : 1.0\n\njulia> @rec t=3U:10U s[t] = s[t-1] + s[t-2]\n\njulia> s\n10-element TSeries{Unit} with range 1U:10U:\n      1U : 1.0\n      2U : 1.0\n      3U : 2.0\n      4U : 3.0\n      5U : 5.0\n      6U : 8.0\n      7U : 13.0\n      8U : 21.0\n      9U : 34.0\n     10U : 55.0\n\n\n\n\n\n","category":"macro"},{"location":"Tutorials/simple_RBC/main/#Simple-RBC-Model","page":"Simple RBC Model","title":"Simple RBC Model","text":"","category":"section"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"You can follow the tutorial by reading this page and copying and pasting code into your Julia REPL session. In this case, you will need the model file, simple_RBC.jl.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Pages = [\"main.md\"]\nDepth = 3","category":"page"},{"location":"Tutorials/simple_RBC/main/#Part-1:-The-model","page":"Simple RBC Model","title":"Part 1: The model","text":"","category":"section"},{"location":"Tutorials/simple_RBC/main/#The-simple-RBC-model","page":"Simple RBC Model","title":"The simple RBC model","text":"","category":"section"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"In this tutorial, we will use the simple RBC model presented by Villemot (2013).","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"A representative agent maximizes the expected discounted sum of his utility by choosing consumption C_t and labour L_t for t=1infty.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"displaystylesum_n=1^inftybeta^t-1E_tleftlog(C_t)-fracL_t^1+gamma1+gammaright","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The household provides labour and rents capital to firms.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"beta=frac11+rho is the discount rate and rho in (0infty) is the rate of time preference;\ngamma in (0infty) is a labour supply parameter.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The household faces the following sequence of budget constraints:","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"displaystyle K_t=K_t-1(1-delta)+w_tL_t+r_tK_t-1-C_t","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Where:","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"K_t is the capital at the end of the period;\ndelta in (01) is the rate of depreciation of capital;\nw_t is the real wage;\nr_t is the real rental rate.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The production function is written as:","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"displaystyle Y_t=A_tK_t-1^alpha((1+g)^tL_t)^1-alpha","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Where:","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"g in (0infty) is the growth rate;\nalpha is the output elasticity of labour.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"A_t is a technological shock that follows an AR(1) process.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"displaystyle log(A_t)=lambdalog(A_t-1)+e_t","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Where:","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"e_t is an i.i.d. zero-mean normally distributed error term with a standard deviation of gamma;\nlambda in (01) is a parameter governing the persistence of the shock.","category":"page"},{"location":"Tutorials/simple_RBC/main/#The-household-problem","page":"Simple RBC Model","title":"The household problem","text":"","category":"section"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The constrained maximization problem can be written as a Lagrangian:","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"displaystyle mathcalL(C_tL_tK_t) = sum_t=1^inftybeta^t-1E_tleftlog(C_t)-fracL_t^1+gamma1+gamma-mu_t(K_t-K_t-1(1-delta)-w_tL_t-r_tK_t-1+C_t)right","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The first order conditions are:","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"beginaligned\n    fracpartialmathcalLpartial C_t = left(frac11+rhoright)^t-1 left(frac1C_t - mu_t right) = 0 \n    fracpartialmathcalLpartial L_t = left(frac11+rhoright)^t-1 left(L_t^gamma - mu_t w_t right) = 0 \n    fracpartialmathcalLpartial K_t = -left(frac11+rho right)^t-1 mu_t + left(frac11+rho right)^t E_t\n        left(mu_t+1(1-delta+r_t) right) = 0\nendaligned","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Once we eliminate the Lagrange multiplier mu_t, we get:","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"beginaligned\n    L_t^gamma = fracw_tC_t \n    frac1C_t = frac11+rho E_t left(frac1C_t+1(r_t+1+1-delta) right)\nendaligned","category":"page"},{"location":"Tutorials/simple_RBC/main/#The-firm-problem","page":"Simple RBC Model","title":"The firm problem","text":"","category":"section"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The firm chooses labour and capital in order to maximize profits:","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"displaystyle max_L_tK_t-1 A_t K_t-1^alpha ((1+g)^t L_t)^1-alpha - r_t K_t-1 - w_t L_t","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The first order conditions are:","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"beginaligned\n    r_t = alpha A_t K_t-1^alpha-1((1+g)^t L_t)^1-alpha \n    w_t = (1-alpha)A_t K_t-1^alpha ((1+g)^t)^1-alpha L_t^-alpha\nendaligned","category":"page"},{"location":"Tutorials/simple_RBC/main/#The-goods-market-equilibrium","page":"Simple RBC Model","title":"The goods market equilibrium","text":"","category":"section"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Aggregate demand must equal aggregate supply to clear the goods market.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"displaystyle K_t + C_t = K_t-1(1-delta)+A_t K_t-1^alpha ((1+g)^t L_t)^1-alpha","category":"page"},{"location":"Tutorials/simple_RBC/main/#The-dynamic-equilibrium","page":"Simple RBC Model","title":"The dynamic equilibrium","text":"","category":"section"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The dynamic equations are obtained by combining the first order conditions of the household and firm problems  with the goods market equilibrium.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Based on the goods market equilibrium, consumption and capital must be growing at the same rate: g_c=g_k=g.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Thus, we can define stationary variables as:","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"beginaligned\n    hatC_t = fracC_t(1+g)^t \n    hatK_t = fracK_t(1+g)^t \n    hatw_t = fracw_t(1+g)^t\nendaligned","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Once stationarized (see Villemot (2013)), the dynamic equations can be written as:","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"beginaligned\n    frac1hatC_t = frac11+rho E_t left(frac1hatC_t+1(1+g)(r_t+1+1-delta) right) \n    L_t^gamma = frachatw_thatC_t \n    r_t = alpha A_t left( frachatK_t-11+g right)^alpha-1 L_t^1-alpha \n    hatw_t = (1-alpha) A_t left( frachatK_t-11+g right)^alpha L_t^-alpha \n    hatK_t + hatC_t = frachatK_t-11+g (1-delta) + A_t left( frachatK_t-11+g right)^alpha L_t^1-alpha\nendaligned","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The next part will discuss how to implement the simple RBC model in StateSpaceEcon.","category":"page"},{"location":"Tutorials/simple_RBC/main/#Part-2:-Implementation-of-the-model-in-StateSpaceEcon","page":"Simple RBC Model","title":"Part 2: Implementation of the model in StateSpaceEcon","text":"","category":"section"},{"location":"Tutorials/simple_RBC/main/#Installing-the-packages","page":"Simple RBC Model","title":"Installing the packages","text":"","category":"section"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We start by installing the packages needed for this tutorial.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"using StateSpaceEcon, ModelBaseEcon, TimeSeriesEcon, Test, Plots, Random, Distributions\n# Fix the random seed for reproducibility.\nRandom.seed!(1234);\n","category":"page"},{"location":"Tutorials/simple_RBC/main/#Writing-the-model-file","page":"Simple RBC Model","title":"Writing the model file","text":"","category":"section"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"In StateSpaceEcon, a model is written in its own dedicated module, which is contained in its own file, simple_RBC.jl.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"A docstring can be added to the model to provide more details:","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"    \"\"\"\n    Simple RBC Model\n    Model available at: https://archives.dynare.org/DynareShanghai2013/order1.pdf\n    Presentation: Villemot, S., 2013. First order approximation of stochastic models. Shanghai Dynare Workshop.\n    \"\"\"","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Then, the module is created with the same name as the model and the associated file name. The model will be constructed with macros taken from the package ModelBaseEcon. So, we need to load the module ModelBaseEcon within the module simple_RBC with using ModelBaseEcon. The model will itself be a global variable called model within the module simple_RBC. The command const declares global variables that will not change and the function Model() constructs a new model object.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"module simple_RBC\n    using ModelBaseEcon\n    const model = Model()\n    # Write the rest of the model below.\nend # module","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The model object can hold three sets of parameters: flags, options and model parameters. Flags and options can be adjusted from the model file itself after the constant declaration. Typically, this is done in the model file before calling @initialize.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Flags are (usually boolean) values which characterize the type of model we have. For example, we can specify that the model is stationary by setting the flag ssZeroSlope to true.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"model.flags.ssZeroSlope = true","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Options are values that adjust the operations of the algorithms. We can preset model options with the function setoption!. Below, we set the desired accuracy with tol and we set maxiter for the maximum number of iterations for the iterative solvers. Auxiliary variables will not be created and substituted to help the solver (substitutions). We will opt for QR factorization, which is slower but more robust than LU factorization. Finally, we will set verbose to true to provide more information from the commands.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"setoption!(model) do o\n    o.tol = 1e-14\n    o.maxiter = 100\n    o.substitutions = false\n    o.factorization = :qr\n    o.verbose = true\nend # options","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Many functions in StateSpaceEcon have optional arguments of the same name as a model option. When the argument is not explicitly given in the function call, these functions will use the value from the model option of the same name. \n The rest of the model is specified with macros which do not have to be in any particular order. \n\nIn addition to falgs and options, the model object also holds model parameters, which are values that appear in the model equations. The macro @parameters assigns parameter values to the model. A link between parameters can be created with the macro @link. Below, the parameter beta depends on the parameter rho.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"@parameters model begin\n    α = 0.33\n    δ = 0.1\n    ρ = 0.03\n    λ = 0.97\n    γ = 0\n    g = 0.015\n    β = @link 1/(1+ρ)\nend # parameters","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Similarly, model variables are specified with the macro @variables. Variables can be declared one line at a time (as with the parameters previously), or over one line by separating them with semicolons ;. Alternatively, we use the macro @logvariables to indicate to the solver the work with the log of the variables. For instance, instead of working with C_t, the solver will work directly with the logarithm as a standalone variable (logC_t=e^log(C_t)). This can help the solver to avoid computing the logarithm of a negative value.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"@logvariables model begin\n    C; K; L; w; r; A;\nend # variables","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The macro @shocks declares model shocks.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"@shocks model begin\n    ea\nend # shocks","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"In this case, a begin block is not necessary and the technology shock can be declared in one line.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"@shocks model ea","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The macro @autoexogenize links a variable with a shock. This can be useful to back out historical shocks with the command autoexogenize! (see below for an example).","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"@autoexogenize model begin\n    A = ea\nend # autoexogenize","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The dynamic equations of the model are embedded within the macro @equations. The variables have to be indexed with t. For instance, K[t-1] refers to the capital stock on t-1 and C[t+1] refers to the expectation on t for consumption on t+1, or E_t(C_t+1). When variables can be separated by a logarithm, it will help the solver to put the macro @log in from of an equation. In this way, the residual will be computed as the difference between the logarithm on the left-hand side and the logarithm on the right-hand side. For instance, the solver will prefer to work with the second equation below, which is linear.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"beginaligned\n    frac1hatC_t = frac11+rho E_t left(frac1hatC_t+1(1+g)(r_t+1+1-delta) right) \n    loghatC_t = log(1+rho) + E_t left(loghatC_t+1log(1+g)-log(r_t+1+1-delta) right)\nendaligned","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"@equations model begin\n    @log 1/(C[t]) = β * (1 / (C[t+1]*(1+g))) * (r[t+1]+1-δ)\n    @log (L[t])^γ = w[t] / C[t]\n    @log r[t] = α * A[t] * (K[t-1]/(1+g)) ^ (α-1) * (L[t]) ^ (1-α)\n    @log w[t] = (1-α) * A[t] * (K[t-1]/(1+g)) ^ α * (L[t]) ^ (-α)\n    K[t] + C[t] = A[t] * (K[t-1]/(1+g)) ^ α * (L[t]) ^ (1-α) + (1-δ) * (K[t-1]/(1+g))\n    log(A[t]) = λ * log(A[t-1]) + ea[t]\nend # equations","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Once the parameters, the variables, the shocks and the equations have been specified, the macro @initialize constructs the model within the module simple_RBC.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"@initialize(model)","category":"page"},{"location":"Tutorials/simple_RBC/main/#Loading-the-model","page":"Simple RBC Model","title":"Loading the model","text":"","category":"section"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We load the module that contains the model with using simple_RBC; the model itself is a global variable called model within that module, which we assign to m in the Main module.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"note: Important note\nFor the using simple_RBC command to work, we need the model file simple_RBC.jl to be on the search path for modules. We can do this by:Pushing the file path to LOAD_PATH global variable (which we do below for simplicity);\nAdding the model as a standalone package and installing it as: using Pkg; Pkg.add(\"/[path to the package]/simple_RBC\")","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"unique!(push!(LOAD_PATH, realpath(\".\")));\nusing simple_RBC\nm = simple_RBC.model","category":"page"},{"location":"Tutorials/simple_RBC/main/#Examining-the-model","page":"Simple RBC Model","title":"Examining the model","text":"","category":"section"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We can see the entire model with fullprint.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"fullprint(m)","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We can see the flags and the options of the model.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"m.flags\nm.options","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We can also examine individual components using the commands parameters, variables, shocks and equations.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"parameters(m)\nvariables(m)\nshocks(m)\nequations(m)","category":"page"},{"location":"Tutorials/simple_RBC/main/#Setting-the-model-parameters","page":"Simple RBC Model","title":"Setting the model parameters","text":"","category":"section"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We must not change any part of the model in the active Julia session except for the model parameters and steady state constraints if any (see the Smets and Wouters (2007) tutorial). If we want to add variables, shocks, or equations, we must do so in the model module file and restart a new Julia session to load the new model.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"When it comes to the model parameters, we can access them by their names from the model object using the dot notation.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"m.β # read a parameter value\nm.α = 0.33 # modify a parameter value","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Parameters can be linked to other parameters with the macro @link:","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"parameters(m)[:β]","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"If rho changes, beta will automatically be updated.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"m.ρ = 0.05\nm.β\nm.ρ = 0.03\nm.β","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"However, the dynamic links only work with parameter values. Otherwise, the function update_links! needs to be called to refresh all the links.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"update_links!(m)","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"note: Important note\nLinks will not be automatically updated if:Links contain a reference outside the model parameters, such as the steady state or a model in a parent module\nA parameter is not a number, such as if an element of a parameter vector is updated.","category":"page"},{"location":"Tutorials/simple_RBC/main/#Part-3:-The-steady-state-solution","page":"Simple RBC Model","title":"Part 3: The steady state solution","text":"","category":"section"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The steady state is a special solution of the dynamic system that remains constant over time. It is important on its own, but also it can be useful in several ways. For example, linearizing the model requires a particular solution about which to linearize, and the steady state is typically used for this purpose.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"In addition to the steady state, we also consider another kind of special solution which grows linearly in time. If we know that the steady state solution is constant (i.e., its slope is zero), we can set the model flag ssZeroSlope to true. This is not required; however in a large model it might help the steady state solver converge faster to the solution.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The model object m stores information about the steady state. This includes the steady state solution itself, as well as a (possibly empty) set of additional constraints that apply only to the steady state. This information can be accessed via m.sstate.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"m.sstate","category":"page"},{"location":"Tutorials/simple_RBC/main/#Solving-for-the-steady-state","page":"Simple RBC Model","title":"Solving for the steady state","text":"","category":"section"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The steady state solution is stored within the model object. Before solving, we have to specify an initial condition. If the model is linear, this makes no difference, but in a non-linear model a good or a bad initial guess might be the difference between success and failure of the steady state solver.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We specify the initial guess by calling clear_sstate!. This call removes any previously stored solution, sets the initial guess, and runs the pre-solve pass of the steady state solver. The initial guess can be given with the lvl and slp arguments; if not provided, an initial guess is chosen automatically.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Once that's done, we call sssolve! to find the steady state. We can see below that sssolve! cannot find a steady state solution.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"clear_sstate!(m)\nsssolve!(m);","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The Newton-Raphson solution algorithm used by default has failed to converge. Instead, the :auto method starts with the Levenberg-Marquardt algorithm and automatically switches to Newton-Raphson when it starts to converge.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"clear_sstate!(m)\nsssolve!(m; method = :auto)","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The function sssolve! returns a Vector{Float64} containing the steady state solution, and it also writes that solution into the model object. The vector is of length 2*nvariables(m) and contains the level and the slope for each variable.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"If in doubt, we can use check_sstate to make sure the steady state solution stored in the model object indeed satisfies the steady state system of equations. This function returns the number of equations that are not satisfied. A value of 0 is what we want to see. In verbose mode, it also lists the problematic equations and their residuals.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"check_sstate(m)","category":"page"},{"location":"Tutorials/simple_RBC/main/#Examining-the-steady-state","page":"Simple RBC Model","title":"Examining the steady state","text":"","category":"section"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We can access the steady state solution via m.sstate using the dot notation.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"m.sstate.C","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We can also assign new values to the steady state solution, but we should be careful to make sure it remains a valid steady state solution.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"m.sstate.C.level = 1.0050\n@test check_sstate(m) > 0","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"As the code above shows, a wrong steady state solution (based on the specified precision in the tol option) will result in one or more equation not being satisfied. Let's put back the correct value.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"m.sstate.C.level = 1.0030433070390223\n@test check_sstate(m) == 0","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We can examine the entire steady state solution with printsstate.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"printsstate(m)","category":"page"},{"location":"Tutorials/simple_RBC/main/#Part-4:-Impulse-response","page":"Simple RBC Model","title":"Part 4: Impulse response","text":"","category":"section"},{"location":"Tutorials/simple_RBC/main/#Simulation-plan","page":"Simple RBC Model","title":"Simulation plan","text":"","category":"section"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Before we can simulate the model, we have to decide on the length of the simulation and what data is available for each period, i.e., what values are known (exogenous). This is done with an object of type Plan.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"To create a plan, all we need is the model object and a range for the simulation.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"sim_rng = 2000Q1:2039Q4\np = Plan(m, sim_rng)","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The plan shows us the list of exogenous values (variables or shocks) for each period or sub-range of the simulation. By default, all shocks are exogenous and all variables are endogenous.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We also see that the range of the plan has been extended before and after the simulation range. This is necessary because we need to set initial and final conditions. The number of periods for initial conditions is equal to the largest lag in the model. Similarly, final conditions have to be imposed over as many periods as the largest lead.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"p.range          # the full range of the plan\ninit_rng = first(p.range):first(sim_rng)-1   # the range for initial conditions\nfinal_rng = last(sim_rng)+1:last(p.range)     # the range for final conditions\n@test length(init_rng) == m.maxlag\n@test length(final_rng) == m.maxlead","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The function exportplan can be used to save a plan to a TXT or CSV file which can be opened to visualize the plan. Alternatively, the function importplan can load the plan back into Julia from the TXT or CSV file.","category":"page"},{"location":"Tutorials/simple_RBC/main/#Exogenous-data","page":"Simple RBC Model","title":"Exogenous data","text":"","category":"section"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We have to provide the data for the simulation. We start with all zeros and fill in the external data, which must include initial conditions for all variable and shocks, exogenous values (according to the plan), and possibly final conditions.","category":"page"},{"location":"Tutorials/simple_RBC/main/#Initial-conditions","page":"Simple RBC Model","title":"Initial conditions","text":"","category":"section"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"In this example, we want to simulate an impulse response, so it makes sense to start from the steady state.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"exog = steadystatedata(m, p)","category":"page"},{"location":"Tutorials/simple_RBC/main/#Final-conditions","page":"Simple RBC Model","title":"Final conditions","text":"","category":"section"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"For the final conditions, we can use the steady state again, because we expect that the economy will eventually return to it if the simulation is sufficiently long past the last shock. We can do this by assigning the values of the steady state to the final periods after the simulation, similarly to what we did with the initial conditions.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Alternatively, we can specify that we want to use the steady state in the call to simulate by passing fctype=fclevel. Yet another possibility is to set the final condition so that the solution slope matches the slope of the steady state by setting fctype=fcslope. In both cases, we do not need to set anything in the exogenous data array because those values would be ignored.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"tip: Pro tip\nIn the simple RBC model, the two ways of using the steady state for final conditions (level or slope) are equivalent, because the steady state here is stationary and unique. In models where the steady state has non-zero slope, or the steady state has zero slope but the level is not unique, we should use fctype=fcslope.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"If the steady state is not solved or if we prefer not to depend on it, we can use fctype=fcnatural. The final conditions will be constructed assuming that the last simulation period reflects the first difference of the steady state. For a stationary model, the simulation needs to be long enough so that variables do not change anymore. In a model where the steady state has non-zero slope, non-stationary variables have to grow at a stable pace by the end of the simulation.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We can set the default option for the simple RBC model outside the model dedicated module.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"m.options.fctype = fcnatural","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Otherwise, this option can be set within the model model but the StateSpaceEcon package must be installed within the module. For instance:","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"module simple_RBC\n    using ModelBaseEcon\n    using StateSpaceEcon\n    const model = Model()\n    model.flags.ssZeroSlope = true\n    setoption!(model) do o\n        o.tol = 1e-14\n        o.maxiter = 100\n        o.substitutions = false\n        o.factorization = :qr\n        o.verbose = true\n        o.fctype = fcnatural\n    end # options\n    # Rest of the model...\nend","category":"page"},{"location":"Tutorials/simple_RBC/main/#A-quick-sanity-check","page":"Simple RBC Model","title":"A quick sanity check","text":"","category":"section"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"If we were to run a simulation where the economy started in the steady state and there were no shocks at all, we'd expect that the economy would remain in steady state forever.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"ss = simulate(m, p, exog);\n@test ss ≈ steadystatedata(m, p)","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The simulated data, ss, should equal (up to the accuracy of the solution) the steady state data. Similar to steadystatedata, we can use zerodata to create a data set containing with zeros to work in the deviation from the steady state solution.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"zz = simulate(m, p, zerodata(m, p); deviation = true);\n@test zz ≈ zerodata(m, p)","category":"page"},{"location":"Tutorials/simple_RBC/main/#Exogenous-data-2","page":"Simple RBC Model","title":"Exogenous data","text":"","category":"section"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"All shocks are exogenous by default. All we have left to do is to set the value of the shock.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Let's say that we want to shock ea for the first four quarters by 0.1.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"exog[sim_rng[1:4], :ea] .= 0.1;\nexog[shocks(m)]","category":"page"},{"location":"Tutorials/simple_RBC/main/#Running-the-simulation","page":"Simple RBC Model","title":"Running the simulation","text":"","category":"section"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We call simulate, providing the model, the exogenous data, and the plan. We also specify the type of final condition we want to impose if we want to diverge from the option setting saved in the model.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"irf = simulate(m, p, exog; fctype=fcslope)","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We can now take a look at how some of the variables in the model have responded to this shock. We use plot from the Plots package. We specify the variables we want to plot using vars and the names of the datasets being plotted (for the legend) in the labels option.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"gr(display_type=:inline) # hide\nmodel_vars = [var.name for var in m.variables]; # model variables are taken from the model\nplot(ss, irf,\n     vars=model_vars,\n     legend= :none,\n     size=(600, 400),\n     xrotation = 45, margin = 6Plots.mm,\n    );","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"savefig(\"irf.png\")","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"(Image: Impulse Response Graph)","category":"page"},{"location":"Tutorials/simple_RBC/main/#Part-5:-Stochastic-shocks-simulation","page":"Simple RBC Model","title":"Part 5: Stochastic shocks simulation","text":"","category":"section"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Now let's run a simulation with stochastic shocks. We will have random shocks over two years and then have no shocks for several years afterwards to allow time for the economy to return to its steady state.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"sim_rng = 2000Q1:2049Q4      # simulate 50 years starting 2000\nshk_rng = 2004Q1 .+ (0:7)    # shock 8 quarters starting in 2004\np = Plan(m, sim_rng)\nexog = steadystatedata(m, p);","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The distribution of the shock is assumed normal with mean zero. We use packages Distributions and Random to draw the necessary random values.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"shk_dist = (ea = Normal(0.0, 0.10),);\nfor (shk, dist) in pairs(shk_dist)\n    exog[shk_rng, shk] .= rand(dist, length(shk_rng))\nend\nexog[shk_rng, shocks(m)]","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Now we are ready to simulate. We can set the shocks to be anticipated or unanticipated by setting the anticipate parameter in simulate.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"sim_a = simulate(m, p, exog; fctype=fcnatural, anticipate=true);\nsim_u = simulate(m, p, exog; fctype=fcnatural, anticipate=false);","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"As before, we can review the responses of variables to the shock using plot.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"observed = collect(keys(m.autoexogenize)); # the observed variable is from the autoexogenize list\nss = steadystatedata(m, p);\ngr(display_type=:inline) # hide\nplot(ss, sim_a, sim_u,\n     vars=model_vars,\n     labels=(\"SS\", \"Anticipated\", \"Unanticipated\"),\n     legend=[true (false for i = 2:length(model_vars))...],\n     linewidth=1.5,   # hide\n     size=(900, 600),  # hide\n     xrotation = 90, margin = 6Plots.mm,\n    );","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"savefig(\"stoch_shk.png\")","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"(Image: Stochastic Shock Response Graph)","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We see that when the shock is anticipated, the variables start to react to them right away; in the unanticipated case, there is no movement until the technology shock actually hit.","category":"page"},{"location":"Tutorials/simple_RBC/main/#Part-5:-Backing-out-historical-shocks","page":"Simple RBC Model","title":"Part 5: Backing out historical shocks","text":"","category":"section"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Now let's pretend that the simulated values for A are historical data and that we do not know the magnitude of the shock ea. We can treat the observed (simulated) values of the variable A as known by making them exogenous. At the same time we will make the shock endogenous, so that we can solve for their values during the simulation.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We use exogenize! and endogenize! to set up a plan in which the observed variable is exogenous and the shock is endogenous throughout the stochastic range.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"endogenize!(p, shocks(m), shk_rng);\nexogenize!(p, observed, shk_rng);\np","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Another possibility is to use the autoexogenize command, which will use the default pairing provided in the model under @autoexogenize.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"autoexogenize!(p, m, shk_rng)","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"As we can see above, the plan now reflects our intentions.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Finally, we need to set up the exogenous data. This time we do not specify the shocks; instead, we assign the known data for the observed variables for the historic range. We start with initial conditions.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"exog = steadystatedata(m, p);","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We take the observed data from the simulation above. We show the anticipated version first.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"for v in observed\n    exog[shk_rng, v] .= sim_a[v]\nend\nback_a = simulate(m, p, exog; fctype=fcnatural, anticipate=true);","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Now we show the unanticipated case.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"for v in observed\n    exog[shk_rng, v] .= sim_u[v]\nend\nback_u = simulate(m, p, exog; fctype=fcnatural, anticipate=false);","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"If we did everything correctly, the shocks we recovered must match the shocks we used when we simulated the data.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"@test sim_a[:ea] ≈ back_a[:ea]\n@test sim_u[:ea] ≈ back_u[:ea]","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Moreover, we must have the unobserved variables match as well. In fact, all the data must match over the entire simulation range.","category":"page"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"@test sim_a ≈ back_a\n@test sim_u ≈ back_u","category":"page"},{"location":"Tutorials/simple_RBC/main/#Appendix","page":"Simple RBC Model","title":"Appendix","text":"","category":"section"},{"location":"Tutorials/simple_RBC/main/#References","page":"Simple RBC Model","title":"References","text":"","category":"section"},{"location":"Tutorials/simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Villemot, S., 2013. First order approximation of stochastic models.","category":"page"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon-Reference","page":"ModelBaseEcon","title":"ModelBaseEcon Reference","text":"","category":"section"},{"location":"Reference/ModelBaseEcon/","page":"ModelBaseEcon","title":"ModelBaseEcon","text":"Pages = [\"modelbaseecon.md\"]","category":"page"},{"location":"Reference/ModelBaseEcon/#Options","page":"ModelBaseEcon","title":"Options","text":"","category":"section"},{"location":"Reference/ModelBaseEcon/","page":"ModelBaseEcon","title":"ModelBaseEcon","text":"Modules = [ModelBaseEcon.OptionsMod]\nPrivate = false","category":"page"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.OptionsMod","page":"ModelBaseEcon","title":"ModelBaseEcon.OptionsMod","text":"OptionsMod\n\nSub-module of ModelBaseEcon, although it can be used independently. Implements the Options data structure.\n\nContents\n\nOptions\ngetoption - read the value of an option\ngetoption! - if not present, also create an option\nsetoption! - create or update the value of an option \n\n\n\n\n\n","category":"module"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.OptionsMod.Options","page":"ModelBaseEcon","title":"ModelBaseEcon.OptionsMod.Options","text":"Options\n\nA collection of key-value pairs representing the options controlling the behaviour or the definition of a Model object. The key is the option name and is always a Symbol, or converted to Symbol, while the value can be anything.\n\nThe options can be accessed using dot notation. Functions getoption and setoption! are also provided. They can be used for programmatic processing of options as well as when the option name is not a valid Julia identifier.\n\nSee also: Options, getoption, getoption!, setoption!\n\nExamples\n\njulia> o = Options(maxiter=20, tol=1e-7)\nOptions:\n    maxiter=20\n    tol=1.0e-7\n\njulia> o.maxiter = 25\n25\n\njulia> o\nOptions:\n    maxiter=25\n    tol=1.0e-7\n\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.OptionsMod.Options-Tuple{Options}","page":"ModelBaseEcon","title":"ModelBaseEcon.OptionsMod.Options","text":"Options(::Options)\n\nConstruct an Options instance as an exact copy of an existing instance.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.OptionsMod.Options-Tuple{}","page":"ModelBaseEcon","title":"ModelBaseEcon.OptionsMod.Options","text":"Options(key=value, ...)\nOptions(:key=>value, ...)\n\nConstruct an Options instance with key-value pairs given as keyword arguments or as a list of pairs. If the latter is used, each key must be a Symbol.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.OptionsMod.getoption","page":"ModelBaseEcon","title":"ModelBaseEcon.OptionsMod.getoption","text":"getoption(o::Options; name=default [, name=default, ...])\ngetoption(o::Options, name, default)\n\nRetrieve the value of an option or a set of options.  The provided defaults are used when the option doesn't exit.\n\nThe return value is the value of the option requested or, if the option doesn't exist, the default. In the first version of the function, if there are more than one options requested, the return value is a tuple.\n\nIn the second version, the name could be a symbol or a string, which can be helpful if the name of the option is not a valid identifier.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.OptionsMod.getoption!","page":"ModelBaseEcon","title":"ModelBaseEcon.OptionsMod.getoption!","text":"getoption!(o::Options; name=default [, name=default, ...])\ngetoption!(o::Options, name, default)\n\nRetrieve the value of an option or a set of options. If the name does not match an existing option, the Options instance is updated by inserting the given name and default value.\n\nThe return value is the value of the option requested (or the default). In the first version of the function, if there are more than one options requested, the return value is a tuple.\n\nIn the second version, the name could be a symbol or a string, which can be helpful if the name of the option is not a valid identifier.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.OptionsMod.setoption!","page":"ModelBaseEcon","title":"ModelBaseEcon.OptionsMod.setoption!","text":"setoption!(o::Options; name=default [, name=default, ...])\nsetoption!(o::Options, name, default)\n\nRetrieve the value of an option or a set of options. If the name does not match an existing option, the Options instance is updated by inserting the given name and default value.\n\nThe return value is the value of the option requested (or the default). In the first version of the function, if there are more than one options requested, the return value is a tuple.\n\nIn the second version, the name could be a symbol or a string, which can be helpful if the name of the option is not a valid identifier.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#Timer","page":"ModelBaseEcon","title":"Timer","text":"","category":"section"},{"location":"Reference/ModelBaseEcon/","page":"ModelBaseEcon","title":"ModelBaseEcon","text":"Modules = [ModelBaseEcon.Timer]\nPrivate = false","category":"page"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Timer","page":"ModelBaseEcon","title":"ModelBaseEcon.Timer","text":"Timer\n\nA sub-module of ModelBaseEcon, although it can be used independently. Provides functionality for measuring the aggregate time spent in individual lines or blocks of code.\n\ntip: Tip\nThe implementation here is quick-and-dirty and is intended for getting a rough idea of where the bottlenecks are. It is best used for timing blocks of code that are passed through relatively few times and each pass takes a relatively long time. In the opposite extreme case (fast code that is called many times), the current implementation of @timer might add extreme overhead.\n\nContents\n\ninittimer       - Enable collection of timer data.\nstoptimer       - Disable collection of timer data.\nprinttimer      - Display timer data.\n@timer          - Measure the runtime taken by the given code.\n\nExample\n\njulia> true\n[...]\n\n\n\n\n\n","category":"module"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Timer.inittimer-Tuple{}","page":"ModelBaseEcon","title":"ModelBaseEcon.Timer.inittimer","text":"inittimer()\n\nEnable the collection of timing data. Existing timing data is lost. By default, collection of timing data is disabled.\n\nSee also: stoptimer, @timer, printtimer\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Timer.printtimer","page":"ModelBaseEcon","title":"ModelBaseEcon.Timer.printtimer","text":"printtimer(io::IO=Base.stdout)\n\nDisplay timing data.\n\nTiming data is displayed in a table with each row containing the number of calls, total time in seconds, and the source line or block tag. Rows are sorted in order of decreasing total time.\n\nSee also: @timer\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Timer.stoptimer-Tuple{}","page":"ModelBaseEcon","title":"ModelBaseEcon.Timer.stoptimer","text":"stoptimer()\n\nDisable the collection of timing data. Existing data is lost. By default, collection of timing data is disabled.\n\nSee also: inittimer, @timer, printtimer\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Timer.@timer-Tuple","page":"ModelBaseEcon","title":"ModelBaseEcon.Timer.@timer","text":"@timer(code)\n@timer(tag::String, code)\n\nMeasure the number of calls and the total time taken by the given code.\n\nIf a tag string is not provided, one is generated from the source file and line. The return value of this macro call is the return value of the code.\n\nwarning: Warning\nImportant limitation is that the code must not contain a return, break, continue, or any other jump out of it. If it does, the program would run correctly, but the timing data collected would be incorrect.\n\nSee also: inittimer, stoptimer, printtimer\n\nExample\n\njulia> inittimer()\n\njulia> @timer Base.sleep(1.0)\n\njulia> printtimer()\n[...]\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon","page":"ModelBaseEcon","title":"ModelBaseEcon","text":"","category":"section"},{"location":"Reference/ModelBaseEcon/","page":"ModelBaseEcon","title":"ModelBaseEcon","text":"Modules = [ModelBaseEcon]\nPrivate = false","category":"page"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.ModelBaseEcon","page":"ModelBaseEcon","title":"ModelBaseEcon.ModelBaseEcon","text":"ModelBaseEcon\n\nThis package is part of the StateSpaceEcon ecosystem.  It contains the basic elements needed for model definition. StateSpaceEcon works with model objects defined with ModelBaseEcon.\n\n\n\n\n\n","category":"module"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Equation","page":"ModelBaseEcon","title":"ModelBaseEcon.Equation","text":"struct Equation <: AbstractEquation\n\nData structure representing a single equation in our state space model.\n\nMethods (for users)\n\nTODO\n\nImplementation (for developers)\n\nDuring the phase of definition of the Model, this type simply stores the expression entered by the user. During @initialize(), the true data structure is constructed. We need this, because the construction of the equation requires information from the Model object, which may not be available at the time the equation expression is first read.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.LinearizationError","page":"ModelBaseEcon","title":"ModelBaseEcon.LinearizationError","text":"LinearizationError <: ModelErrorBase\n\nA concrete error type used when a model cannot be linearized for some reason.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.LogTransform","page":"ModelBaseEcon","title":"ModelBaseEcon.LogTransform","text":"LogTransform <: Transformation\n\nThe log transformation. The inverse is of course exp. This is the default for variables declared with @log.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Model","page":"ModelBaseEcon","title":"ModelBaseEcon.Model","text":"Model <: AbstractModel\n\nData structure that represents a macroeconomic state space model.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.ModelError","page":"ModelBaseEcon","title":"ModelBaseEcon.ModelError","text":"struct ModelError <: ModelErrorBase\n\nConcrete error type used when no specific error description is available.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.ModelErrorBase","page":"ModelBaseEcon","title":"ModelBaseEcon.ModelErrorBase","text":"ModelErrorBase\n\nAbstract error type, base for specific error types used in ModelBaseEcon.\n\nImplementation (note for developers)\n\nWhen implementing a derived error type, override two functions:\n\nmsg(e::SomeModelError) returning a string with the error message;\nhint(e::SomeModelError) returning a string containing a suggestion of how to fix the problem. Optional, if not implemented for a type, the fallback implementation returns an empty string.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.ModelNotInitError","page":"ModelBaseEcon","title":"ModelBaseEcon.ModelNotInitError","text":"struct ModelNotInitError <: ModelErrorBase\n\nSpecific error type used when there's an attempt to use a Model object that has not been initialized.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.ModelParam","page":"ModelBaseEcon","title":"ModelBaseEcon.ModelParam","text":"mutable struct ModelParam\n\nContains a model parameter. For a simple parameter it simply stores its value. For a link or an alias, it stores the link information and also caches the current value for speed.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.NegLogTransform","page":"ModelBaseEcon","title":"ModelBaseEcon.NegLogTransform","text":"NegLogTransform <: Transformation\n\nThe log(-x), with the inverse being -exp(x). Use this when the variable is negative with exponential behaviour (toward -∞).\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.NoTransform","page":"ModelBaseEcon","title":"ModelBaseEcon.NoTransform","text":"NoTransform <: Transformation\n\nThe identity transformation.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.NotImplementedError","page":"ModelBaseEcon","title":"ModelBaseEcon.NotImplementedError","text":"struct NotImplementedError <: ModelErrorBase\n\nSpecific error type used when a feature is planned but not yet implemented. \n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Parameters","page":"ModelBaseEcon","title":"ModelBaseEcon.Parameters","text":"struct Parameters <: AbstractDict{Symbol, Any}\n\nContainer for model parameters. It functions as a Dict where the keys are the parameter names. Simple parameter values are stored directly. Special parameters depend on other parameters are are wrapped in the appropriate data structures to keep track of such dependencies. There are two types of special parameters - aliases and links.\n\nIndividual parameters can be accessed in two different ways - dot and bracket notation.\n\nRead access by dot notation calls peval while bracket notation doesn't. This makes no difference for simple parameters. For special parameters, access by bracket notation returns its internal structure, while access by dot notation returns its current value depending on other parameters.\n\nWrite access is the same in both dot and bracket notation. The new parameter value is assigned directly in the case of simple parameter. To create an alias parameter, use the @alias macro. To create a link parameter use the @link macro.\n\nSee also: ModelParam, peval, @alias, @link, update_links!.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Parameters-2","page":"ModelBaseEcon","title":"ModelBaseEcon.Parameters","text":"Parameters([mod::Module])\n\nWhen creating an instance of Parameters, optionally one can specify the module in which parameter expressions will be evaluated. This only matters if there are any link parameters that depend on custom functions or global variables/constants. In this case, the mod argument should be the module in which these definitions exist.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.SteadyStateData","page":"ModelBaseEcon","title":"ModelBaseEcon.SteadyStateData","text":"SteadyStateData\n\nData structure that holds information about the steady state solution of the Model.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.SteadyStateEquation","page":"ModelBaseEcon","title":"ModelBaseEcon.SteadyStateEquation","text":"struct SteadyStateEquation <: AbstractEquation\n\nData structure representing an individual steady state equation.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Transformation","page":"ModelBaseEcon","title":"ModelBaseEcon.Transformation","text":"abstract type Transformation end\n\nThe base class for all variable transformations.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.add_equation!-Tuple{Model, Expr}","page":"ModelBaseEcon","title":"ModelBaseEcon.add_equation!","text":"add_equation!(model::Model, expr::Expr; modelmodule::Module)\n\nProcess the given expression in the context of the given module, create the Equation() instance for it and add it to the model instance.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.alleqns-Tuple{SteadyStateData}","page":"ModelBaseEcon","title":"ModelBaseEcon.alleqns","text":"alleqns(ssd::SteadyStateData)\n\nReturn a list of all steady state equations.\n\nThe list contains all equations derived from the dynamic system and all explicitly added steady state constraints.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.assign_parameters!-Tuple{Union{ModelBaseEcon.AbstractModel, Parameters}}","page":"ModelBaseEcon","title":"ModelBaseEcon.assign_parameters!","text":"assign_parameters!(model, collection; [options])\nassign_parameters!(model; [options], param=value, ...)\n\nAssign values to model parameters. New parameters can be given as key-value pairs in the function call, or in a collection, such as a Dict or a NamedTuple. Individual parameters can be assigned directly to the model using dot-notation. This function should be more convenient when all parameters values are loaded from a file and available in a dictionary or some other key-value collection.\n\nThere are two options that control the behaviour.\n\npreserve_links=true - if set to true new values for link-parameters are ignored and the link is updated automatically from the new values of parameters it depends on. If set to false any link parameters are overwritten and become non-link parameters set to the given new values.\ncheck=true - if a parameter with the given name does not exist we ignore it. When check is set to true we issue a warning, when set to false we ignore it silently.\n\nExample\n\njulia> @using_example E1\njulia> assign_parameters(E1.model; α=0.3, β=0.7)\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.eval_R!","page":"ModelBaseEcon","title":"ModelBaseEcon.eval_R!","text":"eval_R!(res::AbstractArray{Float64,1}, point::AbstractArray{Float64, 2}, ::MED) where MED <: AbstractModelEvaluationData\n\nEvaluate the model residual at the given point using the given model evaluation structure. The residual is stored in the provided vector.\n\nImplementation details (for developers)\n\nWhen creating a new type of model evaluation data, you must define a method of this function specialized to it.\n\nThe point argument will be a 2d array, with the number of rows equal to maxlag+maxlead+1 and the number of columns equal to the number of variables+shocks+auxvars of the model. The res vector will have the same length as the number of equations + auxiliary equations. Your implementation must not modify point and must update res.\n\nSee also: eval_RJ\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.eval_RJ","page":"ModelBaseEcon","title":"ModelBaseEcon.eval_RJ","text":"eval_RJ(point::AbstractArray{Float64, 2}, ::MED) where MED <: AbstractModelEvaluationData\n\nEvaluate the model residual and its Jacobian at the given point using the given model evaluation structure. Return a tuple, with the first element being the residual and the second element being the Jacobian.\n\nImplementation details (for developers)\n\nWhen creating a new type of model evaluation data, you must define a method of this function specialized to it.\n\nThe point argument will be a 2d array, with the number of rows equal to maxlag+maxlead+1 and the number of columns equal to the number of variables+shocks+auxvars of the model. Your implementation must not modify point and must return the tuple of (residual, Jacobian) evaluated at the given point. The Jacobian is expected to be SparseMatrixCSC (this might change in the future).\n\nSee also: eval_R!\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.export_model","page":"ModelBaseEcon","title":"ModelBaseEcon.export_model","text":"export_model(model, name, file::IO)\nexport_model(model, name, path::String)\n\nExport the model into a module file. The name parameter is used for the name of the module as well as the module file. The module file is created in the directory specified by the optional third argument.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.geteqn-Tuple{Integer, SteadyStateData}","page":"ModelBaseEcon","title":"ModelBaseEcon.geteqn","text":"geteqn(i, ssd::SteadyStateData)\n\nReturn the i-th steady state equation. Index i is interpreted as in the output of alleqns. Calling geteqn(i, sdd) has the same effect as alleqn(ssd)[i], but it's more efficient.\n\nExample\n\n# Iterate all equations like this:\nfor i = 1:neqns(ssd)\n    eqn = geteqn(i, ssd)\n    # do something awesome with `eqn` and `i`\nend\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.inverse_transformation","page":"ModelBaseEcon","title":"ModelBaseEcon.inverse_transformation","text":"inverse_transformation(::Type{<:Transformation})\n\nReturn a Function that will be called to transform the simulation data after solving. See also transformation.\n\nIt is expected that transformation(T) ∘ inverse_transformation(T) == identity and inverse_transformation(T) ∘ transformation(T) == identity, but these is not verified.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.islinearized-Tuple{Model}","page":"ModelBaseEcon","title":"ModelBaseEcon.islinearized","text":"islinearized(m::Model)\n\nReturn true if the given model is linearized and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.issssolved-Tuple{SteadyStateData}","page":"ModelBaseEcon","title":"ModelBaseEcon.issssolved","text":"issssolved(sstate::SteadyStateData)\n\nReturn true if the steady state has been solved, or false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.linearize!","page":"ModelBaseEcon","title":"ModelBaseEcon.linearize!","text":"linearize!(model::Model; <keyword arguments>)\n\nTransform model into its linear approximation about its steady state.\n\nKeyword arguments\n\nsstate - linearize about the provided steady state solution\ndeviation::Bool - whether or not the linearized model will treat data passed to it as deviation from the steady state\n\nSee also: linearized and with_linearized\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.linearized-Tuple{Model}","page":"ModelBaseEcon","title":"ModelBaseEcon.linearized","text":"linearized(model::Model; <arguments>)\n\nCreate a new model that is the linear approximation of the given model about its steady state.\n\nKeyword arguments\n\nsstate - linearize about the provided steady state solution\ndeviation::Bool - whether or not the linearized model will tread data passed \n\nto is as deviation from the steady state\n\nSee also: linearize! and with_linearized\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.logm-Tuple{Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.logm","text":"logm(x) = log(-x)\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.mexp-Tuple{Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.mexp","text":"mexp(x) = -exp(x)\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.neqns-Tuple{SteadyStateData}","page":"ModelBaseEcon","title":"ModelBaseEcon.neqns","text":"neqns(ssd::SteadyStateData)\n\nReturn the total number of equations in the steady state system, including the ones derived from the dynamic system and the ones added explicitly as steady state constraints.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.peval-Tuple{Any, Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.peval","text":"peval(params, what)\n\nEvaluate the given expression in the context of the given parameters.\n\nIf what is a ModelParam, its current value is returned. If there's a chance it might be out of date, call update_links!.\n\nIf what is a Symbol or an Expr, all mentions of parameter names are substituted by their values and the the expression is evaluated.\n\nIf what is any other value, it is returned unchanged.\n\nSee also: Parameters, @alias, @link, ModelParam, update_links!.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.printsstate-Tuple{IO, ModelBaseEcon.AbstractModel}","page":"ModelBaseEcon","title":"ModelBaseEcon.printsstate","text":"printsstate([io::IO,] ssd::SteadyStateData)\n\nDisplay steady state solution.\n\nSteady state solution is presented in a table, where the first column is the name of the variable, the second and third columns are the corresponding values of the level and the slope. If the value is not determined (as per its mask value) then it is displayed as \"*\".\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.selective_linearize!-Tuple{ModelBaseEcon.AbstractModel}","page":"ModelBaseEcon","title":"ModelBaseEcon.selective_linearize!","text":"selective_linearize!(model)\n\nInstruct the model instance to use selective linearization. Only equations annotated with @lin in the model definition will be linearized about the current steady state solution while the rest of the eq\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.transformation","page":"ModelBaseEcon","title":"ModelBaseEcon.transformation","text":"transformation(::Type{<:Transformation})\n\nReturn a Function that will be substituted into the model equations and will be called to transform the input data before solving. See also inverse_transformation.\n\nIt is expected that transformation(T) ∘ inverse_transformation(T) == identity and inverse_transformation(T) ∘ transformation(T) == identity, but these is not verified.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.update_links!-Tuple{ModelBaseEcon.AbstractModel}","page":"ModelBaseEcon","title":"ModelBaseEcon.update_links!","text":"update_links!(model)\nupdate_links!(params)\n\nRecompute the current values of all parameters.\n\nTypically when a new value of a parameter is assigned, all parameter links and aliases that depend on it are updated recursively. If a parameter is mutable, e.g. a Vector or another collection, its value can be updated in place without re-assigning it, thus the automatic update does not happen. In this case, it is necessary to call update_links!.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.with_linearized-Tuple{Function, Model}","page":"ModelBaseEcon","title":"ModelBaseEcon.with_linearized","text":"with_linearized(F::Function, model::Model; <arguments>)\n\nApply the given function on a new model that is the linear approximation  of the given model about its steady state.  This is meant to be used with the do syntax, as in the example below.\n\nKeyword arguments\n\nsstate - linearize about the provided steady state solution\ndeviation::Bool - whether or not the linearized model will tread data passed \n\nto is as deviation from the steady state\n\nSee also: linearize! and with_linearized\n\nExample\n\nwith_linearized(m) do lm\n    # do something awesome with linearized model `lm`\nend\n# model `m` is still non-linear.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@alias-Tuple{Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.@alias","text":"@alias name\n\nCreate a parameter alias. Use `@alias` in the [`@parameters`](@ref) section of your\n\nmodel definition.\n\n@parameters model begin\n    a = 5\n    b = @alias a\nend\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@autoexogenize-Tuple{Any, Vararg{Expr, N} where N}","page":"ModelBaseEcon","title":"ModelBaseEcon.@autoexogenize","text":"@autoexogenize model begin\n    varname = shkname\n    ...\nend\n\nDefine a mapping between variables and shocks that can be used to conveniently  swap exogenous and endogenous variables.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@autoshocks","page":"ModelBaseEcon","title":"ModelBaseEcon.@autoshocks","text":"@autoshocks model\n\nCreate a list of shocks that matches the list of variables.  Each shock name is created from a variable name by appending \"_shk\".\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@d-Tuple","page":"ModelBaseEcon","title":"ModelBaseEcon.@d","text":"$\n\nInterpolation operator for interpolating into e.g. strings and expressions.\n\nExamples\n\njulia> name = \"Joe\"\n\"Joe\"\n\njulia> \"My name is $name.\"\n\"My name is Joe.\"\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@dlog-Tuple","page":"ModelBaseEcon","title":"ModelBaseEcon.@dlog","text":"$\n\nInterpolation operator for interpolating into e.g. strings and expressions.\n\nExamples\n\njulia> name = \"Joe\"\n\"Joe\"\n\njulia> \"My name is $name.\"\n\"My name is Joe.\"\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@equations-Tuple{Any, Expr}","page":"ModelBaseEcon","title":"ModelBaseEcon.@equations","text":"Usage example:\n\n@equations model begin\n    y[t] = a * y[t-1] + b * y[t+1] + y_shk[t]\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@initialize-Tuple{Symbol}","page":"ModelBaseEcon","title":"ModelBaseEcon.@initialize","text":"@initialize model\n\nPrepare a model instance for analysis. Call this macro after all variable names, shock names and equations have been defined.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@lag-Tuple","page":"ModelBaseEcon","title":"ModelBaseEcon.@lag","text":"$\n\nInterpolation operator for interpolating into e.g. strings and expressions.\n\nExamples\n\njulia> name = \"Joe\"\n\"Joe\"\n\njulia> \"My name is $name.\"\n\"My name is Joe.\"\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@lead-Tuple","page":"ModelBaseEcon","title":"ModelBaseEcon.@lead","text":"$\n\nInterpolation operator for interpolating into e.g. strings and expressions.\n\nExamples\n\njulia> name = \"Joe\"\n\"Joe\"\n\njulia> \"My name is $name.\"\n\"My name is Joe.\"\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@link-Tuple{Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.@link","text":"@link expr\n\nCreate a parameter link. Use @link in the @parameters section of your model definition.\n\nIf your parameter depends on other parameters, then you use @link to declare that. The expression can be any valid Julia code.\n\n@parameters model begin\n    a = 5\n    b = @link a + 1\nend\n\nWhen a parameter the link depends on is assigned a new value, the link that depends on it gets updated automatically.\n\nnote: Important note\nThere are two cases in which the value of a link does not get updated automatically. If the parameter it depends on is mutable, e.g. a Vector, it is possible for it to get updated in place. The other case is when the link contains global variable or custom function.In such case, it is necessary to call update_links!.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@load_example-Tuple{Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.@load_example","text":"Deprecated. Use @using_example instead.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@movav-Tuple","page":"ModelBaseEcon","title":"ModelBaseEcon.@movav","text":"$\n\nInterpolation operator for interpolating into e.g. strings and expressions.\n\nExamples\n\njulia> name = \"Joe\"\n\"Joe\"\n\njulia> \"My name is $name.\"\n\"My name is Joe.\"\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@movsum-Tuple","page":"ModelBaseEcon","title":"ModelBaseEcon.@movsum","text":"$\n\nInterpolation operator for interpolating into e.g. strings and expressions.\n\nExamples\n\njulia> name = \"Joe\"\n\"Joe\"\n\njulia> \"My name is $name.\"\n\"My name is Joe.\"\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@parameters-Tuple{Any, Vararg{Expr, N} where N}","page":"ModelBaseEcon","title":"ModelBaseEcon.@parameters","text":"@parameters model begin\n    name = value\n    ...\nend\n\nDeclare and define the model parameters. \n\nThe parameters must have values. Provide the information in a series of assignment statements wrapped inside a begin-end block. The names can be used in equations as if they were regular variables.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@parameters-Tuple{}","page":"ModelBaseEcon","title":"ModelBaseEcon.@parameters","text":"params = @parameters\n\nWhen called without any arguments, return an empty Parameters container, with its evaluation module set to the module in which the macro is being called.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@shocks-Tuple{Any, Expr}","page":"ModelBaseEcon","title":"ModelBaseEcon.@shocks","text":"@shocks model names...\n@shocks model begin\n    names...\nend\n\nDefine the names of transition shocks in the model.\n\nExample\n\n```jldoctest @shocks model ashk bshk c_shk\n\nIf the list is long, use a begin-end block separating names with newline or semicolon\n\n@shocks model begin     ashk; bshk     c_shk end ````\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@steadystate-Tuple{Any, Symbol, Expr}","page":"ModelBaseEcon","title":"ModelBaseEcon.@steadystate","text":"@steadystate model [type] equation\n\nAdd a steady state equation to the model.\n\nThe steady state system of the model is automatically derived from the dynamic system. Use this macro to define additional equations for the steady state. This is particularly useful in the case of a non-linear model that might have multiple steady state, or the steady state might be difficult to solve for, to help the steady state solver find the one you want to use.\n\nmodel is the model instance you want to update\ntype (optional) is the type of constraint you want to add. This can be level\n\nor slope. If missing, the default is level\n\nequation is the expression defining the steady state constraint. In the\n\nequation, use variables and shocks from the model, but without any t-references.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@using_example-Tuple{Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.@using_example","text":"@using_example name\n\nLoad models from the package examples/ folder. The @load_example version is deprecated - stop using it now.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@variables-Tuple{Any, Expr}","page":"ModelBaseEcon","title":"ModelBaseEcon.@variables","text":"@variables model names...\n@variables model begin\n    names...\nend\n\nDefine the names of transition variables in the model.\n\nExample\n\n```jldoctest @variables model a b c\n\nIf the list is long, use a begin-end block separating names with newline or semicolon\n\n@variables model begin     a; b     c end ````\n\n\n\n\n\n","category":"macro"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon-Reference","page":"StateSpaceEcon","title":"StateSpaceEcon Reference","text":"","category":"section"},{"location":"Reference/StateSpaceEcon/","page":"StateSpaceEcon","title":"StateSpaceEcon","text":"Pages = [\"statespaceecon.md\"]","category":"page"},{"location":"Reference/StateSpaceEcon/#Steady-state-solver","page":"StateSpaceEcon","title":"Steady state solver","text":"","category":"section"},{"location":"Reference/StateSpaceEcon/","page":"StateSpaceEcon","title":"StateSpaceEcon","text":"Modules = [StateSpaceEcon.SteadyStateSolver]\nPrivate = false","category":"page"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver","text":"SteadyStateSolver\n\nA module that is part of StateSpaceEcon package. Contains methods for finding a steady state of a model.\n\n\n\n\n\n","category":"module"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.check_sstate-Tuple{Model}","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.check_sstate","text":"check_sstate(model; <options>)\n\nRun a diagnostic test to determine if the steady state solution stored within the given model object is indeed a solution of the steady state system of equations.\n\nReturn the number of steady state equations that are violated by the current steady state solution. If verbose=true, also display diagnostic information in the form of listing all bad equations and their residuals.\n\nOptions\n\nStandard options (default values from model.options)\n\nverbose \ntol - an equation is considered satisfied if its residual, in absolute value, is smaller than this number.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.clear_sstate!-Tuple{Model}","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.clear_sstate!","text":"clear_sstate!(model; lvl=0.1, slp=0.0, <options>)\n\nSet the steady state values to the provided defaults and presolve.\n\nArguments\n\nmodel - the model instance\nlvl, slp - the initial guess for the level and the slope. Each could be a number or a vector of length equal to the number of variable in the mode.\n\nOptions\n\nStandard options (default values are taken from model.options)\n\nverbose\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.diagnose_sstate-Tuple{Model}","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.diagnose_sstate","text":"diagnose_sstate([point,] model)\n\nRun diagnostics on the steady state of the given model. If point is not given, then we check the steady state solution stored inside the given model.\n\nReturn a tuple of \"bad\" equations and \"bad\" variables. \n\nThe set of \"bad\" equations is one that is inconsistent, i.e. there is no solution. This might happen if the system is overdetermined.\n\nThe set of \"bad\" variables contains variables that cannot be solved uniquely. This might happen if the system is underdetermined. In this case, try adding steady state constraints until you get a unique solution. See @steadystate in ModelBaseEcon.\n\nwarning: Internal function\nThe output from this function may be difficult to read.<br> Call check_sstate instead.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.initial_sstate!-Tuple{Model, AbstractVector{Float64}}","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.initial_sstate!","text":"initial_sstate!(model, init; <options>)\n\nSet the steady state values from the given vector and presolve.\n\nCall this function to specify initial guesses for the iterative steady state solver. If the value of a steady state variable is known, it is better to use @steadystate to add that as a steady state constraint.\n\nArguments\n\nmodel - the model.\ninit - a vector of length equal to twice the number of variables in the model. The level and slope values are staggered, i.e., the level and slope of variable j are in init[2j-1] and init[2j].\n\nOptions\n\nStandard options (default values are taken from model.options)\n\nverbose\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.sssolve!-Tuple{Model}","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.sssolve!","text":"sssolve!(model; <options>)\n\nSolve the steady state problem for the given model.\n\nOptions\n\nStandard options (default values are taken from model.options)\n\nverbose\ntol, maxiter - control the stopping criteria of the solver\n\nSpecific options\n\npresolve::Bool - whether or not to use a presolve pass. Default is true.\nmethod::Symbol - choose the solution algorithm. Valid options are :nr for Newton-Raphson, :lm for Levenberg-Marquardt, and :auto. The :auto method starts with the LM algorithm and automatically switches to NR when it starts to converge. Default is :nr.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#Plans","page":"StateSpaceEcon","title":"Plans","text":"","category":"section"},{"location":"Reference/StateSpaceEcon/","page":"StateSpaceEcon","title":"StateSpaceEcon","text":"Modules = [StateSpaceEcon.Plans]\nPrivate = false","category":"page"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans","text":"Plans\n\nModule part of StateSpaceEcon. This module implements the Plan data structure, which is used in simulations. The plan object contains information about the range of the simulation and which variables and shocks are exogenous or endogenous at each period of the range.\n\nConstructors\n\nPlan(model, range)\n\nModify the plan\n\nexogenize!, endogenize! - make variables exogenous or endogenous\nexog_endo!, endo_exog! - swap exogenous and endogenous variables\nautoexogenize! - exogenize and endogenize variables according to the list in the model\n\nPrepare data for simulation\n\nzeroarray, zerodict, zerodata - prepare a matrix or a dictionary or a SimData of data for the simulation containing zeros.\nsteadystatearray, steadystatedict, steadystatedata - prepare a matrix or a dictionary or a SimData of data for the simulation containing the steady state.\n\n\n\n\n\n","category":"module"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.Plan","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.Plan","text":"Plan{T <: MIT}\n\nA data structure representing the simulation plan. It holds information about the time range of the simulation and which variables/shocks are exogenous at each period.\n\n\n\n\n\n","category":"type"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.Plan-Tuple{Model, AbstractUnitRange}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.Plan","text":"Plan(model, range)\n\nCreate a default simulation plan for the given model over the given range. The range of the plan is augmented to include periods before and after the given range, over which initial and final conditions will be applied. \n\nInstead of a range, one could also pass in a single moment in time (MIT) instance, in which case it is interpreted as a range of length 1.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.autoexogenize!-Tuple{Plan, Model, Any}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.autoexogenize!","text":"autoexogenize!(plan, model, date)\n\nModify the given plan according to the \"autoexogenize\" protocol defined in the given model. All variables in the autoexogenization list become endogenous and their corresponding shocks become exogenous over the given date or range. date can be a moment in time (same frequency as the given plan), a range, an iterable, or a container.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.endo_exog!-Tuple{Plan, Any, Any, Any}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.endo_exog!","text":"endo_exog!(plan, endo_vars, exog_vars, date)\n\nModify the given plan so that the given variables listed in exog_vars will be exogenous and the variables listed in endo_vars will be endogenous on the given dates. exog_vars and endo_vars can each be a Symbol or a String or a Vector of such. date can be a moment in time (same type as the plan), or a range or an iterable or a container.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.endogenize!-Tuple{Plan, Any, Any}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.endogenize!","text":"endogenize!(plan, vars, date)\n\nModify the given plan so that the given variables will be endogenous on the given dates. vars can be a Symbol or a String or a Vector of such. date can be a moment in time (same type as the plan), or a range or an iterable or a container.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.exog_endo!-Tuple{Plan, Any, Any, Any}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.exog_endo!","text":"exog_endo!(plan, exog_vars, endo_vars, date)\n\nModify the given plan so that the given variables listed in exog_vars will be exogenous and the variables listed in endo_vars will be endogenous on the given dates. exog_vars and endo_vars can each be a Symbol or a String or a Vector of such. date can be a moment in time (same type as the plan), or a range or an iterable or a container.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.exogenize!-Tuple{Plan, Any, Any}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.exogenize!","text":"exogenize!(plan, vars, date)\n\nModify the given plan so that the given variables will be exogenous on the given dates. vars can be a Symbol or a String or a Vector of such. date can be a moment in time (same type as the plan), or a range or an iterable or a container.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.plansum-Tuple{Model, Plan}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.plansum","text":"plansum(model, plan)\n\nReturn the total number of exogenous variables in the simulation plan. Periods over which initial and final conditions are imposed are not counted in this sum.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.setexog!-Tuple{Plan, Int64, Any}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.setexog!","text":"setexog!(plan, t, vinds)\n\nModify the plan at time t such that vinds are exogenous and the rest are endogenous.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#Stacked-time-solver","page":"StateSpaceEcon","title":"Stacked time solver","text":"","category":"section"},{"location":"Reference/StateSpaceEcon/","page":"StateSpaceEcon","title":"StateSpaceEcon","text":"Modules = [StateSpaceEcon.StackedTimeSolver]\nPrivate = false","category":"page"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver","text":"StackedTimeSolver\n\nA module that is part of StateSpaceEcon package. Contains methods for solving the dynamic system of equations for the model and running simulations.\n\n\n\n\n\n","category":"module"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.array2data","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.array2data","text":"array2data(matrix, vars, range)\narray2data(matrix, model, plan)\narray2workspace(matrix, vars, range)\narray2workspace(matrix, model, plan)\ndata2array(simdata)\ndata2workspace(simdata)\nworkspace2array(w, vars, range)\nworkspace2array(w, model, plan)\nworkspace2data(w, vars, range)\nworkspace2data(w, model, plan)\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.array2workspace","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.array2workspace","text":"array2data(matrix, vars, range)\narray2data(matrix, model, plan)\narray2workspace(matrix, vars, range)\narray2workspace(matrix, model, plan)\ndata2array(simdata)\ndata2workspace(simdata)\nworkspace2array(w, vars, range)\nworkspace2array(w, model, plan)\nworkspace2data(w, vars, range)\nworkspace2data(w, model, plan)\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.data2array","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.data2array","text":"array2data(matrix, vars, range)\narray2data(matrix, model, plan)\narray2workspace(matrix, vars, range)\narray2workspace(matrix, model, plan)\ndata2array(simdata)\ndata2workspace(simdata)\nworkspace2array(w, vars, range)\nworkspace2array(w, model, plan)\nworkspace2data(w, vars, range)\nworkspace2data(w, model, plan)\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.data2workspace","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.data2workspace","text":"array2data(matrix, vars, range)\narray2data(matrix, model, plan)\narray2workspace(matrix, vars, range)\narray2workspace(matrix, model, plan)\ndata2array(simdata)\ndata2workspace(simdata)\nworkspace2array(w, vars, range)\nworkspace2array(w, model, plan)\nworkspace2data(w, vars, range)\nworkspace2data(w, model, plan)\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.dictoverlay","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.dictoverlay","text":"dictoverlay(d1, d2)\n\nMerge two dictionaries. Common key where the values are TSeries of the same frequency are overlayed. Otherwise, a common key takes the value of the last Dict containing it.\n\nnote: Deprecation Note\nThis function will be removed. Use TimeSeriesEcon.overlay instead. An important difference is that TimeSeriesEcon.overlay keeps the values from the first argument where the key appears, while dictoverlay keeps it from the last.\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.seriesoverlay","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.seriesoverlay","text":"seriesoverlay(ts1, ts2)\n\nReturn a new TSeries over the full range of both arguments. The overlapping part contains values from the last argument.\n\nnote: Deprecation Note\nThis function will be removed in the future. Use TimeSeriesEcon.overlay instead.  Note the important difference that in TimeSeriesEcon.overlay the values in the overlay come from the first series where the value exists, as opposed to seriesoverlay where it was from the last one.\n\nSee also: dictoverlay\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.shockdecomp-Tuple{Model, Plan, MVTSeries{F, Float64, C} where {F<:Frequency, C<:AbstractMatrix{Float64}}}","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.shockdecomp","text":"shockdecomp(model, plan, exog_data; control, fctype, [options])\n\nCompute the shock decomposition for the given model, plan, exogenous (shocks) data and control solution.\n\nIf control option is not specified we use the steady state solution stored in the model instance. The algorithm assumes that control is a solution to the dynamic model for the given plan range and final condition. We verify the residual and issue a warning, but do not enforce this. See steadystatedata.\n\nAs part of the algorithm we run a simulation with the given plan,  exog_data and fctype.  See simulate for other options.\n\nnote: Note\nFor now only the case of anticipate=true works. Shock decomp with unanticipated shocks is coming soon.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.simulate","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.simulate","text":"simulate(model, plan, data; <options>)\n\nRun a simulation for the given model, simulation plan and exogenous data.\n\nArguments\n\nmodel - the Model instance to simulate.\nplan - the Plan for the simulation.\ndata - a 2D Array containing the exogenous data. This includes the initial and final conditions.\n\nOptions as keyword arguments\n\nfctype::FCType - set the desired final condition type for the simulation. The default value is fcgiven. Other possible values include fclevel and fcslope.\ninitial_guess::AbstractMatrix{Float64} - a 2D Array containing the initial guess for the solution. This is used to start the Newton-Raphson algorithm. The default value is an empty array (zeros(0,0)), in which case we use the exogenous data for the initial condition. You can use the steady state solution using steadystatearray.\ndeviation::Bool - set to true if the data is given in deviations from the steady state. In this case the simulation result is also returned as a deviation from the steady state. Default value is false.\nanticipate::Bool - set to false to instruct the solver that all shocks are unanticilated by the agents. Default value is true.\nverbose::Bool - control whether or not to print progress information. Default value is taken from model.options.\ntol::Float64 - set the desired accuracy. Default value is taken from model.options.\nmaxiter::Int - algorithm fails if the desired accuracy is not reached within this maximum number of iterations. Default value is taken from model.options.\n\nSee also:\n\nExamples\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.workspace2array","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.workspace2array","text":"array2data(matrix, vars, range)\narray2data(matrix, model, plan)\narray2workspace(matrix, vars, range)\narray2workspace(matrix, model, plan)\ndata2array(simdata)\ndata2workspace(simdata)\nworkspace2array(w, vars, range)\nworkspace2array(w, model, plan)\nworkspace2data(w, vars, range)\nworkspace2data(w, model, plan)\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.workspace2data","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.workspace2data","text":"array2data(matrix, vars, range)\narray2data(matrix, model, plan)\narray2workspace(matrix, vars, range)\narray2workspace(matrix, model, plan)\ndata2array(simdata)\ndata2workspace(simdata)\nworkspace2array(w, vars, range)\nworkspace2array(w, model, plan)\nworkspace2data(w, vars, range)\nworkspace2data(w, model, plan)\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#Various","page":"StateSpaceEcon","title":"Various","text":"","category":"section"},{"location":"Reference/StateSpaceEcon/","page":"StateSpaceEcon","title":"StateSpaceEcon","text":"Modules = [StateSpaceEcon]\nPrivate = false","category":"page"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StateSpaceEcon","page":"StateSpaceEcon","title":"StateSpaceEcon.StateSpaceEcon","text":"StateSpaceEcon\n\nA package for Macroeconomic modelling.\n\n\n\n\n\n","category":"module"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SimData","page":"StateSpaceEcon","title":"StateSpaceEcon.SimData","text":"SimData\n\nData structure containing the time series data for a simulation.\n\nIt is a collection of TSeries of the same frequency and containing data for the same range. When used for simulation, the range must include the initial conditions, the simulation range and the final conditions, although it could extend beyond that. It must contain time series for all variables and shocks in the model, although it might contain other time series.\n\n\n\n\n\n","category":"type"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.printmatrix-Tuple{AbstractMatrix{T} where T, Vararg{Any, N} where N}","page":"StateSpaceEcon","title":"StateSpaceEcon.printmatrix","text":"printmatrix(mat [, Val(F), colnames])\n\nDisplay a matrix in full while controlling the formatting of each value and optionally showing the column names.\n\nVal(F) - display each number in the given format F. The format is in the form of a decimal point number where the whole part indicates the total width and the fractional part is the number of digits printed after the decimal point. Default is Val(12.7)\ncolnames - a list of names to display in the first row. The names are displayed as given, possibly with padding to match the width given in the Val argument. If any names are longer than that, they will not be truncated and so the display will not be aligned properly. Sorry about that!\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.steadystatearray","page":"StateSpaceEcon","title":"StateSpaceEcon.steadystatearray","text":"zeroarray(model, plan)\nsteadystatearray(model, plan; [ref=firstdate(plan) + m.maxlag)\n\nCreate a Matrix{Float64} of the proper dimension for a simulation with the given model with the given plan. It is initialized to 0 or the steady state.\n\nThis function returns a Matrix. We recommend using zerodata. See also zeroworkspace\n\nIn the case of steady state solution that is not stationary in time (i.e., constant rate of change or constant rate of growth) use the ref option to specify the period in which the steady state level is given. The default is the first simulation period.\n\nnote: Deprecation Note\nzeroarray(model, range) will be removed in future versions. Always create a simulation Plan explicitly.\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.zeroarray","page":"StateSpaceEcon","title":"StateSpaceEcon.zeroarray","text":"zeroarray(model, plan)\nsteadystatearray(model, plan; [ref=firstdate(plan) + m.maxlag)\n\nCreate a Matrix{Float64} of the proper dimension for a simulation with the given model with the given plan. It is initialized to 0 or the steady state.\n\nThis function returns a Matrix. We recommend using zerodata. See also zeroworkspace\n\nIn the case of steady state solution that is not stationary in time (i.e., constant rate of change or constant rate of growth) use the ref option to specify the period in which the steady state level is given. The default is the first simulation period.\n\nnote: Deprecation Note\nzeroarray(model, range) will be removed in future versions. Always create a simulation Plan explicitly.\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.zerodata","page":"StateSpaceEcon","title":"StateSpaceEcon.zerodata","text":"zerodata(model, plan)\n\nCreate a [SimData] for a simulation with the given model and plan. Columns correspond to the model variables and shocks in the correct order. Data is initialized with 0 or the steady state. \n\nIn the case of steady state solution that is not stationary in time (i.e., constant rate of change or constant rate of growth) use the ref option to specify the period in which the steady state level is given. The default is the first simulation period.\n\nSee also zeroarray and zeroworkspace\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.zerodict","page":"StateSpaceEcon","title":"StateSpaceEcon.zerodict","text":"zerodict(model, plan)\nsteadystatedict(model, plan; [ref=firstdate(plan) + m.maxlag))\n\nnote: Deprecation Note\nThis function will be removed in a future version. Use zeroworkspace(model, plan).\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.zeroworkspace-Tuple{Model, Plan}","page":"StateSpaceEcon","title":"StateSpaceEcon.zeroworkspace","text":"zeroworkspace(model, plan)\nsteadystateworkspace(model, plan; [ref=firstdate(plan) + m.maxlag))\n\nCreate a TimeSeriesEcon.Workspace containing a TSeries for each variable/shock in the given model. They are initialized to 0 or the steady state solution.\n\nIn the case of steady state solution that is not stationary in time (i.e., constant rate of change or constant rate of growth) use the ref option to specify the period in which the steady state level is given. The default is the first simulation period.\n\nWe recommend using zerodata. See also zeroarray.\n\n\n\n\n\n","category":"method"},{"location":"DesignPapers/#Design-Papers","page":"Design Papers","title":"Design Papers","text":"","category":"section"},{"location":"DesignPapers/","page":"Design Papers","title":"Design Papers","text":"This section contains articles that describe the numerical methods and details about their implementations.","category":"page"},{"location":"#Welcome","page":"Welcome","title":"Welcome","text":"","category":"section"},{"location":"","page":"Welcome","title":"Welcome","text":"This is the official documentation for the StateSpaceEcon collection of Julia packages.","category":"page"},{"location":"","page":"Welcome","title":"Welcome","text":"warning: Under construction\nThis site is incomplete. Many articles that are planned to appear are not yet available. Some articles are still in a draft version. Please check back regularly.","category":"page"},{"location":"Tutorials/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"This section contains a list of tutorials demonstrating the use of StateSpaceEcon group of Julia packages.","category":"page"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"You could read the tutorials on the web - just browse the pages. If you wish to run the tutorial examples and further experiment for yourself, follow the instructions below to install a copy of the Tutorials on your computer.","category":"page"},{"location":"Tutorials/#Getting-started","page":"Introduction","title":"Getting started","text":"","category":"section"},{"location":"Tutorials/#Prerequisites","page":"Introduction","title":"Prerequisites","text":"","category":"section"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"You need a recent version of Julia (v1.0 or later). We also recommend using VSCode and so below we provide the instructions assuming that's the case. To install Julia and VSCode follow the instructions at https://github.com/julia-vscode/julia-vscode#installing-juliavs-codevs-code-julia-extensio","category":"page"},{"location":"Tutorials/#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"Clone either DocsEcon.jl or TutorialsEcon.jl.","category":"page"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"TutorialsEcon.jl is a sub-module of DocsEcon.jl, mounted in scr/Tutorial. If you decide to clone DocsEcon.jl, then you should make sure that you clone it recursively.","category":"page"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"$ git clone --recursive https://github.com/bankofcanada/DocsEcon.jl.git","category":"page"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"If you use VSCode to clone the project, that doesn't happen automatically and you'll see that src/Tutorial directory remains empty. In this case, open a terminal in your DocsEcon.jl directory and run","category":"page"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"$ git submodule init\n$ git submodule update","category":"page"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"After this, you should see the files of TutorialsEcon.jl appear under src/Tutorials.","category":"page"},{"location":"Tutorials/#Initialize-the-environment","page":"Introduction","title":"Initialize the environment","text":"","category":"section"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"Open a Julia REPL in the root directory of your project. Activate the environment in  the current directory and instantiate it.","category":"page"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"julia> ]\npkg> activate .\npkg> instantiate","category":"page"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"Note that if you're working with DocsEcon.jl, there's no need to do this in src/Tutorials, even though that directory contains its own Julia environment. All tutorials would run under the DocsEcon.jl environment just fine. If you find that not to be the case, please open a bug report issue in DocsEcon.jl.","category":"page"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"If you're using VSCode, make sure to set the default Julia environment for the workspace to the one you just instantiated.","category":"page"},{"location":"Tutorials/#Running-a-tutorial","page":"Introduction","title":"Running a tutorial","text":"","category":"section"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"Each tutorial is in its own subdirectory, which is self-contained, meaning that running a tutorial does not depend on files of another tutorial. ","category":"page"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"Each tutorial has a main.jl file, which contains the tutorial code. The code is meant to run in a REPL started in the root directory of the project, which is the default in VSCode. In any case, make sure the currently active environment is the one in the root directory of the project you cloned.","category":"page"}]
}
