var documenterSearchIndex = {"docs":
[{"location":"indexpage/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"indexpage/","page":"Index","title":"Index","text":"","category":"page"},{"location":"Tutorials/README/#README","page":"README","title":"README","text":"","category":"section"},{"location":"Tutorials/README/","page":"README","title":"README","text":"This project contains a list of tutorials demonstrating the use of StateSpaceEcon group of Julia packages. Each tutorial is in its own subdirectory. They are meant to run in a Julia REPL session running in the root directory of the project (which is what happens in VSCode), not in the subdirectory of the specific tutorial.  ","category":"page"},{"location":"Tutorials/README/#Installation","page":"README","title":"Installation","text":"","category":"section"},{"location":"Tutorials/README/","page":"README","title":"README","text":"The tutorials are designed to run in the Julia environment in the root of the project. Before the first use, make sure to instantiate the environment.","category":"page"},{"location":"Tutorials/README/","page":"README","title":"README","text":"] activate .\n] instantiate","category":"page"},{"location":"Tutorials/README/","page":"README","title":"README","text":"After that, make sure the environment is active when you run the tutorial codes.","category":"page"},{"location":"Tutorials/README/#List-of-tutorials","page":"README","title":"List of tutorials","text":"","category":"section"},{"location":"Tutorials/README/","page":"README","title":"README","text":"Each tutorial is in its own subdirectory containing a main.jl and main.md in addition to other files. The two main files contain the same code and explanations. If running the tutorial code yourself, you should use the .jl file.","category":"page"},{"location":"Tutorials/README/","page":"README","title":"README","text":"Smets and Wouters 2007\nFRB-US with VAR-based Expectations\nTimeSeriesEcon","category":"page"},{"location":"Tutorials/US_SW07/main/#Smets-and-Wouters-2007","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"You can follow the tutorial by reading this page and copying and pasting code into your Julia REPL session. In this case, you will need the model file, SW07.jl.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"All the code contained here is also available in this file: main.jl.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Pages = [\"main.md\"]\nDepth = 3","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"using StateSpaceEcon\nusing ModelBaseEcon\nusing TimeSeriesEcon\n\nusing Test\nusing Plots\nusing Random\nusing Distributions\n\n# Fix the random seed for reproducibility.\nRandom.seed!(1234);\n\n# We need the model file SW07.jl to be on the search path for modules.\nunique!(push!(LOAD_PATH, realpath(\".\"))) # hide\n","category":"page"},{"location":"Tutorials/US_SW07/main/#Part-1:-The-model","page":"Smets and Wouters 2007","title":"Part 1: The model","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/#Loading-the-model","page":"Smets and Wouters 2007","title":"Loading the model","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The model is described in its own dedicated module, which is contained in its own file, SW07.jl. We can load the module with using SW07; the model itself is a global variable called model within that module.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"using SW07\nm = SW07.model","category":"page"},{"location":"Tutorials/US_SW07/main/#Examining-the-model","page":"Smets and Wouters 2007","title":"Examining the model","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"This model is too big to fit all of its details in the REPL window, so only summary information is displayed. We can see the entire model with fullprint.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"fullprint(m)","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We can also examine individual components using the commands parameters, variables, shocks, equations.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"parameters(m)","category":"page"},{"location":"Tutorials/US_SW07/main/#Setting-the-model-parameters","page":"Smets and Wouters 2007","title":"Setting the model parameters","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We must not change any part of the model in the active Julia session except for the model parameters and steady state constraints. If we want to add variables, shocks, or equations, we must do so in the model module file and restart Julia to load the new model.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"When it comes to the model parameters, we can access them by their names from the model object using dot notation.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"m.crr # read a parameter value\nm.cgy = 0.5187 # modify a parameter value","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"note: Note\nIn this model the values of the parameters have been set according to the replication data.","category":"page"},{"location":"Tutorials/US_SW07/main/#Model-flags-and-options","page":"Smets and Wouters 2007","title":"Model flags and options","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"In addition to model parameters, which are values that appear in the model equations, the model object also holds two other sets of parameters, namely flags and options.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Flags are (usually boolean) values which characterize the type of model we have. For example, a linear model should have its linear flag set to true. Typically, this is done in the model file before calling @initialize.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"m.flags","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Options are values that adjust the operations of the algorithms. For example, we have tol and maxiter, which set the desired accuracy and maximum number of iterations for the iterative solvers. These can be adjusted as needed at any time. Another useful option is verbose, which controls the level of verbosity of the different commands.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Many functions in StateSpaceEcon have optional arguments of the same name as a model option. When the argument is not explicitly given in the function call, these functions will use the value from the model option of the same name.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"m.verbose = true\nm.options","category":"page"},{"location":"Tutorials/US_SW07/main/#Part-2:-The-steady-state-solution","page":"Smets and Wouters 2007","title":"Part 2: The steady state solution","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The steady state is a special solution of the dynamic system that remains constant over time. It is important on its own, but also it can be useful in several ways. For example, linearizing the model requires a particular solution about which to linearize, and the steady state is typically used for this purpose.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"In addition to the steady state, we also consider another kind of special solution which grows linearly in time. If we know that the steady state solution is constant (i.e., its slope is zero), we can set the model flag ssZeroSlope to true. This is not required; however in a large model it might help the steady state solver converge faster to the solution.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The model object m stores information about the steady state. This includes the steady state solution itself, as well as a (possibly empty) set of additional constraints that apply only to the steady state. This information can be accessed via m.sstate.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"m.sstate","category":"page"},{"location":"Tutorials/US_SW07/main/#steady_state_constraints","page":"Smets and Wouters 2007","title":"Steady state constraints","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Sometimes the steady state is not unique, and we can use steady state constraints to specify the particular steady state we want. Also, if the model is non-linear, these constraints can be used to help the steady state solver converge. Steady state constraints can be added with the @steadystate macro. The constraint can be as simple as giving a specific value; we can also write an equation with multiple variables. We're allowed to use model parameters in these equations as well.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"@steadystate m a = 5\nm.sstate","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We can clean up the constraints by emptying the constraints container.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"empty!(m.sstate.constraints)\nm.sstate","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"note: Important note\nSteady state constraints that are always valid can be pre-defined in the model file. In that case, all calls to the @steadystate macro must be made after calling @initialize.","category":"page"},{"location":"Tutorials/US_SW07/main/#Solving-for-the-steady-state","page":"Smets and Wouters 2007","title":"Solving for the steady state","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The steady state solution is stored within the model object. Before solving, we have to specify an initial condition. If the model is linear, this makes no difference, but in a non-linear model a good or a bad initial guess might be the difference between success and failure of the steady state solver.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We specify the initial guess by calling clear_sstate!. This call removes any previously stored solution, sets the initial guess, and runs the pre-solve pass of the steady state solver. The initial guess can be given with the lvl and slp arguments; if not provided, an initial guess is chosen automatically.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Once that's done, we call sssolve! to find the steady state. This function returns a Vector{Float64} containing the steady state solution, and it also writes that solution into the model object. The vector is of length 2*nvariables(m) and contains the level and the slope for each variable.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"clear_sstate!(m)\nsssolve!(m);","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"If in doubt, we can use check_sstate to make sure the steady state solution stored in the model object indeed satisfies the steady state system of equations. This function returns the number of equations that are not satisfied. A value of 0 is what we want to see. In verbose mode, it also lists the problematic equations and their residuals.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"check_sstate(m)","category":"page"},{"location":"Tutorials/US_SW07/main/#Examining-the-steady-state","page":"Smets and Wouters 2007","title":"Examining the steady state","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We can access the steady state solution via m.sstate using the dot notation.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"m.sstate.dc","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We can also assign new values to the steady state solution, but we should be careful to make sure it remains a valid steady state solution.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"m.sstate.dc.level = 0.43121\n@test check_sstate(m) > 0","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"As the code above shows, a wrong steady state solution (based on the specified precision in the tol option) will result in one or more equation not being satisfied. Let's put back the correct value.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"m.sstate.dc.level = 0.4312\n@test check_sstate(m) == 0","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We can examine the entire steady state solution with printsstate.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"printsstate(m)","category":"page"},{"location":"Tutorials/US_SW07/main/#Part-3:-Impulse-response","page":"Smets and Wouters 2007","title":"Part 3: Impulse response","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/#Simulation-plan","page":"Smets and Wouters 2007","title":"Simulation plan","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Before we can simulate the model, we have to decide on the length of the simulation and what data is available for each period, i.e., what values are known (exogenous). This is done with an object of type Plan.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"To create a plan, all we need is the model object and a range for the simulation.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"sim_rng = 2000Q1:2039Q4\np = Plan(m, sim_rng)","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The plan shows us the list of exogenous values (variable or shocks) for each period or sub-range of the simulation. By default, all shocks are exogenous and all variables are endogenous.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We also see that the range of the plan has been extended before and after the simulation range. This is necessary because we need to set initial and final conditions. The number of periods for initial conditions is equal to the largest lag in the model. Similarly, final conditions have to be imposed over as many periods as the largest lead.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"p.range          # the full range of the plan\ninit_rng = first(p.range):first(sim_rng)-1   # the range for initial conditions\nfinal_rng = last(sim_rng)+1:last(p.range)     # the range for final conditions\n@test length(init_rng) == m.maxlag\n@test length(final_rng) == m.maxlead","category":"page"},{"location":"Tutorials/US_SW07/main/#Exogenous-data","page":"Smets and Wouters 2007","title":"Exogenous data","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We have to provide the data for the simulation. We start with all zeros and fill in the external data, which must include initial conditions for all variable and shocks, exogenous values (according to the plan), and possibly final conditions.","category":"page"},{"location":"Tutorials/US_SW07/main/#Initial-conditions","page":"Smets and Wouters 2007","title":"Initial conditions","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"In this example, we want to simulate an impulse response, so it makes sense to start from the steady state, so that is what we set as the initial condition. We leave the initial conditions for the shocks at 0.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"exog = zerodata(m, p);\nfor var in variables(m)\n    exog[init_rng, var] = m.sstate[var].level\nend\nexog","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"tip: Pro tip\nThe above works because the steady state is stationary, i.e., all slopes are zero. If we had a model with linear growth steady state, we could do something like the following (see @rec):for var in variables(m)\n    ss = m.sstate[var]\n    exog[init_rng, var] = ss.level\n    if ss.slope != 0\n        # recursively update by adding the slope each period\n        @rec init_rng[2:end] exog[t, var] = exog[t - 1, var] + ss.slope\n    end\nend","category":"page"},{"location":"Tutorials/US_SW07/main/#Final-conditions","page":"Smets and Wouters 2007","title":"Final conditions","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"For the final conditions we can use the steady state again, because we expect that the economy will eventually return to it if the simulation is sufficiently long past the last shock. We can do this by assigning the values of the steady state to the final periods after the simulation, similarly to what we did with the initial conditions.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Alternatively, we can specify that we want to use the steady state in the call to simulate by passing fctype=fclevel. Yet another possibility is to set the final condition so that the solution slope matches the slope of the steady state by setting fctype=fcslope. In both cases, we do not need to set anything in the exogenous data array because those values would be ignored.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"tip: Pro tip\nIn the Smets and Wouters 2007 model the two ways of using the steady state for final conditions (level or slope) are equivalent, because the steady state here is stationary and unique. In models where the steady state has non-zero slope, or the steady state has zero slope but the level is not unique, we should use fctype=fcslope.","category":"page"},{"location":"Tutorials/US_SW07/main/#A-quick-sanity-check","page":"Smets and Wouters 2007","title":"A quick sanity check","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"If we were to run a simulation where the economy started in the steady state and there were no shocks at all, we'd expect that the economy would remain in steady state forever.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"ss = simulate(m, exog, p; fctype=fcslope);","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The simulated data, ss, should equal (up to the accuracy of the solution) the steady state data. Similar to zerodata, we can use steadystatedata to create a data set containing the steady state solution.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"@test ss ≈ steadystatedata(m, p)","category":"page"},{"location":"Tutorials/US_SW07/main/#Exogenous-data-2","page":"Smets and Wouters 2007","title":"Exogenous data","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"All shocks are exogenous by default. All we have left to do is to set the value of the shock.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Let's say that we want to shock epinf for the first four quarters by 0.1.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"exog[sim_rng[1:4], :epinf] = 0.1;\nexog[shocks(m)]","category":"page"},{"location":"Tutorials/US_SW07/main/#Running-the-simulation","page":"Smets and Wouters 2007","title":"Running the simulation","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We call simulate, providing the model, the exogenous data, and the plan. We also specify the type of final condition we want to impose.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"irf = simulate(m, exog, p, fctype=fcslope);","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We can now take a look at how some of the observable variables in the model have responded to this shock. We use plot from the Plots package to for that. We specify the variables we want to plot using vars and the names of the datasets being plotted (for the legend) in the names option.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"plot(ss, irf,\n     vars=(:pinfobs, :dy, :labobs, :robs),\n     names=(\"SS\", \"IRF\"),\n     legend=[true false false false],\n     size=(600, 400)\n    );","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"savefig(\"irf.png\")","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"(Image: Impulse Response Graph)","category":"page"},{"location":"Tutorials/US_SW07/main/#Part-4:-Stochastic-shocks-simulation","page":"Smets and Wouters 2007","title":"Part 4: Stochastic shocks simulation","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Now let's run a simulation with stochastic shocks. We will have random shocks over two years and then have no shocks for several years afterwards to allow time for the economy to return to its steady state.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"sim_rng = 2000Q1:2049Q4      # simulate 50 years starting 2000\nshk_rng = 2004Q1 .+ (0:7)    # shock 8 quarters starting in 2004\np = Plan(m, sim_rng)\ninit_rng = first(p.range):first(sim_rng) - 1\nfinal_rng = last(sim_rng) + 1:last(p.range)\nexog = zerodata(m, p);\nfor v in variables(m)\n    exog[init_rng, v] = m.sstate[v].level\nend","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The distributions of the shocks are assumed normal with mean zero and standard deviations that have been estimated in the replication data. We use packages Distributions and Random to draw the necessary random values.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"shk_dist = (ea = Normal(0.0, 0.4618),\n            eb = Normal(0.0, 1.8513),\n            eg = Normal(0.0, 0.6090),\n            eqs = Normal(0.0, 0.6017),\n            em = Normal(0.0, 0.2397),\n            epinf = Normal(0.0, 0.1455),\n            ew = Normal(0.0, 0.2089));\nfor (shk, dist) in pairs(shk_dist)\n    exog[shk_rng, shk] = rand(dist, length(shk_rng))\nend\nexog[shk_rng, shocks(m)]","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Now we are ready to simulate. We can set the shocks to be anticipated or unanticipated by setting the anticipate parameter in simulate.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"sim_a = simulate(m, exog, p; fctype=fcslope, anticipate=true);\nsim_u = simulate(m, exog, p; fctype=fcslope, anticipate=false);","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"As before, we can review the responses of the observed variables to these shocks using plot.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"observed = (:dy, :dc, :dinve, :labobs, :pinfobs, :dw, :robs);\nss = steadystatedata(m, p);\nplot(ss, sim_a, sim_u,\n     vars=observed,\n     names=(\"SS\", \"Anticipated\", \"Unanticipated\"),\n     legend=[true (false for i = 1:6)...],\n     linewidth=1.5,   # hide\n     size=(900, 600)  # hide\n    );","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"savefig(\"stoch_shk.png\")","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"(Image: Stochastic Shock Response Graph)","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We see that when the shocks are anticipated, the variables start to react to them right away; in the unanticipated case, there is no movement until the shocks actually hit.","category":"page"},{"location":"Tutorials/US_SW07/main/#Part-5:-Backing-out-historical-shocks","page":"Smets and Wouters 2007","title":"Part 5: Backing out historical shocks","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Now let's pretend that the simulated values are historical data and that we do not know the magnitude of the shocks. We can treat the observed (simulated) values of the variables as known by making them exogenous. At the same time we will make the shocks endogenous, so that we can solve for their values during the simulation.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The \"historic\" (simulated, assumed observed) range is from the first period of the simulation until the last shock in the previous exercise.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"hist_rng = first(sim_rng):last(shk_rng)","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We use exogenize! and endogenize! to set up a plan in which observed variables are exogenous and shocks are endogenous throughout the historic range.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"endogenize!(p, shocks(m), hist_rng);\nexogenize!(p, observed, hist_rng);\np","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"As we can see above, the plan now reflects our intentions.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Finally, we need to set up the exogenous data. This time we do not specify the shocks; instead, we assign the known data for the observed variables for the historic range. We start with initial conditions.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"exog = zerodata(m, p);\nfor v in variables(m)\n    exog[init_rng, v] = m.sstate[v].level\nend","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We take the observed data from the simulation above. We show the anticipated version first.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"for v in observed\n    exog[hist_rng, v] = sim_a[v]\nend\nback_a = simulate(m, exog, p, fctype=fcslope, anticipate=true);","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Now we show the unanticipated case.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"for v in observed\n    exog[hist_rng, v] = sim_u[v]\nend\nback_u = simulate(m, exog, p, fctype=fcslope, anticipate=false);","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"If we did everything correctly, the shocks we recovered must match exactly the shocks we used when we simulated the \"historical\" data.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"@test sim_a[shocks(m)] ≈ back_a[shocks(m)]\n@test sim_u[shocks(m)] ≈ back_u[shocks(m)]","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Moreover, we must have the unobserved variables match as well. In fact, all the data must match over the entire simulation range.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"@test sim_a ≈ back_a\n@test sim_u ≈ back_u","category":"page"},{"location":"Tutorials/US_SW07/main/#Appendix","page":"Smets and Wouters 2007","title":"Appendix","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/#replication_data","page":"Smets and Wouters 2007","title":"Replication Data","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The replication data can be downloaded from http://doi.org/10.3886/E116269V1","category":"page"},{"location":"Tutorials/US_SW07/main/#References","page":"Smets and Wouters 2007","title":"References","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Smets, F., Wouters, R., 2007. Shocks and frictions in US business cycles: A bayesian DSGE approach. The American Economic Review 97(3), 586–606.","category":"page"},{"location":"DesignPapers/final_conditions/#Final-Conditions","page":"Final Conditions","title":"Final Conditions","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"This article describes the different types of final conditions supported in StateSpaceEcon, the relevant mathematical derivations, as well as some implementation details.","category":"page"},{"location":"DesignPapers/final_conditions/#Introduction","page":"Final Conditions","title":"Introduction","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"In the stacked time algorithm all equations for all time periods are solved simultaneously as one, very large system of equations. Because of lags in some of the variables, we must impose initial conditions, i.e. values for the variables before the first period of the simulation. This is not unique to stacked time algorithm - all solution methods require initial conditions.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Similarly, because of leads in some of the variables, we must provide final conditions. Final conditions are equations in terms of variables at times beyond the last period of the simulation.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"As a running example, consider a model with one variable y_t, one shock sy_t, and one equation involving one lag and one lead:","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    f(y_t-1 y_t y_t+1 s_t) = 0","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Suppose we want to simulate 3 periods. Let's use indices t=24 for the simulation periods. In the stacked time algorithm we have to solve the following system of equations:","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"beginaligned\n    f(y_1 y_2 y_3 s_2) = 0 \n    f(y_2 y_3 y_4 s_3) = 0 \n    f(y_3 y_4 y_5 s_4) = 0\nendaligned","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"We see that we have 3 equations with 5 unknowns - we assume that the values of the shocks (s_t) are given as exogenous data. In order to find a unique solution for y_t for all t=15, we need two more equations. The first one is the initial condition.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"y_1 = Y_1","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"where Y_1 is a known value of y at time t=1. The last equation is the final condition, which would help us solve for y_5.","category":"page"},{"location":"DesignPapers/final_conditions/#Types-of-Final-Conditions","page":"Final Conditions","title":"Types of Final Conditions","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"There are four types of final conditions currently implemented in StateSpaceEcon.","category":"page"},{"location":"DesignPapers/final_conditions/#fcgiven","page":"Final Conditions","title":"fcgiven","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"This is the simplest one of them. It can be used when the values of the variable after the end of the simulation are known and we simply assign them.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"In our running example, the following equation corresponds to fcgiven.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"y_5 = Y_5","category":"page"},{"location":"DesignPapers/final_conditions/#fclevel","page":"Final Conditions","title":"fclevel","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"This is almost the same as fcgiven in that here again we simply assign known values to the variables in the final conditions. This time the values come from the steady state solution of the system. This works if the steady state of y_t is a constant.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"y_5 = ssY_5","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Where ssY is the steady state of y. Note that the steady state is not necessarily a constant. In the case of balanced growth path and more than one final conditions period, we still assign the known values of ssY_t as computed from its known level and slope.","category":"page"},{"location":"DesignPapers/final_conditions/#fcslope","page":"Final Conditions","title":"fcslope","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"In this case we write an equation which sets the first difference of y_t at the end of the simulation (for all final conditions periods) to the slope of the steady state. This works if the steady state solution of y_t is a balanced path with linear growth. It can also be used with constant steady state - in that case the \"linear growth\" has slope 0.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"y_5 - y_4 = ssY_5 - ssY_4","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Note that ssY_t+1 - ssY_t = ssY_slope is simply the slope of the steady state - a constant that does not depend on t.","category":"page"},{"location":"DesignPapers/final_conditions/#fcnatural","page":"Final Conditions","title":"fcnatural","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"This is the case when we believe that the solution path beyond the end of the simulation is a straight line, but we don't know its slope, i.e., we allow the slope to be solved for. Practically, this final condition imposes the constraint that the second difference of the variable is zero after the last simulation period.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"   y_5 - 2 y_4 + y_3 = 0","category":"page"},{"location":"DesignPapers/final_conditions/#The-Stacked-Time-System-of-Equations","page":"Final Conditions","title":"The Stacked Time System of Equations","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Once we stack all equations for all simulation time periods into a single system of equations, we get a system with more unknowns than equations, as we saw above. In addition to initial and final conditions, we also have to impose exogenous constraints.","category":"page"},{"location":"DesignPapers/final_conditions/#Vector-of-Unknowns","page":"Final Conditions","title":"Vector of Unknowns","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Let us denote by x the vector of all unknowns. To be specific, the variables and shocks are assigned consecutive and unique indices from 1 to N. Also, the time periods of the simulation, together with the necessary number of time periods before (initial conditions) and after (final conditions) the simulation, are numbered sequentially starting from 1 to T. Thus vector x has N T components. We have adopted the convention that the first T components correspond to values of the first variable, components from T+1 to 2T are for variable 2 and so on.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"We divide the unknowns into three groups based on how they are treated by the solver. The first group contains the unknowns whose values are already known. These include initial conditions and exogenous constraints. We denote these x_e.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"The second group is the set of \"active unknowns\". These are the ones we are actually solving for in the simulation. We denote them x_s.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"The third group consists of the unknowns determined by final conditions. We denote that vector x_c.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"In our example, the vectors of unknowns would look like this:","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"beginaligned\n    x = y_1 y_2 y_3 y_4 y_5 s_1 s_2 s_3 s_4 s_5 \n    x_e = y_1 s_1 s_2 s_3 s_3 s_4 s_5 \n    x_s = y_2 y_3 y_4 \n    x_c = y_5\nendaligned","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"In what follows, we will renumber the unknowns in x such that x_e are in the beginning, x_s are in the middle and x_c are at the end. In the code we don't actually do this, but it makes it easier to discuss the linear algebra in the following sections.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    x =  x_e  x_s  x_c ","category":"page"},{"location":"DesignPapers/final_conditions/#Equations","page":"Final Conditions","title":"Equations","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"The equations are also grouped into the same three groups and for the purpose of this exposition we put them in the same order as we did with the unknowns above.","category":"page"},{"location":"DesignPapers/final_conditions/#The-System-of-Equations","page":"Final Conditions","title":"The System of Equations","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Without loss of generality we have a system of equations F(x) = 0. Starting with an initial guess x^0, the Newton-Raphson method consists in the iteration","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    x^n+1 = x^n - J(x^n)^-1 F(x^n)qquadmathrmfor n=012","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"where J(x^n) is the Jacobian of F evaluated at x^n.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"warning: Important\nWe need to distinguish between initial condition and initial guess. The former refers to the values of the model variables prior to the simulation range. The latter is the vector of unknowns at the start of the iterative solution method. To distinguish the two, we use upper index (superscript) to denote the successive iterations of the Newton-Raphson method, while the lower index (subscript) is used to denote the variable group e, s, or c.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"The computational step here consists in solving the linear system with matrix J and right hand side F. We can write this system into a 3-by-3 block-matrix form, with rows corresponding to equations and columns corresponding to unknowns split into the three groups.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    beginbmatrix I  0  0  E_s  S  C_s  E_c  S_c  C endbmatrix\n    cdot\n    beginbmatrix delta x_e  delta x_s  delta x_c endbmatrix\n    =\n    beginbmatrix 0  F_s  F_c endbmatrix","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"The first row corresponds to exogenous and initial conditions. Notice that the unknown here is not x but the update delta x. If we assign the correct exogenous and initial values in x^0 then the residuals of this group of equations will be all zeros, F_e = 0, and so the update delta x_e will also be always zero.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Therefore the entire system reduces to solving the following:","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    beginbmatrix S  C_s  S_c  C endbmatrix\n    cdot\n    beginbmatrix delta x_s  delta x_c endbmatrix\n    =\n    beginbmatrix F_s  F_c endbmatrix","category":"page"},{"location":"DesignPapers/final_conditions/#Solution-Method","page":"Final Conditions","title":"Solution Method","text":"","category":"section"},{"location":"DesignPapers/final_conditions/#Case-1:-fcgiven","page":"Final Conditions","title":"Case 1: fcgiven","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"In this case we have","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    beginbmatrix S  C_s  0  I endbmatrix\n    cdot\n    beginbmatrix delta x_s  delta x_c endbmatrix\n    =\n    beginbmatrix F_s  0 endbmatrix","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Once again we assume that the correct values for x_c are assigned in the initial guess, x^0. Therefore the update delta x_c is always zero. Therefore in this case we simply solve","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    S cdot delta x_s = F_s","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Note that even though we are not explicitly solving for delta x_e and delta x_c, the matrix S and the right hand side F_s here depend on the values x_e and x_c, since they are part of x^n when evaluating F(x^n) and J(n^n).","category":"page"},{"location":"DesignPapers/final_conditions/#Case-2:-fclevel","page":"Final Conditions","title":"Case 2: fclevel","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"This is identical to case 1.","category":"page"},{"location":"DesignPapers/final_conditions/#Case-3:-fcslope","page":"Final Conditions","title":"Case 3: fcslope","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"This is an interesting case. Pay attention because this part is tricky.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"We have the following equations.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"beginaligned\n    S cdot delta x_s + C_s cdot delta x_c = F_s \n    S_c cdot delta x_s + C cdot delta x_c = F_c\nendaligned","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"We eliminate delta x_c from the system. To do so, we multiply the second equation by C_s C^-1 and subtract the result from the first equation.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    left( S - C_s C^-1 S_c right) cdot delta x_s = F_s - C_s C^-1 F_c","category":"page"},{"location":"DesignPapers/final_conditions/#Solve-for-\\delta-x_s","page":"Final Conditions","title":"Solve for delta x_s","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Suppose that F_c = 0. We will discuss later how we make sure that's the case. Then the solution for delta x_s is given by","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    left( S - C_s C^-1 S_c right) cdot delta x_s = F_s","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"The only difference with case 1 and 2 is that the system matrix is modified by subtracting C_s C^-1 S_c. The matrix C^-1 S_c is constant. This matrix is specific to the fcslope type of final conditions for the given model. It only depends on the number of variables and the number of final conditions periods. It can be pre-computed and stored.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"The matrix C_s on the other hand depends on x^n and so it needs to be re-computed at every iteration.","category":"page"},{"location":"DesignPapers/final_conditions/#Solve-for-\\delta-x_c","page":"Final Conditions","title":"Solve for delta x_c","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"How do we make sure that F_c = 0? Remember that the final conditions equation in our example model is","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"y_5 - y_4 = ssY_slope","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Imagine how this would generalize to an arbitrary model. Now notice that the residual F_c depends on x^n and the slope of the steady state ssY_slope. Since we know the x^n_s part of x^n prior to solving the system, we can set the x^n_c part of x^n so that the final conditions are satisfied. In other words, this would make sure that F_c = 0. One way to do this is to simply start from the values of the variables at the last period of the simulation (which are in x^n_s; that's y_4 in our example) and compute all future values (which are in x^n_c,; that's y_5 in the example) by adding the corresponding steady state slope (that is y_5 = y_4 + ssY_slope). We must do this on every iteration before we evaluate F(x^n) and J(x^n).","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Actually, that's not true. It turns out that we only need to do this to the initial guess x^0. After that, once we compute delta x_s by solving the above system, we can solve the following system for delta x_c.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    C cdot delta x_c = - S_c cdot delta x_s","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"With delta x computed this way, the resulting x^n+1 will produce F_c=0 at the next iteration. This can be verified directly.","category":"page"},{"location":"DesignPapers/final_conditions/#The-Matrices:-C,-S_c-and-C{-1}S_c","page":"Final Conditions","title":"The Matrices: C, S_c and C^-1S_c","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"These matrices have 0 everywhere except for some non-zero blocks, which we discuss here.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Our running example has only one period of final conditions and a single variable, which is a trivial case. In order to see what happens in a more general case, suppose we have 4 periods of final conditions and several variables. In matrix C we will have a block, C_b, like the one below for each variable in the model. Each C_b will be the same square block with as many rows and columns as the number of final condition periods.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"C_b = beginbmatrix\n    1  0  0  0  -1  1  0  0  0  -1  1  0  0  0  -1  1\n    endbmatrix","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Matrix S_c also contains identical blocks S_cb for each variable. The number of rows is the same as C_b, while the number of columns equals the number of simulation periods. The -1 in the top-right corner is in the column corresponding to the last period of the simulation. (In our trivial example above that would be t=4)","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"S_cb = beginbmatrix\n            0  cdots  0  -1 \n            0  cdots  0  0 \n            0  cdots  0  0 \n            0  cdots  0  0\n          endbmatrix","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Now it is straightforward to compute C^-1 S_c. It also has block-structure with blocks like this:","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":" left(C^-1S_cright)_b = beginbmatrix\n            0  cdots  0  -1 \n            0  cdots  0  -1 \n            0  cdots  0  -1 \n            0  cdots  0  -1 \n        endbmatrix","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"The column with -1 again corresponds to the last period of the simulation.","category":"page"},{"location":"DesignPapers/final_conditions/#Case-4:-fcnatural","page":"Final Conditions","title":"Case 4: fcnatural","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"This case is identical to case 3. The only thing that changes is the matrices.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"This time for our example we will use 5 periods of final conditions, so that the patterns would be more obvious. We have the following.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"C_b = beginbmatrix\n    -1   0   0   0   0 \n     2  -1   0   0   0 \n    -1   2  -1   0   0 \n     0  -1   2  -1   0 \n     0   0  -1   2  -1 \n    endbmatrix","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"For S_c this time we have non-zeros in two columns corresponding to the last two periods of the simulation.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"S_cb = beginbmatrix\n            0  cdots  0  -1  2 \n            0  cdots  0  0  -1 \n            0  cdots  0  0   0 \n            0  cdots  0  0   0 \n            0  cdots  0  0   0 \n          endbmatrix","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Finally, we have","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":" left(C^-1S_cright)_b = beginbmatrix\n            0  cdots  0  1  -2 \n            0  cdots  0  2  -3 \n            0  cdots  0  3  -4 \n            0  cdots  0  4  -5 \n            0  cdots  0  5  -6 \n        endbmatrix","category":"page"},{"location":"DesignPapers/final_conditions/#Handling-of-log-variables","page":"Final Conditions","title":"Handling of log-variables","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"If we have log variables the final conditions the cases of fclevel and fcgiven are the same as above.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"In the case of fcslope the balanced growth path solution is actually a geometric sequence. What we call its \"slope\" here is actually the common ratio, that is ssY_slope = ssY_t  ssY_t-1 for all t. We have final condition equations that look like this:","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    y_5  y_4 = ssY_slope","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"In the case of fcnatural, we again impose the condition that the solution must be a geometric sequence, although this time the common ratio is unknown and we must solve for it. We have final conditions like this","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    y_5  y_4 = y_4  y_3","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"In both cases it is better to work with an equivalent formulation in terms of logs.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"beginaligned\n    log(y_5) = log(y_4) + log(ssY_slope) qquad  mathrmfor fcslope \n    log(y_5) = 2 log(y_4) - log(y_3) qquad  mathrmfor fcnatural\nendaligned","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"If we were to implement this directly, the matrix blocks C_b and S_cb corresponding to log-variables would not be constant (as they were above for non-log variables), because they would contain the derivatives of the above log functions and would therefore need to be re-computed on each iteration.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"However, in our implementation of log-variables, we apply the log-transformation and so the unknowns we actually solve for are log(y_t). Thus, the final conditions are in fact identical to the ones for non-log variables and we don't need to do anything special here.","category":"page"},{"location":"DesignPapers/final_conditions/#Conclusion","page":"Final Conditions","title":"Conclusion","text":"","category":"section"},{"location":"Tutorials/TimeSeriesEcon/main/#TimeSeriesEcon","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"","category":"section"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"All the code contained here is also available in this file: main.jl.","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"Pages = [\"main.md\"]\nDepth = 3","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"using TimeSeriesEcon\nusing Plots","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/#Part-1:-MIT-and-TSeries","page":"TimeSeriesEcon","title":"Part 1: MIT and TSeries","text":"","category":"section"},{"location":"Tutorials/TimeSeriesEcon/main/#Initialize-MITs-and-TSeries","page":"TimeSeriesEcon","title":"Initialize MITs and TSeries","text":"","category":"section"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"MIT (Moment-in-Time) is a primitive type based on 64-bit signed integers that  represents discrete dates. There are two ways to initialize  MITs: ","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"(1) directly 2020M8, or \n(2) using the functional form mm(2020, 8).","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"Internally, MIT contains Frequency information - more on this in the next section. ","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"mit_integer = 2000U  # ii(2000)\n\nmit_monthly = 2020M8 # mm(2020, 8)\n\nmit_quarterly = 2020Q3 # qq(2020, 3)\n\nmit_yearly = 2020Y  # yy(2020)","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"TSeries is subtype of AbstractVector and represents 1-dimensional time-series. A key feature of TSeries is the ability to use MITs as indices to get and set values. ","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"note: Note\nTSeries converts all values to Float64. The automatic conversion feature might be changed in the future.","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"series_monthly = TSeries(2020M1, rand(1:10, 6))","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"There are various ways to initialize TSeries - here, we provided an MIT that represents the first date in the series and a vector of random values.","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"As you can see, the frequency of MIT carries over to a TSeries instance.","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/#Frequency","page":"TimeSeriesEcon","title":"Frequency","text":"","category":"section"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"Every instance of MIT and TSeries is equipped with Frequency information, which is stored as a parameter.","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"frequencyof(2020M8)\nfrequencyof(series_monthly)","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"As such, we can avoid performing operations on TSeries or MITs of different frequencies. Also, having Frequency parameter simplifies the retrieval of frequency specific information.","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"year(2020M8)\nperiod(2020M8)\n\nppy(2020M8) # number of periods per year","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/#Part-2:-Indexing-using-MITs","page":"TimeSeriesEcon","title":"Part 2: Indexing using MITs","text":"","category":"section"},{"location":"Tutorials/TimeSeriesEcon/main/#Access","page":"TimeSeriesEcon","title":"Access","text":"","category":"section"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"Just as integers are used to index into Julia vectors, MITs are used to index into TSeries. ","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"Indexing using a single MIT returns a float value associated with that date.\nIndexing using a range of MITs will return another TSeries instance","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"series_monthly\n\nseries_monthly[2020M1]\nseries_monthly[2020M1:2020M3]","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/#Assign","page":"TimeSeriesEcon","title":"Assign","text":"","category":"section"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"series_monthly[2020M1] = -1;\nseries_monthly\n\nseries_monthly[2020M2:end] = -1;\nseries_monthly","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"You can also assign values outside of the bounds that were initially declared.","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"series_monthly[end + 2] = -1;\nseries_monthly","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/#Part-3:-Plots-and-helpful-functions","page":"TimeSeriesEcon","title":"Part 3: Plots and helpful functions","text":"","category":"section"},{"location":"Tutorials/TimeSeriesEcon/main/#Plotting-support","page":"TimeSeriesEcon","title":"Plotting support","text":"","category":"section"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"Using the Plots package, we can plot multiple TSeries with varying frequency.","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"plot(TSeries(2000Q1, rand(1:3, 10)), \n     TSeries(2000M1, rand(4:6, 30)),\n     legend=true, \n     title=\"TSeries Plot\", \n     labels=[\"Quarterly\", \"Monthly\"],\n     size=(600, 400)\n    );","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"savefig(\"tseries.png\")","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"(Image: TSeries Graph)","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/#Conversions","page":"TimeSeriesEcon","title":"Conversions","text":"","category":"section"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"note: Note\nSupport for frequency conversion from low to high is under development.","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"tsmonthly = TSeries(2020M1, collect(1:12));\n\n# Monthly -> Quarterly\ntsquarterly = convert(TSeries{Quarterly}, tsmonthly)\n\n# Monthly -> Yearly\ntsyearly = convert(TSeries{Yearly}, tsmonthly)","category":"page"},{"location":"DesignPapers/log_variables/#Log-variables","page":"Log-variables","title":"Log-variables","text":"","category":"section"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"This article describes the intended meaning of declaring a variable using the @log annotation, and the internal handling of such variables.","category":"page"},{"location":"DesignPapers/log_variables/#What-is-a-log-variable","page":"Log-variables","title":"What is a log-variable","text":"","category":"section"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"A variable should be declared using the @log annotation when its balanced growth path is exponential growth or decay. Specifically this means that","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"X_t = c X_t-1","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"for some c, which we call its slope. The balanced growth path forms a geometric sequence with common ratio c. The growth rate, let's call it r, is related to the slope as c = 1 + r.","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"This has implications to how we solve for the steady state of such variable and also to how we impose final conditions of type fcslope and fcnatural.","category":"page"},{"location":"DesignPapers/log_variables/#Implementation-details","page":"Log-variables","title":"Implementation details","text":"","category":"section"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"Internally we work with the log transformation of log variables. All equations and data provided by the user should be in terms of the declared variable. This log transformation is done internally, automatically, and should be completely transparent to the user.","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"It is not strictly necessary to use such transformation. However, this approach simplifies several aspects of the implementation. In addition, a log-variable is always positive and usually appears as argument to logarithms, fractional powers and division, which might produce domain errors if the argument becomes negative or zero, for example during the solver iterations. By working with the log of the variable, which is allowed to be any real number, we avoid such problems.","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"Applying this transformation affects the following parts of the implementation.","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"Transform the dynamic equations and their corresponding steady state equations.\nTransform the steady-state constraints.\nApply appropriate final conditions in the case of fcslope and fcnatural.\nTransform the linearization about a solution with log-variables.","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"We also need to transform the user provided data before running the solution algorithms and then transform the solution back by applying the inverse transformation before returning it to the user. This includes","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"initial conditions,\nexogenous data,\nsteady state solution,\nsimulation result,\ndata given in deviation from the steady state.","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"We address each of these in the remainder of this article.","category":"page"},{"location":"DesignPapers/log_variables/#Transformations-of-the-equations","page":"Log-variables","title":"Transformations of the equations","text":"","category":"section"},{"location":"DesignPapers/log_variables/#Dynamic-equations","page":"Log-variables","title":"Dynamic equations","text":"","category":"section"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"When a mention of a variable is encountered in an equation, we replace that mention by a new symbol whose name is made up from the name of the variable and the lag or lead value. For example, equation Y[t] = Y[t-1] + 0.1 becomes #Y#0# = #Y#-1# + 0.1, where #Y#0# and #Y#-1# are the new variable names corresponding to the contemporaneous and lag 1 values of Y.","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"When a variable is declared @log X, the new symbols created for the different lags have the meaning of the log of that variable. For example, equation X[t] / X[t-1] = 1.01 becomes exp(#logX#0#) / exp(#logX#-1#) = 1.01.","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"All we have to do from this point on is to make sure that the data values for these variables are transformed accordingly. In particular, there is no need to do anything about transforming the gradients of the equation residual functions, since they are automatically computed from the transformed equation by automatic differentiation.","category":"page"},{"location":"DesignPapers/log_variables/#Steady-state-equations-derived-from-dynamic-equations","page":"Log-variables","title":"Steady state equations derived from dynamic equations","text":"","category":"section"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"For regular variables we substitute","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"Yt = lvl_Y + (t-t_ref) * slp_Y","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"in the dynamic equations. t_ref is a reference time: time at which Y[t_ref] = lvl_Y. All lags and leads of Y are unknowns in the dynamic system, while here, in the steady state system, we have two unknowns, namely lvl_Y and slp_Y. For this reason, we take each equation at two different values of t.","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"In the case of @log X variable, we have the steady state substitution","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"Xt = exp(lvl_logX + (t-t_ref) * slp_logX)","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"Since the dynamic equations have already been transformed in terms of log(X[t]), we actually have to do the substitution","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"log(Xt) = lvl_logX + (t-t_ref) slp_logX","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"which is the same as for non-log variables. So once again we don't need to do anything to the equations, we only need to transform the data.","category":"page"},{"location":"DesignPapers/log_variables/#Steady-state-constraints","page":"Log-variables","title":"Steady state constraints","text":"","category":"section"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"Here we expect the user to provide equations in terms of the original meaning of the log-variable. When X is mentioned in a level type constraint, we replace it by exp(lvl_logX) and similarly in a slope type constraint we replace is by exp(slp_logX).","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"This works well when the constraint is simply assigning a known value. The user must keep in mind that we interpret the slope as the common ratio of the geometric sequence and provide values in these terms.","category":"page"},{"location":"DesignPapers/log_variables/#Final-conditions","page":"Log-variables","title":"Final conditions","text":"","category":"section"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"This is discussed at the end of the article on final conditions. TLDR: we don't need to do anything special since we're working with the log-transformed variables.","category":"page"},{"location":"DesignPapers/log_variables/#Linearization","page":"Log-variables","title":"Linearization","text":"","category":"section"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"TODO","category":"page"},{"location":"DesignPapers/log_variables/#Transforming-the-data","page":"Log-variables","title":"Transforming the data","text":"","category":"section"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"Every value of user-provided data for a log-variable we must apply log() before using it internally. Also, every value we compute for a log-variable, we must apply exp() before returning it to the user.","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"There is nothing special about this, we just have to make sure to do it.","category":"page"},{"location":"DesignPapers/log_variables/#Data-provided-in-deviation","page":"Log-variables","title":"Data provided in deviation","text":"","category":"section"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"TODO","category":"page"},{"location":"Tutorials/FRB-US/main/#FRB/US-with-VAR-based-Expectations","page":"FRB/US","title":"FRB/US with VAR-based Expectations","text":"","category":"section"},{"location":"Tutorials/FRB-US/main/#Getting-started","page":"FRB/US","title":"Getting started","text":"","category":"section"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"If you wish to run the code of this tutorial, or to experiment for yourself, make sure to follow the instructions in Introduction/Getting_started.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"using StateSpaceEcon\nusing ModelBaseEcon\nusing TimeSeriesEcon\n\nusing Test\nusing Plots\nusing Random\n\n# Fix the random seed for reproducibility.\nRandom.seed!(1234);\n\n# We need the model file FRBUS_VAR.jl to be on the search path for modules.\nunique!(push!(LOAD_PATH, realpath(\"./models\"))) # hide\n","category":"page"},{"location":"Tutorials/FRB-US/main/#The-Model-File","page":"FRB/US","title":"The Model File","text":"","category":"section"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"We recommend placing the model definition in its own Julia module in a separate source file. Although this is not strictly necessary, it helps to keep the code well organized and it also allows us to take advantage of pre-compilation. The first time we load the model file it takes some time to compile, and after that loading is much faster.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"The FRB/US model we will be working with is located in models/FRBUS_VAR.jl.  This file was automatically generated from the model.xml file contained within frbus_package.zip.","category":"page"},{"location":"Tutorials/FRB-US/main/#Some-Notes-About-the-Julia-Model-File","page":"FRB/US","title":"Some Notes About the Julia Model File","text":"","category":"section"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Some variables are declared as log variables using the @log declaration within a @variables block. For example\n@variables model begin\n    # ... #\n    \"Investment in equipment, current \\$\" @log ebfin\n    \"Personal consumption expenditures, current \\$ (NIPA definition)\" @log ecnian\n    # ... #\nend\nA full discussion of log variables is beyond the scope of this tutorial.  However a very simplified explanation is that this improves the stability of  the numerical solver for variables which are always positive.\nVariables which do not have an associated equation, and for which data is always given, are declared exogenous using an @exogenous block. For example\n@exogenous model begin\n    # Exogenous variables:\n    \"Potential government employment ratio (relative to business)\" adjlegrt\n    \"Dummy, post-1979 indicator\" d79a\n    \"Dummy, 1980-1995 indicator\" d8095\n    # ... #\nend\nThe EViews syntax is translated to Julia syntax. EViews functions d() and dlog() are replaced with their equivalent StateSpaceEcon meta functions @d() and @dlog(). EViews @movav() is left alone, because a meta function by the same name already exists in StateSpaceEcon, and does the same thing. Finally, the EViews @recode() is replaced with the equivalent Julia function ifelse(), or where appropriate with a min() or a max().\nSeveral equations contain expressions matching the pattern 1 / (1 + exp(-cx)), where c is a large constant (usually 25) and x is some expression. This sigmoid function is a smooth approximation of the Heaviside step function for large values of c. While mathematically the derivative of this function is well defined and converges to approximately zero everywhere outside a very small interval containing 0, numerically it causes problems because it results in either 0/0 or ∞/∞. To remedy this situation, we replace such patterns with equivalent calls to heaviside(cx), where the function heaviside() is defined in the model file.\nexport heaviside\n\"Heaviside step function\" @inline heaviside(x) = convert(typeof(x), x>zero(x))","category":"page"},{"location":"Tutorials/FRB-US/main/#Regenerating-the-Model-File","page":"FRB/US","title":"Regenerating the Model File","text":"","category":"section"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"We have included the script update_models.jl. It is not necessary for running the code below, but it may be helpful for further experimentation.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"If the model file is missing, for some reason or another, this script will automatically download frbus_package.zip and process the model.xml within it to re-generate model/FRBUS_VAR.jl. This could also be useful if you make modifications to model.xml (including not only the equations, but also the parameter values), or if you want to use a different FRBUS package from the one posted on the FRBUS website. In this case, simply place your frbus_package.zip in the models/ directory and run update_models.jl. Of course such modifications can also be done directly into the existing models/FRBUS_VAR.jl file.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Note that after updating models/FRBUS_VAR.jl, it'd be best to restart the REPL. The first time you load the new model module it'll take a bit longer due to pre-compilation.","category":"page"},{"location":"Tutorials/FRB-US/main/#Load-the-Model","page":"FRB/US","title":"Load the Model","text":"","category":"section"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Assuming that the models/ directory is already in the LOAD_PATH list, we can load the model by using its module. Once loaded, the module contains a variable model which represents the model object.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"using FRBUS_VAR\nm = FRBUS_VAR.model","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"We see that the model has a number of variables, shocks, equations, and parameters. The total number of variables include exogenous variables.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"m.variables","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"We also see that the model object includes a number of auxiliary equations. These equations (and variables) are automatically added as substitutions for expressions that must be positive.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"m.auxeqns","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"For example, we see that variable aux1 was added with the first equation in the above list. At the same time, in equation for dpgap, the expression log(phr[t] * pxp[t]) has been replaced by aux1[t].","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"m.equations[2]","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"A detailed discussion of auxiliary variables and equations is beyond the scope of this tutorial. It suffices to say that we can safely ignore their presence for now.","category":"page"},{"location":"Tutorials/FRB-US/main/#Load-the-Longbase-Data","page":"FRB/US","title":"Load the Longbase Data","text":"","category":"section"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Unfortunately the longbase data is available only in EViews format, which cannot be read automatically by open source software (at least to our knowledge). For convenience, here we have included the version of longbase from 23-07-2020 in a csv format and a function that loads that data. The function is defined in file load_longbase.jl. Note that this is not a module, so we load it by calling include(), not using.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"include(\"load_longbase.jl\")\nlongbase = load_longbase(\"longbase_23072020.csv\")\n@test size(longbase) == (834, 659) # hide","category":"page"},{"location":"Tutorials/FRB-US/main/#Load-set_policy.jl","page":"FRB/US","title":"Load set_policy.jl","text":"","category":"section"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"The model contains a number of switch variables to control which monetary policy function is used and which fiscal policy function is used at each period of the simulation. For convenience, we have included functions set_mp!() and set_fp!(), which are defined in set_policy.jl.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"include(\"set_policy.jl\")\n@doc set_mp!\n\ndmp_switches\n\n@doc set_fp!\n\ndfp_switches","category":"page"},{"location":"Tutorials/FRB-US/main/#Prepare-the-Simulation-Plan","page":"FRB/US","title":"Prepare the Simulation Plan","text":"","category":"section"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"The simulation is controlled by a Plan object. The plan is defined by a model object and a simulation range. The full range handled by the plan contains additional periods before and after the simulation range, which account for initial and final conditions. By default, the simulation plan is setup such that all shocks are exogenous and all variables are endogenous, except for the variables that are declared either in an @exogenous block or with the @exog declaration within an @variables block in the model file.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"sim = 2020Q1:2025Q4     # simulation range\np = Plan(m, sim)        # the plan object\n\nini = firstdate(p):first(sim) - 1      # range of initial conditions\nfin = last(sim) + 1:lastdate(p)        # range of final conditions","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Note that the fin range is actually empty. This is because this model doesn't have any leads.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"isempty(fin)","category":"page"},{"location":"Tutorials/FRB-US/main/#Prepare-the-Exogenous-Data","page":"FRB/US","title":"Prepare the Exogenous Data","text":"","category":"section"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"We start by pre-allocating simulation data that is set to 0 everywhere.  Then we assign within it the data from longbase using Julia's .= operator.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"ed = zerodata(m, p);\ned .= longbase[p.range];","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Next we set the monetary policy, the fiscal policy and a few other switches.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"# set monetary policy\nset_mp!(ed, :dmpintay);\n\n# turn off zero bound and policy thresholds;\n# hold policy maker's perceived equilibrium real interest rate\ned.dmptrsh .= 0.0;\ned.rffmin .= -9999;\ned.drstar .= 0.0;\n\n# set fiscal policy\nset_fp!(ed, :dfpsrp);\n\n@test all(sum(abs, ed[dmp_switches], dims=2) .== 1) # hide\n@test all(sum(abs, ed[dfp_switches], dims=2) .== 1) # hide\n","category":"page"},{"location":"Tutorials/FRB-US/main/#Back-out-the-Shocks","page":"FRB/US","title":"Back out the Shocks","text":"","category":"section"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"The first simulation test is to compute the shocks given the variable paths from longbase. To do this, we swap the variables and shocks, making variables exogenous and shocks endogenous. The mapping between variables and their corresponding shocks is declared in the model file, so we can simply call autoexogenize!. We make a copy of the plan p, so that the original plan would not be modified. We also make a copy of the exogenous data, ed, so that the original would remain unchanged.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"p_0 = autoexogenize!(copy(p), m, sim)\ned_0 = copy(ed)","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Now we run the simulate command. Note that the first time we run a function in Julia it takes a bit longer due to compilation time. In this case, it takes much longer because the model is very large and each and every equation gets compiled together with its automatic derivative.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"sol_0 = @time simulate(m, ed_0, p_0; verbose=true, tol=1e-12);\n@test sol_0[m.variables] ≈ ed[m.variables]","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"The compilation is done once and the compiled code is used in every call after that. So the second call to simulate is much, much faster.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"sol_0 = @time simulate(m, ed_0, p_0; verbose=true, tol=1e-12);","category":"page"},{"location":"Tutorials/FRB-US/main/#Recover-the-Baseline-Case","page":"FRB/US","title":"Recover the Baseline Case","text":"","category":"section"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Next simulation is a sanity check test. If we run a simulation with the shocks set to the values we just backed out, the resulting variable paths must match the ones we started with.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Once again we start with an exogenous data set everywhere to 0. Then we assign only the initial conditions and the shocks we just backed out.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"p_r = Plan(m, sim);\ned_r = zerodata(m, p_r);\n\n# initial conditions for the variables are taken from longbase\ned_r[ini, m.variables] = longbase[ini, m.variables];\n\n# shocks are taken from from sol_0\ned_r[p_r.range, m.shocks] = sol_0[p_r.range, m.shocks];\n\n# exogenous variables are also taken  from sol_0\nexogenous = m.variables[isexog.(m.variables)];\ned_r[p_r.range, exogenous] = sol_0[p_r.range, exogenous];","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Now, the only thing left is to set the initial guess for the endogenous variables. If we leave it at 0, that would be an initial guess too far from the solution and the Newton-Raphson will likely diverge. If we set it to the known solution, that would diminish this exercise to merely verifying that it is indeed a solution (we already know that). So, to make things a bit more interesting, we add a bit of noise to the true solution.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"endogenous = m.variables[.!isexog.(m.variables)];\ned_r[sim, endogenous] = longbase[sim, endogenous] .+ 0.03.*randn(length(sim), length(endogenous));","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Once again we have to set the monetary policy and the fiscal policy rules, as well as the values of some of the other switches.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"set_mp!(ed_r, :dmpintay);\ned_r.dmptrsh .= 0.0;\ned_r.rffmin .= -9999;\ned_r.drstar .= 0.0;\nset_fp!(ed_r, :dfpsrp);","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"And finally we can run the simulation and check to make sure that indeed the recovered simulation matches the base case.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"sol_r = @time simulate(m, ed_r, p_r, verbose=true, tol=1e-9);\n@test sol_r ≈ sol_0","category":"page"},{"location":"Tutorials/FRB-US/main/#Simulate-a-shock","page":"FRB/US","title":"Simulate a shock","text":"","category":"section"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"The last exercise is to simulate the impulse response to a unit shock in rffintay.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"m.rffintay","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"We start with the base case and add 1 to the rffintay_a shock at the first period of the simulation.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"p_1 = Plan(m, sim);\ned_1 = copy(sol_0);\n\ned_1.rffintay_a[first(sim)] += 1;\nsol_1 = @time simulate(m, ed_1, p_1;  verbose=true, tol=1e-9);\n","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Finally, we can plot the impulse response function to see what we've done.","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"# compute the differences between the base case and the shocked simulation.\ndd = hcat(SimData(p.range),\n    d_rff=sol_1.rff - sol_0.rff,\n    d_rg10=sol_1.rg10 - sol_0.rg10,\n    d_lur=sol_1.lur - sol_0.lur,\n    d_pic4=sol_1.pic4 - sol_0.pic4,\n);\n\n# produce the plot\nplot(dd[sim], vars=(:d_rff, :d_rg10, :d_lur, :d_pic4), \n     legend=false, size=(600, 400));","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"savefig(\"irf.png\")","category":"page"},{"location":"Tutorials/FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"(Image: Impulse Response Graph)","category":"page"},{"location":"Tutorials/LICENSE/","page":"-","title":"-","text":"BSD 3-Clause License","category":"page"},{"location":"Tutorials/LICENSE/","page":"-","title":"-","text":"Copyright (c) 2020, Bank of Canada All rights reserved.","category":"page"},{"location":"Tutorials/LICENSE/","page":"-","title":"-","text":"Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:","category":"page"},{"location":"Tutorials/LICENSE/","page":"-","title":"-","text":"Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.","category":"page"},{"location":"Tutorials/LICENSE/","page":"-","title":"-","text":"THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","category":"page"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon-Reference","page":"TimeSeriesEcon","title":"TimeSeriesEcon Reference","text":"","category":"section"},{"location":"Reference/TimeSeriesEcon/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"Modules = [TimeSeriesEcon]","category":"page"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.TimeSeriesEcon","page":"TimeSeriesEcon","title":"TimeSeriesEcon.TimeSeriesEcon","text":"TimeSeriesEcon\n\nThis package is part of the StateSpaceEcon ecosystem. TimeSeriesEcon.jl provides functionality to work with low-Frequency discrete macroeconomic time-series data.\n\nFrequencies (abstract type):\n\nUnit\nMonthly\nQuarterly\nYearly\n\nTypes:\n\nMIT{Frequency} (aka \"Moment In Time\")\na primitive type denoting monthly, quarterly, and yearly dates\nTSeries{Frequency}\nan AbstractVector that can be indexed using MIT\n\nFunctions:\n\nMIT Constructors/Functions\nmm(year::Int, period::Int): returns a monthly MIT type instance\nqq(year::Int, period::Int): returns a quarterly MIT type instance\nyy(year::Int): returns a yearly MIT type instance\nii(x::Int): returns a unit MIT type instance\nyear(x::MIT): returns a Int64 year value associated with x\nperiod(x::MIT): returns a Int64 period value associated with x\nfrequencyof(x::MIT): returns <: Frequency assosicated wtih x\n\nFunctions operating on TSeries\nmitrange(x::TSeries): returns a UnitRange{MIT{Frequency}} for the given x\nfirstdate(x::TSeries): returns MIT{Frequency} first date associated with x  \nlastdate(x::TSeries): returns MIT{Frequency} last date associated with x\nppy(x::TSeries): returns the number of periods per year for x::TSeries. (ppy also accepts x::MIT and x::Frequency) \nshift(x::TSeries, i::Int64): shifts the dates of x by firstdate(x) - i\nshift!: in-place version of shift\npct(x::TSeries, shift_value::Int64; islog::Bool = false): calculates percent rate of change of x::TSeries\napct(x::TSeries, islog::Bool = false): calculates annualized percent rate of change of x::TSeries\nnanrm!(x::TSeries, type::Symbol=:both): removes NaN from x::TSeries\n\n\n\n\n\n","category":"module"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.Frequency","page":"TimeSeriesEcon","title":"TimeSeriesEcon.Frequency","text":"Frequency\n\nFrequency is an abstract type. \n\nMonthly, Quarterly, Yearly, Unit abstract types are subtypes of Frequency.\n\nExamples\n\njulia> Quarterly <: Frequency\ntrue\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.MIT","page":"TimeSeriesEcon","title":"TimeSeriesEcon.MIT","text":"MIT{Frequency}(x::Int64)\n\nMIT is a primitive type (Signed 64) representing a discrete date.\n\nNote: Please use yy, qq, 'mm', ii to instantiate MITs.  MITs are mainly used internally for the package development.\n\nExamples\n\njulia> MIT{Yearly}(2000)\n2000Y\njulia> MIT{Monthly}(2020*12 + 3)\n2020M4\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.Monthly","page":"TimeSeriesEcon","title":"TimeSeriesEcon.Monthly","text":"Monthly\n\nSee also: Frequency ```\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.Quarterly","page":"TimeSeriesEcon","title":"TimeSeriesEcon.Quarterly","text":"Quarterly\n\nSee also: Frequency ```\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.TSeries","page":"TimeSeriesEcon","title":"TimeSeriesEcon.TSeries","text":"struct TSeries{Frequency} <: AbstractVector{Float64}\n\nData structure representing a time-series vector. The following  operations are allowed:\n\nindexing using MIT (aka \"moment-in-time\") and UnitRange{MIT}\nassignment using MIT and UnitRange{MIT}\n\nIn addition, most of the operations available to Julia vectors (+, -, *, etc.) are supported by TSeries as well.\n\nExamples\n\nCreate TSeries\n\njulia> x = TSeries(qq(2020, 1), ones(4))\nTSeries{Quarterly} of length 4\n2020Q1: 1.0\n2020Q2: 1.0\n2020Q3: 1.0\n2020Q4: 1.0\n\nIndex into TSeries\n\njulia> x[qq(2020, 1)]\n1.0\n\njulia> x[qq(2020, 1):qq(2020, 2)]\nTSeries{Quarterly} of length 2\n2020Q1: 1.0\n2020Q2: 1.0\n\nAssignment using MIT\n\njulia> x[qq(2020, 1)] = 100; x\nTSeries{Quarterly} of length 4\n2020Q1: 100.0\n2020Q2: 1.0\n2020Q3: 1.0\n2020Q4: 1.0\n\njulia> x[qq(2020, 1):qq(2020, 2)] = 100; x\nTSeries{Quarterly} of length 4\n2020Q1: 100.0\n2020Q2: 100.0\n2020Q3: 1.0\n2020Q4: 1.0\n\nArithmetic Operations on TSeries\n\njulia> x = TSeries(qq(2020, 1), ones(4))\nTSeries{Quarterly} of length 4\n2020Q1: 1.0\n2020Q2: 1.0\n2020Q3: 1.0\n2020Q4: 1.0\n\njulia> 2*x + 98\nTSeries{Quarterly} of length 4\n2020Q1: 100.0\n2020Q2: 100.0\n2020Q3: 100.0\n2020Q4: 100.0\n\njulia> log(exp(x))\nTSeries{Quarterly} of length 4\n2020Q1: 1.0\n2020Q2: 1.0\n2020Q3: 1.0\n2020Q4: 1.0\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.Unit","page":"TimeSeriesEcon","title":"TimeSeriesEcon.Unit","text":"Unit\n\nSee also: Frequency ```\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.Yearly","page":"TimeSeriesEcon","title":"TimeSeriesEcon.Yearly","text":"Yearly\n\nSee also: Frequency ```\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#Base.:*-Union{Tuple{T}, Tuple{TSeries{T,C} where C<:AbstractArray{Float64,1},Number}} where T<:Frequency","page":"TimeSeriesEcon","title":"Base.:*","text":"3 * ts\nts * 3 returns timeseries with every element multiplied by 3\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#Base.:/-Union{Tuple{T}, Tuple{TSeries{T,C} where C<:AbstractArray{Float64,1},Number}} where T<:Frequency","page":"TimeSeriesEcon","title":"Base.:/","text":"ts / 3 returns timeseries with every element divided by 3\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#Base.diff-Union{Tuple{TSeries{T,C} where C<:AbstractArray{Float64,1}}, Tuple{T}, Tuple{TSeries{T,C} where C<:AbstractArray{Float64,1},Int64}} where T<:Frequency","page":"TimeSeriesEcon","title":"Base.diff","text":"diff(x::TSeries, k::Int64 = -1)\n\nSame as Iris implementation of diff\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#Base.getindex-Union{Tuple{T}, Tuple{TSeries{T,C} where C<:AbstractArray{Float64,1},AbstractArray{MIT{T},1}}} where T<:Frequency","page":"TimeSeriesEcon","title":"Base.getindex","text":"getindex using Vector{MIT}. Note the difference between Vector{MIT} and UnitRange{MIT}\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#Base.getindex-Union{Tuple{T}, Tuple{TSeries{T,C} where C<:AbstractArray{Float64,1},AbstractUnitRange{MIT{T}}}} where T<:Frequency","page":"TimeSeriesEcon","title":"Base.getindex","text":"getindex using UnitRange{MIT}\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#Base.getindex-Union{Tuple{T}, Tuple{TSeries{T,C} where C<:AbstractArray{Float64,1},MIT{T}}} where T<:Frequency","page":"TimeSeriesEcon","title":"Base.getindex","text":"getindex using MIT\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#Base.hcat-Union{Tuple{Vararg{TSeries{T,C} where C<:AbstractArray{Float64,1},N}}, Tuple{T}, Tuple{N}} where T<:Frequency where N","page":"TimeSeriesEcon","title":"Base.hcat","text":"Horizonatal Concatenation of `TSeries`\n\nExamples\n\njulia> a = TSeries(ii(1), ones(3));\njulia> b = TSeries(ii(2), ones(3));\njulia> [a b]\n4×2 Array{Float64,2}:\n   1.0  NaN\n   1.0    1.0\n   1.0    1.0\n NaN      1.0\n\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#Base.setindex!-Union{Tuple{T}, Tuple{TSeries{T,C} where C<:AbstractArray{Float64,1},AbstractArray{#s13,1} where #s13<:Number,AbstractUnitRange{MIT{T}}}} where T<:Frequency","page":"TimeSeriesEcon","title":"Base.setindex!","text":"setindex a vector using UnitRange{MIT}\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#Base.setindex!-Union{Tuple{T}, Tuple{TSeries{T,C} where C<:AbstractArray{Float64,1},Number,AbstractUnitRange{MIT{T}}}} where T<:Frequency","page":"TimeSeriesEcon","title":"Base.setindex!","text":"setindex a value using UnitRange{MIT}\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#Base.setindex!-Union{Tuple{T}, Tuple{TSeries{T,C} where C<:AbstractArray{Float64,1},Number,MIT{T}}} where T<:Frequency","page":"TimeSeriesEcon","title":"Base.setindex!","text":"setindex a value using MIT\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#Base.setindex!-Union{Tuple{T}, Tuple{TSeries{T,C} where C<:AbstractArray{Float64,1},TSeries{T,C} where C<:AbstractArray{Float64,1},AbstractUnitRange{MIT{T}}}} where T<:Frequency","page":"TimeSeriesEcon","title":"Base.setindex!","text":"setindex values from other TSeries using UnitRange{MIT}\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#Base.setindex!-Union{Tuple{T}, Tuple{TSeries{T,C} where C<:AbstractArray{Float64,1},TSeries{T,C} where C<:AbstractArray{Float64,1},MIT{T}}} where T<:Frequency","page":"TimeSeriesEcon","title":"Base.setindex!","text":"setindex values from other TSeries using MIT\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.apct","page":"TimeSeriesEcon","title":"TimeSeriesEcon.apct","text":"apct(x::TSeries, islog::Bool)\n\nCalculate annualised percent rate of change in x.\n\nNote: The implementation is similar to IRIS.\n\nExamples\n\njulia> x = TSeries(qq(2018, 1), Vector(1:8));\n\njulia> apct(x)\nTSeries{Quarterly} of length 7\n2018Q2: 1500.0\n2018Q3: 406.25\n2018Q4: 216.04938271604937\n2019Q1: 144.140625\n2019Q2: 107.35999999999999\n2019Q3: 85.26234567901243\n2019Q4: 70.59558517284461\n\nSee also: pct\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.firstdate-Tuple{TSeries}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.firstdate","text":"firstdate(x::TSeries)\n\nReturn an MIT indicating the first date in the TSeries.\n\nExamples\n\njulia> firstdate(TSeries(qq(2020, 1), ones(10)))\n2020Q1\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.frequencyof-Tuple{Any}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.frequencyof","text":"frequencyof(::MIT)\nfrequencyof(::Type{MIT})\n\nReturn the Frequency type of the given MIT instance of type.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.frequencyof-Union{Tuple{TSeries{T,C} where C<:AbstractArray{Float64,1}}, Tuple{T}} where T<:Frequency","page":"TimeSeriesEcon","title":"TimeSeriesEcon.frequencyof","text":"Can be applied to a TSeries instance or a range of MIT to return its Frequency.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.ii-Tuple{Int64}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.ii","text":"ii(x::Int64)\n\nRepresents an Integer date and return MIT{Unit} type instance\n\nExamples\n\njulia> ii(123)\nii(123)\n\njulia> ii(123) + 5\nii(128)\n\njulia> typeof(ii(123))\nMIT{Unit}\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.lastdate-Tuple{TSeries}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.lastdate","text":"lastdate(x::TSeries)\n\nReturn an MIT indicating the last date in the TSeries.\n\nExamples\n\njulia> lastdate(TSeries(qq(2020, 1), ones(10)))\n2022Q2\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.leftcropnan!-Tuple{TSeries}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.leftcropnan!","text":"leftcropnan!(x::TSeries)\n\nRemove NaN values from starting at the beginning of x, in-place.\n\nNote: an internal function.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.mitrange-Tuple{TSeries}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.mitrange","text":"mitrange(x::TSeries)\n\nReturn an UnitRange{MIT{<:Frequency}} associated with x.\n\nExamples\n\njulia> mitrange(TSeries(qq(2020, 1), ones(4)))\n2020Q1:2020Q4\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.mm-Tuple{Any,Any}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.mm","text":"mm(y::Int64, p::Int64)\n\nRepresents a Monthly date and returns MIT{Monthly} type instance.\n\nExamples\n\njulia> mm(2020, 1)\n2020M1\n\njulia> mm(2020, 1) + 5\n2020M6\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.nanrm!","page":"TimeSeriesEcon","title":"TimeSeriesEcon.nanrm!","text":"nanrm!(s::TSeries, type::Symbol)\n\nRemove NaN values that are either at the beginning of the s and/or end of x.\n\nExamples\n\njulia> s = TSeries(yy(2018), [NaN, NaN, 1, 2, NaN]);\n\njulia> nanrm!(s);\n\njulia> s\nTSeries{Yearly} of length 2\n2020Y: 1.0\n2021Y: 2.0\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.pct-Tuple{TSeries,Int64}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.pct","text":"pct(x::TSeries, shift_value::Int64, islog::Bool)\n\nCalculate percentage growth in x given a shift_value.\n\nNote: The implementation is similar to IRIS.\n\nExamples\n\njulia> x = TSeries(yy(2000), Vector(1:4));\n\njulia> pct(x, -1)\nTSeries{Yearly} of length 3\n2001Y: 100.0\n2002Y: 50.0\n2003Y: 33.33333333333333\n\nSee also: apct\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.period-Union{Tuple{MIT{T}}, Tuple{T}} where T<:Frequency","page":"TimeSeriesEcon","title":"TimeSeriesEcon.period","text":"period(x::MIT)\n\nReturn ::Int64 representing period for a given MIT\n\nExamples\n\njulia> period(mm(2020, 1))\n1\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.ppy-Union{Tuple{MIT{F}}, Tuple{F}} where F<:Frequency","page":"TimeSeriesEcon","title":"TimeSeriesEcon.ppy","text":"ppy(::MIT)\nppy(::Type{MIT})\n\nWhen applied to an MIT instance or type, return the ppy of its frequency.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.ppy-Union{Tuple{TSeries{T,C} where C<:AbstractArray{Float64,1}}, Tuple{T}} where T<:Frequency","page":"TimeSeriesEcon","title":"TimeSeriesEcon.ppy","text":"ppy(::TSeries)\nppy(::Type{TSeries})\n\nWhen applied to a TSeries instance or type, return the ppy of its frequency.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.ppy-Union{Tuple{Type{T}}, Tuple{T}} where T<:Monthly","page":"TimeSeriesEcon","title":"TimeSeriesEcon.ppy","text":"ppy(::Frequency)\n\nReturns the number of periods per year for a given Frequency, MIT, and TSeries\n\nExamples\n\njulia> ppy(Quarterly)                   # Frequency\n4\n\njulia> ppy(mm(2020, 1))                 # MIT\n12\n\njulia> ppy(TSeries(yy(2020), ones(3)))   # TSeries\n1\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.qq-Tuple{Any,Any}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.qq","text":"qq(y::Int64, p::Int64)\n\nRepresents a Quarterly date and returns MIT{Quarterly} type instance.\n\nExamples\n\njulia> qq(2020, 1)\n2020Q1\n\njulia> qq(2020, 1) + 5\n2021Q2\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.rightcropnan!-Tuple{TSeries}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.rightcropnan!","text":"rightcropnan!(x::TSeries)\n\nRemove NaN values from the end of x\n\nNote: an internal function.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.shift!-Union{Tuple{T}, Tuple{TSeries{T,C} where C<:AbstractArray{Float64,1},Int64}} where T<:Frequency","page":"TimeSeriesEcon","title":"TimeSeriesEcon.shift!","text":"shift!(x::TSeries, n::Int64)\n\nShift dates of x back by k periods, in-place.  Note: The implementation of is similar to IRIS ts{1}.\n\nExamples\n\njulia> x = TSeries(qq(2020, 1), ones(4));\n\njulia> shift!(x, 1);\n\njulia> x\nTSeries{Quarterly} of length 4\n2019Q4: 1.0\n2020Q1: 1.0\n2020Q2: 1.0\n2020Q3: 1.0\n\nSee also: shift\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.shift-Union{Tuple{T}, Tuple{TSeries{T,C} where C<:AbstractArray{Float64,1},Int64}} where T<:Frequency","page":"TimeSeriesEcon","title":"TimeSeriesEcon.shift","text":"shift(x::TSeries, n::Int64)\n\nShift dates of x back by k periods.  Note: The implementation of is similar to IRIS ts{1}.\n\nExamples\n\njulia> shift(TSeries(qq(2020, 1), ones(4)), 1)\nTSeries{Quarterly} of length 4\n2019Q4: 1.0\n2020Q1: 1.0\n2020Q2: 1.0\n2020Q3: 1.0\n\n\njulia> shift(TSeries(qq(2020, 1), ones(4)), -1)\nTSeries{Quarterly} of length 4\n2020Q2: 1.0\n2020Q3: 1.0\n2020Q4: 1.0\n2021Q1: 1.0\n\nSee also: shift!\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.year-Union{Tuple{MIT{T}}, Tuple{T}} where T<:Frequency","page":"TimeSeriesEcon","title":"TimeSeriesEcon.year","text":"year(x::MIT)\n\nReturn ::Int64 representing year for a given MIT\n\nNote: an internal method for now.\n\nExamples\n\njulia> year(mm(2020, 1))\n2020\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.yy","page":"TimeSeriesEcon","title":"TimeSeriesEcon.yy","text":"yy(y::Int64)\n\nRepresents a Yearly date and returns MIT{Yearly} type instance.\n\nExamples\n\njulia> yy(2020)\n2020Y\n\njulia> yy(2020) + 5\n2025Y\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.@rec-Tuple{Any,Any}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.@rec","text":"@rec(eqn, rng)\n\nComputes recursive calculations for the given eqn and rng.\n\nExamples\n\njulia> s = TSeries(ii(1), zeros(1));\n\njulia> # Initial values\n\njulia> s[ii(1)] = 0;\n\njulia> s[ii(2)] = 1;\n\njulia> @rec s[t] = s[t-1] + s[t-2] ii(3):ii(10)\n\njulia> s\nTSeries{Unit} of length 10\nii(1): 0.0\nii(2): 1.0\nii(3): 1.0\nii(4): 2.0\nii(5): 3.0\nii(6): 5.0\nii(7): 8.0\nii(8): 13.0\nii(9): 21.0\nii(10): 34.0\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon-Reference","page":"ModelBaseEcon","title":"ModelBaseEcon Reference","text":"","category":"section"},{"location":"Reference/ModelBaseEcon/","page":"ModelBaseEcon","title":"ModelBaseEcon","text":"Pages = [\"modelbaseecon.md\"]","category":"page"},{"location":"Reference/ModelBaseEcon/#Options","page":"ModelBaseEcon","title":"Options","text":"","category":"section"},{"location":"Reference/ModelBaseEcon/","page":"ModelBaseEcon","title":"ModelBaseEcon","text":"Modules = [ModelBaseEcon.OptionsMod]\nPrivate = false","category":"page"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.OptionsMod","page":"ModelBaseEcon","title":"ModelBaseEcon.OptionsMod","text":"OptionsMod\n\nSub-module of ModelBaseEcon, although it can be used independently. Implements the Options data structure.\n\nContents\n\nOptions\ngetoption - read the value of an option\ngetoption! - if not present, also create an option\nsetoption! - create or update the value of an option \n\n\n\n\n\n","category":"module"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.OptionsMod.Options","page":"ModelBaseEcon","title":"ModelBaseEcon.OptionsMod.Options","text":"Options\n\nA collection of key-value pairs representing the options controlling the behaviour or the definition of a Model object. The key is the option name and is always a Symbol, or converted to Symbol, while the value can be anything.\n\nThe options can be accessed using dot notation. Functions getoption and setoption! are also provided. They can be used for programmatic processing of options as well as when the option name is not a valid Julia identifier.\n\nSee also: Options, getoption, getoption!, setoption!\n\nExamples\n\njulia> o = Options(maxiter=20, tol=1e-7)\nOptions:\n    maxiter=20\n    tol=1.0e-7\n\njulia> o.maxiter = 25\n25\n\njulia> o\nOptions:\n    maxiter=25\n    tol=1.0e-7\n\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.OptionsMod.Options-Tuple{Options}","page":"ModelBaseEcon","title":"ModelBaseEcon.OptionsMod.Options","text":"Options(::Options)\n\nConstruct an Options instance as an exact copy of an existing instance.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.OptionsMod.Options-Tuple{}","page":"ModelBaseEcon","title":"ModelBaseEcon.OptionsMod.Options","text":"Options(key=value, ...)\nOptions(:key=>value, ...)\n\nConstruct an Options instance with key-value pairs given as keyword arguments or as a list of pairs. If the latter is used, each key must be a Symbol.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.OptionsMod.getoption","page":"ModelBaseEcon","title":"ModelBaseEcon.OptionsMod.getoption","text":"getoption(o::Options; name=default [, name=default, ...])\ngetoption(o::Options, name, default)\n\nRetrieve the value of an option or a set of options.  The provided defaults are used when the option doesn't exit.\n\nThe return value is the value of the option requested or, if the option doesn't exist, the default. In the first version of the function, if there are more than one options requested, the return value is a tuple.\n\nIn the second version, the name could be a symbol or a string, which can be helpful if the name of the option is not a valid identifier.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.OptionsMod.getoption!","page":"ModelBaseEcon","title":"ModelBaseEcon.OptionsMod.getoption!","text":"getoption!(o::Options; name=default [, name=default, ...])\ngetoption!(o::Options, name, default)\n\nRetrieve the value of an option or a set of options. If the name does not match an existing option, the Options instance is updated by inserting the given name and default value.\n\nThe return value is the value of the option requested (or the default). In the first version of the function, if there are more than one options requested, the return value is a tuple.\n\nIn the second version, the name could be a symbol or a string, which can be helpful if the name of the option is not a valid identifier.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.OptionsMod.setoption!","page":"ModelBaseEcon","title":"ModelBaseEcon.OptionsMod.setoption!","text":"setoption!(o::Options; name=default [, name=default, ...])\nsetoption!(o::Options, name, default)\n\nRetrieve the value of an option or a set of options. If the name does not match an existing option, the Options instance is updated by inserting the given name and default value.\n\nThe return value is the value of the option requested (or the default). In the first version of the function, if there are more than one options requested, the return value is a tuple.\n\nIn the second version, the name could be a symbol or a string, which can be helpful if the name of the option is not a valid identifier.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#Timer","page":"ModelBaseEcon","title":"Timer","text":"","category":"section"},{"location":"Reference/ModelBaseEcon/","page":"ModelBaseEcon","title":"ModelBaseEcon","text":"Modules = [ModelBaseEcon.Timer]\nPrivate = false","category":"page"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Timer","page":"ModelBaseEcon","title":"ModelBaseEcon.Timer","text":"Timer\n\nA sub-module of ModelBaseEcon, although it can be used independently. Provides functionality for measuring the aggregate time spent in individual lines or blocks of code.\n\ntip: Tip\nThe implementation here is quick-and-dirty and is intended for getting a rough idea of where the bottlenecks are. It is best used for timing blocks of code that are passed through relatively few times and each pass takes a relatively long time. In the opposite extreme case (fast code that is called many times), the current implementation of @timer might add extreme overhead.\n\nContents\n\ninittimer       - Enable collection of timer data.\nstoptimer       - Disable collection of timer data.\nprinttimer      - Display timer data.\n@timer          - Measure the runtime taken by the given code.\n\nExample\n\njulia> true\n[...]\n\n\n\n\n\n","category":"module"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Timer.inittimer-Tuple{}","page":"ModelBaseEcon","title":"ModelBaseEcon.Timer.inittimer","text":"inittimer()\n\nEnable the collection of timing data. Existing timing data is lost. By default, collection of timing data is disabled.\n\nSee also: stoptimer, @timer, printtimer\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Timer.printtimer","page":"ModelBaseEcon","title":"ModelBaseEcon.Timer.printtimer","text":"printtimer(io::IO=Base.stdout)\n\nDisplay timing data.\n\nTiming data is displayed in a table with each row containing the number of calls, total time in seconds, and the source line or block tag. Rows are sorted in order of decreasing total time.\n\nSee also: @timer\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Timer.stoptimer-Tuple{}","page":"ModelBaseEcon","title":"ModelBaseEcon.Timer.stoptimer","text":"stoptimer()\n\nDisable the collection of timing data. Existing data is lost. By default, collection of timing data is disabled.\n\nSee also: inittimer, @timer, printtimer\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Timer.@timer-Tuple","page":"ModelBaseEcon","title":"ModelBaseEcon.Timer.@timer","text":"@timer(code)\n@timer(tag::String, code)\n\nMeasure the number of calls and the total time taken by the given code.\n\nIf a tag string is not provided, one is generated from the source file and line. The return value of this macro call is the return value of the code.\n\nwarning: Warning\nImportant limitation is that the code must not contain a return, break, continue, or any other jump out of it. If it does, the program would run correctly, but the timing data collected would be incorrect.\n\nSee also: inittimer, stoptimer, printtimer\n\nExample\n\njulia> inittimer()\n\njulia> @timer Base.sleep(1.0)\n\njulia> printtimer()\n[...]\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon","page":"ModelBaseEcon","title":"ModelBaseEcon","text":"","category":"section"},{"location":"Reference/ModelBaseEcon/","page":"ModelBaseEcon","title":"ModelBaseEcon","text":"Modules = [ModelBaseEcon]\nPrivate = false","category":"page"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.ModelBaseEcon","page":"ModelBaseEcon","title":"ModelBaseEcon.ModelBaseEcon","text":"ModelBaseEcon\n\nThis package is part of the StateSpaceEcon ecosystem.  It contains the basic elements needed for model definition. StateSpaceEcon works with model objects defined with ModelBaseEcon.\n\n\n\n\n\n","category":"module"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Equation","page":"ModelBaseEcon","title":"ModelBaseEcon.Equation","text":"struct Equation <: AbstractEquation\n\nData structure representing a single equation in our state space model.\n\nMethods (for users)\n\nTODO\n\nImplementation (for developers)\n\nDuring the phase of definition of the Model, this type simply stores the expression entered by the user. During @initialize(), the true data structure is constructed. We need this, because the construction of the equation requaires information from the Model object, which may not be available at the time the equation expression is first read.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.LinearizationError","page":"ModelBaseEcon","title":"ModelBaseEcon.LinearizationError","text":"LinearizationError <: ModelErrorBase\n\nA concrete error type used when a model cannot be linearized for some reason.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.LogTransform","page":"ModelBaseEcon","title":"ModelBaseEcon.LogTransform","text":"LogTransform <: Transformation\n\nThe log transformation. The inverse is of course exp. This is the default for variables declared with @log.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Model","page":"ModelBaseEcon","title":"ModelBaseEcon.Model","text":"Model <: AbstractModel\n\nData structure that represents a macroeconomic state space model.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.ModelError","page":"ModelBaseEcon","title":"ModelBaseEcon.ModelError","text":"struct ModelError <: ModelErrorBase\n\nConcrete error type used when no specific error description is available.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.ModelErrorBase","page":"ModelBaseEcon","title":"ModelBaseEcon.ModelErrorBase","text":"ModelErrorBase\n\nAbstract error type, base for specific error types used in ModelBaseEcon.\n\nImplementation (note for developers)\n\nWhen implementing a derived error type, override two functions:\n\nmsg(e::SomeModelError) returning a string with the error message;\nhint(e::SomeModelError) returning a string containing a suggestion of how to fix the problem. Optional, if not implemented for a type, the fallback implementation returns an empty string.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.ModelNotInitError","page":"ModelBaseEcon","title":"ModelBaseEcon.ModelNotInitError","text":"struct ModelNotInitError <: ModelErrorBase\n\nSpecific error type used when there's an attempt to use a Model object that has not been initialized.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.ModelParam","page":"ModelBaseEcon","title":"ModelBaseEcon.ModelParam","text":"mutable struct ModelParam\n\nContains a model parameter. For a simple parameter it simply stores its value. For a link or an alias, it stores the link information and also caches the current value for speed.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.NegLogTransform","page":"ModelBaseEcon","title":"ModelBaseEcon.NegLogTransform","text":"NegLogTransform <: Transformation\n\nThe log(-x), with the inverse being -exp(x). Use this when the variable is negative with exponential behaviour (toward -∞).\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.NoTransform","page":"ModelBaseEcon","title":"ModelBaseEcon.NoTransform","text":"NoTransform <: Transformation\n\nThe identity transformation.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.NotImplementedError","page":"ModelBaseEcon","title":"ModelBaseEcon.NotImplementedError","text":"struct NotImplementedError <: ModelErrorBase\n\nSpecific error type used when a feature is planned but not yet implemented. \n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Parameters","page":"ModelBaseEcon","title":"ModelBaseEcon.Parameters","text":"struct Parameters <: AbstractDict{Symbol, Any}\n\nContainer for model parameters. It functions as a Dict where the keys are the parameter names. Simple parameter values are stored directly. Special parameters depend on other parameters are are wrapped in the appropriate data structures to keep track of such dependencies. There are two types of special parameters - aliases and links.\n\nIndividual parameters can be accessed in two different ways - dot and bracket notation.\n\nRead access by dot notation calls peval while bracket notation doesn't. This makes no difference for simple parameters. For special parameters, access by bracket notation returns its internal structure, while access by dot notation returns its current value depending on other parameters.\n\nWrite access is the same in both dot and bracket notation. The new parameter value is assigned directly in the case of simple parameter. To create an alias parameter, use the @alias macro. To create a link parameter use the @link macro.\n\nSee also: ModelParam, peval, @alias, @link, update_links!.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Parameters-2","page":"ModelBaseEcon","title":"ModelBaseEcon.Parameters","text":"Parameters([mod::Module])\n\nWhen creating an instance of Parameters, optionally one can specify the module in which parameter expressions will be evaluated. This only matters if there are any link parameters that depend on custom functions or global variables/constants. In this case, the mod argument should be the module in which these definitions exist.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.SteadyStateData","page":"ModelBaseEcon","title":"ModelBaseEcon.SteadyStateData","text":"SteadyStateData\n\nData structure that holds information about the steady state solution of the Model.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.SteadyStateEquation","page":"ModelBaseEcon","title":"ModelBaseEcon.SteadyStateEquation","text":"struct SteadyStateEquation <: AbstractEquation\n\nData structure representing an individual steady state equation.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Transformation","page":"ModelBaseEcon","title":"ModelBaseEcon.Transformation","text":"abstract type Transformation end\n\nThe base class for all variable transformations.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.alleqns-Tuple{SteadyStateData}","page":"ModelBaseEcon","title":"ModelBaseEcon.alleqns","text":"alleqns(ssd::SteadyStateData)\n\nReturn a list of all steady state equations.\n\nThe list contains all equations derived from the dynamic system and all explicitly added steady state constraints.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.eval_R!","page":"ModelBaseEcon","title":"ModelBaseEcon.eval_R!","text":"eval_R!(res::AbstractArray{Float64,1}, point::AbstractArray{Float64, 2}, ::MED) where MED <: AbstractModelEvaluationData\n\nEvaluate the model residual at the given point using the given model evaluation structure. The residual is stored in the provided vector.\n\nImplementation details (for developers)\n\nWhen creating a new type of model evaluation data, you must define a method of this function specialized to it.\n\nThe point argument will be a 2d array, with the number of rows equal to maxlag+maxlead+1 and the number of columns equal to the number of variables+shocks+auxvars of the model. The res vector will have the same length as the number of equations + auxiliary equations.  Your implementation must not modify point and must update res.\n\nSee also: eval_RJ\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.eval_RJ","page":"ModelBaseEcon","title":"ModelBaseEcon.eval_RJ","text":"eval_RJ(point::AbstractArray{Float64, 2}, ::MED) where MED <: AbstractModelEvaluationData\n\nEvaluate the model residual and its Jacobian at the given point using the given model evaluation structure. Return a tuple, with the first element being the residual and the second element being the Jacobian.\n\nImplementation details (for developers)\n\nWhen creating a new type of model evaluation data, you must define a method of this function specialized to it.\n\nThe point argument will be a 2d array, with the number of rows equal to maxlag+maxlead+1 and the number of columns equal to the number of variables+shocks+auxvars of the model. Your implementation must not modify point and must return the tuple of (residual, Jacobian) evaluated at the given point. The Jacobian is expected to be SparseMatrixCSC (this might change in the future).\n\nSee also: eval_R!\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.export_model","page":"ModelBaseEcon","title":"ModelBaseEcon.export_model","text":"export_model(model, name, file::IO)\nexport_model(model, name, path::String)\n\nExport the model into a module file. The name parameter is used for the name of the module as well as the module file. The module file is created in the directory specified by the optional third argument.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.geteqn-Tuple{Integer,SteadyStateData}","page":"ModelBaseEcon","title":"ModelBaseEcon.geteqn","text":"geteqn(i, ssd::SteadyStateData)\n\nReturn the i-th steady state equation. Index i is interpreted as in the output of alleqns. Calling geteqn(i, sdd) has the same effect as alleqn(ssd)[i], but it's more efficient.\n\nExample\n\n# Iterate all equations like this:\nfor i = 1:neqns(ssd)\n    eqn = geteqn(i, ssd)\n    # do something awesome with `eqn` and `i`\nend\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.inverse_transformation","page":"ModelBaseEcon","title":"ModelBaseEcon.inverse_transformation","text":"inverse_transformation(::Type{<:Transformation})\n\nReturn a Function that will be called to transform the simulation data after solving. See also transformation.\n\nIt is expected that transformation(T) ∘ inverse_transformation(T) == identity and inverse_transformation(T) ∘ transformation(T) == identity, but these is not verified.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.islinearized-Tuple{Model}","page":"ModelBaseEcon","title":"ModelBaseEcon.islinearized","text":"islinearized(m::Model)\n\nReturn true if the given model is linearized and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.issssolved-Tuple{SteadyStateData}","page":"ModelBaseEcon","title":"ModelBaseEcon.issssolved","text":"issssolved(sstate::SteadyStateData)\n\nReturn true if the steady state has been solved, or false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.linearize!","page":"ModelBaseEcon","title":"ModelBaseEcon.linearize!","text":"linearize!(model::Model; <keyword arguments>)\n\nTransform model into its linear approximation about its steady state.\n\nKeyword arguments\n\nsstate - linearize about the provided steady state solution\ndeviation::Bool - whether or not the linearized model will tread data passed \n\nto is as deviation from the steady state\n\nSee also: linearized and with_linearized\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.linearized-Tuple{Model}","page":"ModelBaseEcon","title":"ModelBaseEcon.linearized","text":"linearized(model::Model; <arguments>)\n\nCreate a new model that is the linear approximation of the given model about its steady state.\n\nKeyword arguments\n\nsstate - linearize about the provided steady state solution\ndeviation::Bool - whether or not the linearized model will tread data passed \n\nto is as deviation from the steady state\n\nSee also: linearize! and with_linearized\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.logm-Tuple{Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.logm","text":"logm(x) = log(-x)\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.mexp-Tuple{Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.mexp","text":"mexp(x) = -exp(x)\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.neqns-Tuple{SteadyStateData}","page":"ModelBaseEcon","title":"ModelBaseEcon.neqns","text":"neqns(ssd::SteadyStateData)\n\nReturn the total number of equations in the steady state system, including the ones derived from the dynamic system and the ones added explicitly as steady state constraints.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.peval-Tuple{Any,Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.peval","text":"peval(params, what)\n\nEvaluate the given expression in the context of the given parameters.\n\nIf what is a ModelParam, its current value is returned. If there's a chance it might be out of date, call update_links!.\n\nIf what is a Symbol or an Expr, all mentions of parameter names are substituted by their values and the the expression is evaluated.\n\nIf what is any other value, it is returned unchanged.\n\nSee also: Parameters, @alias, @link, ModelParam, update_links!.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.printsstate-Tuple{IO,ModelBaseEcon.AbstractModel}","page":"ModelBaseEcon","title":"ModelBaseEcon.printsstate","text":"printsstate([io::IO,] ssd::SteadyStateData)\n\nDisplay steady state solution.\n\nSteady state solution is presented in a table, where the first column is the name of the variable, the second and third columns are the corresponding values of the level and the slope. If the value is not determined (as per its mask value) then it is displayed as \"*\".\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.transformation","page":"ModelBaseEcon","title":"ModelBaseEcon.transformation","text":"transformation(::Type{<:Transformation})\n\nReturn a Function that will be substituted into the model equations and will be called to transform the input data before solving. See also inverse_transformation.\n\nIt is expected that transformation(T) ∘ inverse_transformation(T) == identity and inverse_transformation(T) ∘ transformation(T) == identity, but these is not verified.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.update_links!-Tuple{ModelBaseEcon.AbstractModel}","page":"ModelBaseEcon","title":"ModelBaseEcon.update_links!","text":"update_links!(model)\nupdate_links!(params)\n\nRecompute the current values of all parameters.\n\nTypically when a new value of a parameter is assigned, all parameter links and aliases that depend on it are updated recursively. If a parameter mutable, e.g. a Vector or another collection, its value can be updated in place without re-assigning it, thus the automatic updated does not happen. In this case, it is necessary to call update_links!.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.with_linearized-Tuple{Function,Model}","page":"ModelBaseEcon","title":"ModelBaseEcon.with_linearized","text":"with_linearized(F::Function, model::Model; <arguments>)\n\nApply the given function on a new model that is the linear approximation  of the given model about its steady state.  This is meant to be used with the do syntax, as in the example below.\n\nKeyword arguments\n\nsstate - linearize about the provided steady state solution\ndeviation::Bool - whether or not the linearized model will tread data passed \n\nto is as deviation from the steady state\n\nSee also: linearize! and with_linearized\n\nExample\n\nwith_linearized(m) do lm\n    # do something awesome with linearized model `lm`\nend\n# model `m` is still non-linear.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@alias-Tuple{Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.@alias","text":"@alias name\n\nCreate a parameter alias. Use `@alias` in the [`@parameters`](@ref) section of your\n\nmodel definition.\n\n@parameters model begin\n    a = 5\n    b = @alias a\nend\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@autoexogenize-Tuple{Any,Vararg{Expr,N} where N}","page":"ModelBaseEcon","title":"ModelBaseEcon.@autoexogenize","text":"@autoexogenize model begin\n    varname = shkname\n    ...\nend\n\nDefine a mapping between variables and shocks that can be used to conveniently  swap exogenous and endogenous variables.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@autoshocks","page":"ModelBaseEcon","title":"ModelBaseEcon.@autoshocks","text":"@autoshocks model\n\nCreate a list of shocks that matches the list of variables.  Each shock name is created from a variable name by appending \"_shk\".\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@d-Tuple","page":"ModelBaseEcon","title":"ModelBaseEcon.@d","text":"No documentation found.\n\nBinding ModelBaseEcon.fsym does not exist.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@dlog-Tuple","page":"ModelBaseEcon","title":"ModelBaseEcon.@dlog","text":"No documentation found.\n\nBinding ModelBaseEcon.fsym does not exist.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@equations-Tuple{Any,Expr}","page":"ModelBaseEcon","title":"ModelBaseEcon.@equations","text":"Usage example:\n\n@equations model begin\n    y[t] = a * y[t-1] + b * y[t+1] + y_shk[t]\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@initialize-Tuple{Symbol}","page":"ModelBaseEcon","title":"ModelBaseEcon.@initialize","text":"@initialize model\n\nPrepare a model instance for analysis. Call this macro after all variable names, shock names and equations have been defined.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@lag-Tuple","page":"ModelBaseEcon","title":"ModelBaseEcon.@lag","text":"No documentation found.\n\nBinding ModelBaseEcon.fsym does not exist.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@lead-Tuple","page":"ModelBaseEcon","title":"ModelBaseEcon.@lead","text":"No documentation found.\n\nBinding ModelBaseEcon.fsym does not exist.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@link-Tuple{Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.@link","text":"@link expr\n\nCreate a parameter link. Use @link in the @parameters section of your model definition.\n\nIf your parameter depends on other parameters, then you use @link to declare that. The expression can be any valid Julia code.\n\n@parameters model begin\n    a = 5\n    b = @link a + 1\nend\n\nWhen a parameter the link depends on is assigned a new value, the link that depends on it gets updated automatically.\n\nnote: Important note\nThere are two cases in which the value of a link does not get updated automatically. If the parameter it depends on is mutable, e.g. a Vector, it is possible for it to get updated in place. The other case is when the link contains global variable or custom function.In such case, it is necessary to call update_links!.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@load_example-Tuple{Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.@load_example","text":"Deprecated. Use @using_example instead.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@movav-Tuple","page":"ModelBaseEcon","title":"ModelBaseEcon.@movav","text":"No documentation found.\n\nBinding ModelBaseEcon.fsym does not exist.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@movsum-Tuple","page":"ModelBaseEcon","title":"ModelBaseEcon.@movsum","text":"No documentation found.\n\nBinding ModelBaseEcon.fsym does not exist.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@parameters-Tuple{Any,Vararg{Expr,N} where N}","page":"ModelBaseEcon","title":"ModelBaseEcon.@parameters","text":"@parameters model begin\n    name = value\n    ...\nend\n\nDeclare and define the model parameters. \n\nThe parameters must have values. Provide the information in a series of assignment statements wrapped inside a begin-end block. The names can be used in equations as if they were regular variables.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@parameters-Tuple{}","page":"ModelBaseEcon","title":"ModelBaseEcon.@parameters","text":"params = @parameters\n\nWhen called without any arguments, return an empty Parameters container, with its evaluation module set to the module in which the macro is being called.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@shocks-Tuple{Any,Expr}","page":"ModelBaseEcon","title":"ModelBaseEcon.@shocks","text":"@shocks model names...\n@shocks model begin\n    names...\nend\n\nDefine the names of transition shocks in the model.\n\nExample\n\n```jldoctest @shocks model ashk bshk c_shk\n\nIf the list is long, use a begin-end block separating names with newline or semicolon\n\n@shocks model begin     ashk; bshk     c_shk end ````\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@steadystate-Tuple{Any,Symbol,Expr}","page":"ModelBaseEcon","title":"ModelBaseEcon.@steadystate","text":"@steadystate model [type] equation\n\nAdd a steady state equation to the model.\n\nThe steady state system of the model is automatically derived from the dynamic system. Use this macro to define additional equations for the steady state. This is particularly useful in the case of a non-linear model that might have multiple steady state, or the steady state might be difficult to solve for, to help the steady state solver find the one you want to use.\n\nmodel is the model instance you want to update\ntype (optional) is the type of constraint you want to add. This can be level\n\nor slope. If missing, the default is level\n\nequation is the expression defining the steady state constraint. In the\n\nequation, use variables and shocks from the model, but without any t-references.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@using_example-Tuple{Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.@using_example","text":"@using_example name\n\nLoad models from the package examples/ folder. The @load_example version is deprecated - stop using it now.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@variables-Tuple{Any,Expr}","page":"ModelBaseEcon","title":"ModelBaseEcon.@variables","text":"@variables model names...\n@variables model begin\n    names...\nend\n\nDefine the names of transition variables in the model.\n\nExample\n\n```jldoctest @variables model a b c\n\nIf the list is long, use a begin-end block separating names with newline or semicolon\n\n@variables model begin     a; b     c end ````\n\n\n\n\n\n","category":"macro"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon-Reference","page":"StateSpaceEcon","title":"StateSpaceEcon Reference","text":"","category":"section"},{"location":"Reference/StateSpaceEcon/","page":"StateSpaceEcon","title":"StateSpaceEcon","text":"Pages = [\"statespaceecon.md\"]","category":"page"},{"location":"Reference/StateSpaceEcon/#Steady-state-solver","page":"StateSpaceEcon","title":"Steady state solver","text":"","category":"section"},{"location":"Reference/StateSpaceEcon/","page":"StateSpaceEcon","title":"StateSpaceEcon","text":"Modules = [StateSpaceEcon.SteadyStateSolver]\nPrivate = false","category":"page"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver","text":"SteadyStateSolver\n\nA module that is part of StateSpaceEcon package. Contains methods for finding a steady state of a model.\n\n\n\n\n\n","category":"module"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.check_sstate-Tuple{Model}","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.check_sstate","text":"check_sstate(model; <options>)\n\nRun a diagnostic test to determine if the steady state solution stored within the given model object is indeed a solution of the steady state system of equations.\n\nReturn the number of steady state equations that are violated by the current steady state solution. If verbose=true, also display diagnostic information in the form of listing all bad equations and their residuals.\n\nOptions\n\nStandard options (default values from model.options)\n\nverbose \ntol - an equation is considered satisfied if its residual, in absolute value, is smaller than this number.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.clear_sstate!-Tuple{Model}","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.clear_sstate!","text":"clear_sstate!(model; lvl=0.1, slp=0.0, <options>)\n\nSet the steady state values to the provided defaults and presolve.\n\nArguments\n\nmodel - the model instance\nlvl, slp - the initial guess for the level and the slope. Each could be a number or a vector of length equal to the number of variable in the mode.\n\nOptions\n\nStandard options (default values are taken from model.options)\n\nverbose\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.diagnose_sstate-Tuple{Model}","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.diagnose_sstate","text":"diagnose_sstate([point,] model)\n\nRun diagnostics on the steady state of the given model. If point is not given, then we check the steady state solution stored inside the given model.\n\nReturn a tuple of \"bad\" equations and \"bad\" variables. \n\nThe set of \"bad\" equations is one that is inconsistent, i.e. there is no solution. This might happen if the system is overdetermined.\n\nThe set of \"bad\" variables contains variables that cannot be solved uniquely. This might happen if the system is underdetermined. In this case, try adding steady state constraints until you get a unique solution. See @steadystate in ModelBaseEcon.\n\nwarning: Internal function\nThe output from this function may be difficult to read.<br> Call check_sstate instead.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.initial_sstate!-Tuple{Model,AbstractArray{Float64,1}}","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.initial_sstate!","text":"initial_sstate!(model, init; <options>)\n\nSet the steady state values from the given vector and presolve.\n\nCall this function to specify initial guesses for the iterative steady state solver. If the value of a steady state variable is known, it is better to use @steadystate to add that as a steady state constraint.\n\nArguments\n\nmodel - the model.\ninit - a vector of length equal to twice the number of variables in the model. The level and slope values are staggered, i.e., the level and slope of variable j are in init[2j-1] and init[2j].\n\nOptions\n\nStandard options (default values are taken from model.options)\n\nverbose\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.sssolve!-Tuple{Model}","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.sssolve!","text":"sssolve!(model; <options>)\n\nSolve the steady state problem for the given model.\n\nOptions\n\nStandard options (default values are taken from model.options)\n\nverbose\ntol, maxiter - control the stopping criteria of the solver\n\nSpecific options\n\npresolve::Bool - whether or not to use a presolve pass. Default is true.\nmethod::Symbol - choose the solution algorithm. Valid options are :nr for Newton-Raphson, :lm for Levenberg-Marquardt, and :auto. The :auto method starts with the LM algorithm and automatically switches to NR when it starts to converge. Default is :nr.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#Plans","page":"StateSpaceEcon","title":"Plans","text":"","category":"section"},{"location":"Reference/StateSpaceEcon/","page":"StateSpaceEcon","title":"StateSpaceEcon","text":"Modules = [StateSpaceEcon.Plans]\nPrivate = false","category":"page"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans","text":"Plans\n\nModule part of StateSpaceEcon. This module implements the Plan data structure, which is used in simulations. The plan object contains information about the range of the simulation and which variables and shocks are exogenous or endogenous at each period of the range.\n\nConstructors\n\nPlan(model, range)\n\nModify the plan\n\nexogenize!, endogenize! - make variables exogenous or endogenous\nexog_endo!, endo_exog! - swap exogenous and endogenous variables\nautoexogenize! - exogenize and endogenize variables according to the list in the model\n\nPrepare data for simulation\n\nzeroarray, zerodict, zerodata - prepare a matrix or a dictionary or a SimData of data for the simulation containing zeros.\nsteadystatearray, steadystatedict, steadystatedata - prepare a matrix or a dictionary or a SimData of data for the simulation containing the steady state.\n\n\n\n\n\n","category":"module"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.Plan","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.Plan","text":"Plan{T <: MIT}\n\nA data structure representing the simulation plan. It holds information about the time range of the simulation and which variables/shocks are exogenous at each period.\n\n\n\n\n\n","category":"type"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.Plan-Tuple{Model,AbstractUnitRange}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.Plan","text":"Plan(model, range)\n\nCreate a default simulation plan for the given model over the given range. The range of the plan is augmented to include periods before and after the given range, over which initial and final conditions will be applied. \n\nInstead of a range, one could also pass in a single moment in time (MIT) instance, in which case it is interpreted as a range of length 1.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.autoexogenize!-Tuple{Plan,Model,Any}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.autoexogenize!","text":"autoexogenize!(plan, model, date)\n\nModify the given plan according to the \"autoexogenize\" protocol defined in the given model. All variables in the autoexogenization list become endogenous and their corresponding shocks become exogenous over the given date or range. date can be a moment in time (same frequency as the given plan), a range, an iterable, or a container.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.endo_exog!-Tuple{Plan,Any,Any,Any}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.endo_exog!","text":"endo_exog!(plan, endo_vars, exog_vars, date)\n\nModify the given plan so that the given variables listed in exog_vars will be exogenous and the variables listed in endo_vars will be endogenous on the given dates. exog_vars and endo_vars can each be a Symbol or a String or a Vector of such. date can be a moment in time (same type as the plan), or a range or an iterable or a container.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.endogenize!-Tuple{Plan,Any,Any}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.endogenize!","text":"endogenize!(plan, vars, date)\n\nModify the given plan so that the given variables will be endogenous on the given dates. vars can be a Symbol or a String or a Vector of such. date can be a moment in time (same type as the plan), or a range or an iterable or a container.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.exog_endo!-Tuple{Plan,Any,Any,Any}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.exog_endo!","text":"exog_endo!(plan, exog_vars, endo_vars, date)\n\nModify the given plan so that the given variables listed in exog_vars will be exogenous and the variables listed in endo_vars will be endogenous on the given dates. exog_vars and endo_vars can each be a Symbol or a String or a Vector of such. date can be a moment in time (same type as the plan), or a range or an iterable or a container.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.exogenize!-Tuple{Plan,Any,Any}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.exogenize!","text":"exogenize!(plan, vars, date)\n\nModify the given plan so that the given variables will be exogenous on the given dates. vars can be a Symbol or a String or a Vector of such. date can be a moment in time (same type as the plan), or a range or an iterable or a container.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.plansum-Tuple{Model,Plan}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.plansum","text":"plansum(model, plan)\n\nReturn the total number of exogenous variables in the simulation plan. Periods over which initial and final conditions are imposed are not counted in this sum.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.setexog!-Tuple{Plan,Int64,Any}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.setexog!","text":"setexog!(plan, t, vinds)\n\nModify the plan at time t such that vinds are exogenous and the rest are endogenous.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#Stacked-time-solver","page":"StateSpaceEcon","title":"Stacked time solver","text":"","category":"section"},{"location":"Reference/StateSpaceEcon/","page":"StateSpaceEcon","title":"StateSpaceEcon","text":"Modules = [StateSpaceEcon.StackedTimeSolver]\nPrivate = false","category":"page"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver","text":"StackedTimeSolver\n\nA module that is part of StateSpaceEcon package. Contains methods for solving the dynamic system of equations for the model and running simulations.\n\n\n\n\n\n","category":"module"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.array2data-Tuple{AbstractArray{Float64,2},AbstractArray{T,1} where T,MIT}","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.array2data","text":"array2data(data, vars, start_date; copy=false)\n\nConvert the simulation data array to a SimData.\n\nUse the copy argument to control whether or not the returned SimData will hold a reference to the given data array or its own copy.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.array2dict-Tuple{AbstractArray{Float64,2},AbstractArray{T,1} where T,MIT}","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.array2dict","text":"array2dict(data, vars, start_date)\n\nConvert the simulation data array to a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.data2array-Tuple{SimData}","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.data2array","text":"data2array(sd::SimData; copy=false)::Array{Float64,2}\n\nConvert a SimData to an Array. The copy argument controls whether the returned Array holds a copy of the data or a reference to the data in sd.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.data2dict-Tuple{SimData}","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.data2dict","text":"data2dict(sd::SimData; copy=false)::Dict{String, Any}\n\nConvert a SimData to a dictionary containing the same data as individual TSeries.\n\nUse the copy argument to control whether the TSeries in the returned Dict will hold references to the columns of sd or copies of that data.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.dict2array-Tuple{Dict,AbstractArray{T,1} where T}","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.dict2array","text":"dict2array(d, vars; range)\n\nConvert a dictionary of TSeries to a 2d array of simulation data for the given range. If the range argument is not provided, the effective range is the intersection of the ranges of available data for the given list of variables.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.dict2data-Tuple{Dict,AbstractArray{T,1} where T}","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.dict2data","text":"dict2data(d, vars; range)\n\nConvert a dictionary of TSeries to a SimDatafor the given range. If therange` argument is not provided, the effective range is the intersection of the ranges of available data for the given list of variables.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.dictoverlay-Tuple{Dict{String,#s41} where #s41,Dict{String,#s40} where #s40}","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.dictoverlay","text":"dictoverlay(d1, d2)\n\nMerge two dictionaries. Common key where the values are TSeries of the same frequency are overlayed. Otherwise, a common key takes the value of the last Dict containing it.\n\nSee also: seriesoverlay\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.seriesoverlay-Tuple{TSeries,TSeries}","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.seriesoverlay","text":"seriesoverlay(ts1, ts2)\n\nReturn a new TSeries over the full range of both arguments. The overlapping part contains values from the last argument.\n\nSee also: dictoverlay\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.simulate-Tuple{Model,Plan,AbstractArray{Float64,2}}","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.simulate","text":"simulate(model, plan, data; <options>)\n\nRun a simulation for the given model, simulation plan and exogenous data.\n\nArguments\n\nmodel - the Model instance to simulate.\nplan - the Plan for the simulation.\ndata - a 2D Array containing the exogenous data. This includes the initial and final conditions.\n\nOptions as keyword arguments\n\nfctype::FCType - set the desired final condition type for the simulation. The default value is fcgiven. Other possible values include fclevel and fcslope.\ninitial_guess::AbstractMatrix{Float64} - a 2D Array containing the initial guess for the solution. This is used to start the Newton-Raphson algorithm. The default value is an empty array (zeros(0,0)), in which case we use the exogenous data for the initial condition. You can use the steady state solution using steadystatearray.\nlinearize::Bool - set to true to instruct the solver to use the liearized model. If the model is already linearized, this option has the effect that the model gets linearized about the current steady stat and with the value of deviation given here. Otherwise the model is linearized about the steady state. After the simulation is computed, the model is restored to its original state. Default value is false.\ndeviation::Bool - set to true if the data is in deviations from the steady state. This is only relevant if the linearize option is set to true. Default value is false.\nanticipate::Bool - set to false to instruct the solver that all shocks are unanticilated by the agents. Default value is true.\nverbose::Bool - control whether or not to print progress information. Default value is taken from model.options.\ntol::Float64 - set the desired accuracy. Default value is taken from model.options.\nmaxiter::Int - algorithm fails if the desired accuracy is not reached within this maximum number of iterations. Default value is taken from model.options.\n\nSee also:\n\nExamples\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#Various","page":"StateSpaceEcon","title":"Various","text":"","category":"section"},{"location":"Reference/StateSpaceEcon/","page":"StateSpaceEcon","title":"StateSpaceEcon","text":"Modules = [StateSpaceEcon]\nPrivate = false","category":"page"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StateSpaceEcon","page":"StateSpaceEcon","title":"StateSpaceEcon.StateSpaceEcon","text":"StateSpaceEcon\n\nA package for Macroeconomic modelling.\n\n\n\n\n\n","category":"module"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SimData","page":"StateSpaceEcon","title":"StateSpaceEcon.SimData","text":"SimData(fd, vars, data)\n\nConstruct an instance of SimData with the given variable names and data. The first date is provided in the fd::MIT argument, which also contains information about the frequency. The number of names must match the number of columns in data. The names must be String or Symbol or anything that converts to Symbol.\n\n\n\n\n\n","category":"type"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SimData-2","page":"StateSpaceEcon","title":"StateSpaceEcon.SimData","text":"SimData\n\nData structure containing the time series data for a simulation.\n\nIt is a collection of TSeries of the same frequency and containing data for the same range. When used for simulation, the range must include the initial conditions, the simulation range and the final conditions, although it could extend beyond that. It must contain time series for all variables and shocks in the model, although it might contain other time series.\n\n\n\n\n\n","category":"type"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.printmatrix-Tuple{AbstractArray{T,2} where T,Vararg{Any,N} where N}","page":"StateSpaceEcon","title":"StateSpaceEcon.printmatrix","text":"printmatrix(mat [, Val(F), colnames])\n\nDisplay a matrix in full while controlling the formatting of each value and optionally showing the column names.\n\nVal(F) - display each number in the given format F. The format is in the form of a decimal point number where the whole part indicates the total width and the fractional part is the number of digits printed after the decimal point. Default is Val(12.7)\ncolnames - a list of names to display in the first row. The names are displayed as given, possibly with padding to match the width given in the Val argument. If any names are longer than that, they will not be truncated and so the display will not be aligned properly. Sorry about that!\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.steadystatearray","page":"StateSpaceEcon","title":"StateSpaceEcon.steadystatearray","text":"steadystatearray(model, plan)\nsteadystatearray(model, range)\n\nCreate a matrix of the proper dimensions for a simulation with the given model with the given plan or over the given range. The matrix is initialized with the steady state level of each variable. If a range is given rather than a plan, it is augmented with periods before and after the given range in order to accommodate initial and final conditions.\n\nSee also: zeroarray, zerodict, steadystatearray, steadystatedict\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.steadystatedata","page":"StateSpaceEcon","title":"StateSpaceEcon.steadystatedata","text":"steadystatedata(model, plan)\nsteadystatedata(model, range)\n\nCreate a SimData containing a TSeries of the appropriate range for each variable in the model for a simulation with the given plan or over the given range. The matrix is initialized with the steady state level of each variable. If a range is given rather than a plan, it is augmented with periods before and after the given range in order to accommodate initial and final conditions.\n\nSee also: zeroarray, zerodict, steadystatearray, steadystatedict\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.steadystatedict","page":"StateSpaceEcon","title":"StateSpaceEcon.steadystatedict","text":"steadystatearray(model, plan)\nsteadystatearray(model, range)\n\nCreate a dictionary containing a TSeries of the appropriate range for each variable in the model for a simulation with the given plan or over the given range. The matrix is initialized with the steady state level of each variable. If a range is given rather than a plan, it is augmented with periods before and after the given range in order to accommodate initial and final conditions.\n\nSee also: zeroarray, zerodict, steadystatearray, steadystatedict\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.zeroarray","page":"StateSpaceEcon","title":"StateSpaceEcon.zeroarray","text":"zeroarray(model, plan)\nzeroarray(model, range)\n\nCreate a matrix of the proper dimension for a simulation with the given model with the given plan or over the given range. If a range is given, the data is prepared for the default plan. This means that appropriate number of periods are added before and after the range to account for initial and final conditions.\n\nSee also: zeroarray, zerodict, steadystatearray, steadystatedict\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.zerodata","page":"StateSpaceEcon","title":"StateSpaceEcon.zerodata","text":"zerodata(model, plan)\nzerodata(model, range)\n\nCreate a NamedTuple containing a TSeries of the appropriate range for each variable in the model for a simulation with the given plan or over the given range. If a range is given rather than a plan, the data is prepared for the default plan over that range. This means that appropriate number of periods are added before and after the range to account for initial and final conditions.\n\nSee also: zeroarray, zerodict, steadystatearray, steadystatedict\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.zerodict","page":"StateSpaceEcon","title":"StateSpaceEcon.zerodict","text":"zerodict(model, plan)\nzerodict(model, range)\n\nCreate a dictionary containing a TSeries of the appropriate range for each variable in the model for a simulation with the given plan or over the given range. If a range is given rather than a plan, the data is prepared for the default plan over that range. This means that appropriate number of periods are added before and after the range to account for initial and final conditions.\n\nSee also: zeroarray, zerodict, steadystatearray, steadystatedict\n\n\n\n\n\n","category":"function"},{"location":"DesignPapers/#Design-Papers","page":"Design Papers","title":"Design Papers","text":"","category":"section"},{"location":"DesignPapers/","page":"Design Papers","title":"Design Papers","text":"This section contains articles that describe the numerical methods and details about their implementations.","category":"page"},{"location":"#Welcome","page":"Welcome","title":"Welcome","text":"","category":"section"},{"location":"","page":"Welcome","title":"Welcome","text":"This is the official documentation for the StateSpaceEcon collection of Julia packages.","category":"page"},{"location":"","page":"Welcome","title":"Welcome","text":"warning: Under construction\nThis site is incomplete. Many articles that are planned to appear are not yet available. Some articles are still in a draft version. Please check back regularly.","category":"page"},{"location":"Tutorials/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"This section contains a list of tutorials demonstrating the use of StateSpaceEcon group of Julia packages.","category":"page"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"You could read the tutorials on the web - just browse the pages. If you wish to run the tutorial examples and further experiment for yourself, follow the instructions below to install a copy of the Tutorials on your computer.","category":"page"},{"location":"Tutorials/#Getting-started","page":"Introduction","title":"Getting started","text":"","category":"section"},{"location":"Tutorials/#Prerequisites","page":"Introduction","title":"Prerequisites","text":"","category":"section"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"You need a recent version of Julia (v1.0 or later). We also recommend using VSCode and so below we provide the instructions assuming that's the case. To install Julia and VSCode follow the instructions at https://github.com/julia-vscode/julia-vscode#installing-juliavs-codevs-code-julia-extensio","category":"page"},{"location":"Tutorials/#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"Clone either DocsEcon.jl or TutorialsEcon.jl.","category":"page"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"TutorialsEcon.jl is a sub-module of DocsEcon.jl, mounted in scr/Tutorial. If you decide to clone DocsEcon.jl, then you should make sure that you clone it recursively.","category":"page"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"$ git clone --recursive https://github.com/bankofcanada/DocsEcon.jl.git","category":"page"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"If you use VSCode to clone the project, that doesn't happen automatically and you'll see that src/Tutorial directory remains empty. In this case, open a terminal in your DocsEcon.jl directory and run","category":"page"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"$ git submodule init\n$ git submodule update","category":"page"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"After this, you should see the files of TutorialsEcon.jl appear under src/Tutorials.","category":"page"},{"location":"Tutorials/#Initialize-the-environment","page":"Introduction","title":"Initialize the environment","text":"","category":"section"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"Open a Julia REPL in the root directory of your project. Activate the environment in  the current directory and instantiate it.","category":"page"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"julia> ]\npkg> activate .\npkg> instantiate","category":"page"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"Note that if you're working with DocsEcon.jl, there's no need to do this in src/Tutorials, even though that directory contains its own Julia environment. All tutorials would run under the DocsEcon.jl environment just fine. If you find that not to be the case, please open a bug report issue in DocsEcon.jl.","category":"page"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"If you're using VSCode, make sure to set the default Julia environment for the workspace to the one you just instantiated.","category":"page"},{"location":"Tutorials/#Running-a-tutorial","page":"Introduction","title":"Running a tutorial","text":"","category":"section"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"Each tutorial is in its own subdirectory, which is self-contained, meaning that running a tutorial does not depend on files of another tutorial. ","category":"page"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"Each tutorial has a main.jl file, which contains the tutorial code. The code is meant to run in a REPL started in the root directory of the project, which is the default in VSCode. In any case, make sure the currently active environment is the one in the root directory of the project you cloned.","category":"page"}]
}
