var documenterSearchIndex = {"docs":
[{"location":"indexpage/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"indexpage/","page":"Index","title":"Index","text":"","category":"page"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon-Reference","page":"ModelBaseEcon","title":"ModelBaseEcon Reference","text":"","category":"section"},{"location":"Reference/ModelBaseEcon/","page":"ModelBaseEcon","title":"ModelBaseEcon","text":"Pages = [\"modelbaseecon.md\"]","category":"page"},{"location":"Reference/ModelBaseEcon/#Options","page":"ModelBaseEcon","title":"Options","text":"","category":"section"},{"location":"Reference/ModelBaseEcon/","page":"ModelBaseEcon","title":"ModelBaseEcon","text":"Modules = [ModelBaseEcon.OptionsMod]\nPrivate = false","category":"page"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.OptionsMod","page":"ModelBaseEcon","title":"ModelBaseEcon.OptionsMod","text":"OptionsMod\n\nSub-module of ModelBaseEcon, although it can be used independently. Implements the Options data structure.\n\nContents\n\nOptions\ngetoption - read the value of an option\ngetoption! - if not present, also create an option\nsetoption! - create or update the value of an option \n\n\n\n\n\n","category":"module"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.OptionsMod.Options","page":"ModelBaseEcon","title":"ModelBaseEcon.OptionsMod.Options","text":"Options\n\nA collection of key-value pairs representing the options controlling the behaviour or the definition of a Model object. The key is the option name and is always a Symbol, or converted to Symbol, while the value can be anything.\n\nThe options can be accessed using dot notation. Functions getoption and setoption! are also provided. They can be used for programmatic processing of options as well as when the option name is not a valid Julia identifier.\n\nSee also: Options, getoption, getoption!, setoption!\n\nExamples\n\njulia> o = Options(maxiter=20, tol=1e-7)\nOptions:\n    maxiter=20\n    tol=1.0e-7\n\njulia> o.maxiter = 25\n25\n\njulia> o\nOptions:\n    maxiter=25\n    tol=1.0e-7\n\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.OptionsMod.Options-Tuple{Options}","page":"ModelBaseEcon","title":"ModelBaseEcon.OptionsMod.Options","text":"Options(::Options)\n\nConstruct an Options instance as an exact copy of an existing instance.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.OptionsMod.Options-Tuple{}","page":"ModelBaseEcon","title":"ModelBaseEcon.OptionsMod.Options","text":"Options(key=value, ...)\nOptions(:key=>value, ...)\n\nConstruct an Options instance with key-value pairs given as keyword arguments or as a list of pairs. If the latter is used, each key must be a Symbol.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.OptionsMod.getoption","page":"ModelBaseEcon","title":"ModelBaseEcon.OptionsMod.getoption","text":"getoption(o::Options; name=default [, name=default, ...])\ngetoption(o::Options, name, default)\n\nRetrieve the value of an option or a set of options.  The provided defaults are used when the option doesn't exit.\n\nThe return value is the value of the option requested or, if the option doesn't exist, the default. In the first version of the function, if there are more than one options requested, the return value is a tuple.\n\nIn the second version, the name could be a symbol or a string, which can be helpful if the name of the option is not a valid identifier.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.OptionsMod.getoption!","page":"ModelBaseEcon","title":"ModelBaseEcon.OptionsMod.getoption!","text":"getoption!(o::Options; name=default [, name=default, ...])\ngetoption!(o::Options, name, default)\n\nRetrieve the value of an option or a set of options. If the name does not match an existing option, the Options instance is updated by inserting the given name and default value.\n\nThe return value is the value of the option requested (or the default). In the first version of the function, if there are more than one options requested, the return value is a tuple.\n\nIn the second version, the name could be a symbol or a string, which can be helpful if the name of the option is not a valid identifier.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.OptionsMod.setoption!","page":"ModelBaseEcon","title":"ModelBaseEcon.OptionsMod.setoption!","text":"setoption!(o::Options; name=default [, name=default, ...])\nsetoption!(o::Options, name, default)\n\nRetrieve the value of an option or a set of options. If the name does not match an existing option, the Options instance is updated by inserting the given name and default value.\n\nThe return value is the value of the option requested (or the default). In the first version of the function, if there are more than one options requested, the return value is a tuple.\n\nIn the second version, the name could be a symbol or a string, which can be helpful if the name of the option is not a valid identifier.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#Timer","page":"ModelBaseEcon","title":"Timer","text":"","category":"section"},{"location":"Reference/ModelBaseEcon/","page":"ModelBaseEcon","title":"ModelBaseEcon","text":"Modules = [ModelBaseEcon.Timer]\nPrivate = false","category":"page"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Timer","page":"ModelBaseEcon","title":"ModelBaseEcon.Timer","text":"Timer\n\nA sub-module of ModelBaseEcon, although it can be used independently. Provides functionality for measuring the aggregate time spent in individual lines or blocks of code.\n\ntip: Tip\nThe implementation here is quick-and-dirty and is intended for getting a rough idea of where the bottlenecks are. It is best used for timing blocks of code that are passed through relatively few times and each pass takes a relatively long time. In the opposite extreme case (fast code that is called many times), the current implementation of @timer might add extreme overhead.\n\nContents\n\ninittimer       - Enable collection of timer data.\nstoptimer       - Disable collection of timer data.\nprinttimer      - Display timer data.\n@timer          - Measure the runtime taken by the given code.\n\nExample\n\njulia> true\n[...]\n\n\n\n\n\n","category":"module"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Timer.inittimer-Tuple{}","page":"ModelBaseEcon","title":"ModelBaseEcon.Timer.inittimer","text":"inittimer()\n\nEnable the collection of timing data. Existing timing data is lost. By default, collection of timing data is disabled.\n\nSee also: stoptimer, @timer, printtimer\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Timer.printtimer","page":"ModelBaseEcon","title":"ModelBaseEcon.Timer.printtimer","text":"printtimer(io::IO=Base.stdout)\n\nDisplay timing data.\n\nTiming data is displayed in a table with each row containing the number of calls, total time in seconds, and the source line or block tag. Rows are sorted in order of decreasing total time.\n\nSee also: @timer\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Timer.stoptimer-Tuple{}","page":"ModelBaseEcon","title":"ModelBaseEcon.Timer.stoptimer","text":"stoptimer()\n\nDisable the collection of timing data. Existing data is lost. By default, collection of timing data is disabled.\n\nSee also: inittimer, @timer, printtimer\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Timer.@timer-Tuple","page":"ModelBaseEcon","title":"ModelBaseEcon.Timer.@timer","text":"@timer(code)\n@timer(tag::String, code)\n\nMeasure the number of calls and the total time taken by the given code.\n\nIf a tag string is not provided, one is generated from the source file and line. The return value of this macro call is the return value of the code.\n\nwarning: Warning\nImportant limitation is that the code must not contain a return, break, continue, or any other jump out of it. If it does, the program would run correctly, but the timing data collected would be incorrect.\n\nSee also: inittimer, stoptimer, printtimer\n\nExample\n\njulia> inittimer()\n\njulia> @timer Base.sleep(1.0)\n\njulia> printtimer()\n[...]\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon","page":"ModelBaseEcon","title":"ModelBaseEcon","text":"","category":"section"},{"location":"Reference/ModelBaseEcon/","page":"ModelBaseEcon","title":"ModelBaseEcon","text":"Modules = [ModelBaseEcon]\nPrivate = false","category":"page"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.ModelBaseEcon","page":"ModelBaseEcon","title":"ModelBaseEcon.ModelBaseEcon","text":"ModelBaseEcon\n\nThis package is part of the StateSpaceEcon ecosystem.  It contains the basic elements needed for model definition. StateSpaceEcon works with model objects defined with ModelBaseEcon.\n\n\n\n\n\n","category":"module"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Equation","page":"ModelBaseEcon","title":"ModelBaseEcon.Equation","text":"struct Equation <: AbstractEquation\n\nData structure representing a single equation in our state space model.\n\nMethods (for users)\n\nTODO\n\nImplementation (for developers)\n\nDuring the phase of definition of the Model, this type simply stores the expression entered by the user. During @initialize(), the true data structure is constructed. We need this, because the construction of the equation requaires information from the Model object, which may not be available at the time the equation expression is first read.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.LinearizationError","page":"ModelBaseEcon","title":"ModelBaseEcon.LinearizationError","text":"LinearizationError <: ModelErrorBase\n\nA concrete error type used when a model cannot be linearized for some reason.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Model","page":"ModelBaseEcon","title":"ModelBaseEcon.Model","text":"Model <: AbstractModel\n\nData structure that represents a macroeconomic state space model.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.ModelError","page":"ModelBaseEcon","title":"ModelBaseEcon.ModelError","text":"struct ModelError <: ModelErrorBase\n\nConcrete error type used when no specific error description is available.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.ModelErrorBase","page":"ModelBaseEcon","title":"ModelBaseEcon.ModelErrorBase","text":"ModelErrorBase\n\nAbstract error type, base for specific error types used in ModelBaseEcon.\n\nImplementation (note for developers)\n\nWhen implementing a derived error type, override two functions:\n\nmsg(e::SomeModelError) returning a string with the error message;\nhint(e::SomeModelError) returning a string containing a suggestion of how to fix the problem. Optional, if not implemented for a type, the fallback implementation returns an empty string.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.ModelNotInitError","page":"ModelBaseEcon","title":"ModelBaseEcon.ModelNotInitError","text":"struct ModelNotInitError <: ModelErrorBase\n\nSpecific error type used when there's an attempt to use a Model object that has not been initialized.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.ModelParam","page":"ModelBaseEcon","title":"ModelBaseEcon.ModelParam","text":"mutable struct ModelParam\n\nContains a model parameter. For a simple parameter it simply stores its value. For a link or an alias, it stores the link information and also caches the current value for speed.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.NotImplementedError","page":"ModelBaseEcon","title":"ModelBaseEcon.NotImplementedError","text":"struct NotImplementedError <: ModelErrorBase\n\nSpecific error type used when a feature is planned but not yet implemented. \n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Parameters","page":"ModelBaseEcon","title":"ModelBaseEcon.Parameters","text":"struct Parameters <: AbstractDict{Symbol, Any}\n\nContainer for model parameters. It functions as a Dict where the keys are the parameter names. Simple parameter values are stored directly. Special parameters depend on other parameters are are wrapped in the appropriate data structures to keep track of such dependencies. There are two types of special parameters - aliases and links.\n\nIndividual parameters can be accessed in two different ways - dot and bracket notation.\n\nRead access by dot notation calls peval while bracket notation doesn't. This makes no difference for simple parameters. For special parameters, access by bracket notation returns its internal structure, while access by dot notation returns its current value depending on other parameters.\n\nWrite access is the same in both dot and bracket notation. The new parameter value is assigned directly in the case of simple parameter. To create an alias parameter, use the @alias macro. To create a link parameter use the @link macro.\n\nSee also: ModelParam, peval, @alias, @link, update_links!.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Parameters-2","page":"ModelBaseEcon","title":"ModelBaseEcon.Parameters","text":"Parameters([mod::Module])\n\nWhen creating an instance of Parameters, optionally one can specify the module in which parameter expressions will be evaluated. This only matters if there are any link parameters that depend on custom functions or global variables/constants. In this case, the mod argument should be the module in which these definitions exist.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.SteadyStateData","page":"ModelBaseEcon","title":"ModelBaseEcon.SteadyStateData","text":"SteadyStateData\n\nData structure that holds information about the steady state solution of the Model.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.SteadyStateEquation","page":"ModelBaseEcon","title":"ModelBaseEcon.SteadyStateEquation","text":"struct SteadyStateEquation <: AbstractEquation\n\nData structure representing an individual steady state equation.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.alleqns-Tuple{SteadyStateData}","page":"ModelBaseEcon","title":"ModelBaseEcon.alleqns","text":"alleqns(ssd::SteadyStateData)\n\nReturn a list of all steady state equations.\n\nThe list contains all equations derived from the dynamic system and all explicitly added steady state constraints.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.eval_R!","page":"ModelBaseEcon","title":"ModelBaseEcon.eval_R!","text":"eval_R!(res::AbstractArray{Float64,1}, point::AbstractArray{Float64, 2}, ::MED) where MED <: AbstractModelEvaluationData\n\nEvaluate the model residual at the given point using the given model evaluation structure. The residual is stored in the provided vector.\n\nImplementation details (for developers)\n\nWhen creating a new type of model evaluation data, you must define a method of this function specialized to it.\n\nThe point argument will be a 2d array, with the number of rows equal to maxlag+maxlead+1 and the number of columns equal to the number of variables+shocks+auxvars of the model. The res vector will have the same length as the number of equations + auxiliary equations.  Your implementation must not modify point and must update res.\n\nSee also: eval_RJ\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.eval_RJ","page":"ModelBaseEcon","title":"ModelBaseEcon.eval_RJ","text":"eval_RJ(point::AbstractArray{Float64, 2}, ::MED) where MED <: AbstractModelEvaluationData\n\nEvaluate the model residual and its Jacobian at the given point using the given model evaluation structure. Return a tuple, with the first element being the residual and the second element being the Jacobian.\n\nImplementation details (for developers)\n\nWhen creating a new type of model evaluation data, you must define a method of this function specialized to it.\n\nThe point argument will be a 2d array, with the number of rows equal to maxlag+maxlead+1 and the number of columns equal to the number of variables+shocks+auxvars of the model. Your implementation must not modify point and must return the tuple of (residual, Jacobian) evaluated at the given point. The Jacobian is expected to be SparseMatrixCSC (this might change in the future).\n\nSee also: eval_R!\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.export_model","page":"ModelBaseEcon","title":"ModelBaseEcon.export_model","text":"export_model(model, name, file::IO)\nexport_model(model, name, path::String)\n\nExport the model into a module file. The name parameter is used for the name of the module as well as the module file. The module file is created in the directory specified by the optional third argument.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.geteqn-Tuple{Integer,SteadyStateData}","page":"ModelBaseEcon","title":"ModelBaseEcon.geteqn","text":"geteqn(i, ssd::SteadyStateData)\n\nReturn the i-th steady state equation. Index i is interpreted as in the output of alleqns. Calling geteqn(i, sdd) has the same effect as alleqn(ssd)[i], but it's more efficient.\n\nExample\n\n# Iterate all equations like this:\nfor i = 1:neqns(ssd)\n    eqn = geteqn(i, ssd)\n    # do something awesome with `eqn` and `i`\nend\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.islinearized-Tuple{Model}","page":"ModelBaseEcon","title":"ModelBaseEcon.islinearized","text":"islinearized(m::Model)\n\nReturn true if the given model is linearized and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.issssolved-Tuple{SteadyStateData}","page":"ModelBaseEcon","title":"ModelBaseEcon.issssolved","text":"issssolved(sstate::SteadyStateData)\n\nReturn true if the steady state has been solved, or false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.linearize!","page":"ModelBaseEcon","title":"ModelBaseEcon.linearize!","text":"linearize!(model::Model; <keyword arguments>)\n\nTransform model into its linear approximation about its steady state.\n\nKeyword arguments\n\nsstate - linearize about the provided steady state solution\ndeviation::Bool - whether or not the linearized model will tread data passed \n\nto is as deviation from the steady state\n\nSee also: linearized and with_linearized\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.linearized-Tuple{Model}","page":"ModelBaseEcon","title":"ModelBaseEcon.linearized","text":"linearized(model::Model; <arguments>)\n\nCreate a new model that is the linear approximation of the given model about its steady state.\n\nKeyword arguments\n\nsstate - linearize about the provided steady state solution\ndeviation::Bool - whether or not the linearized model will tread data passed \n\nto is as deviation from the steady state\n\nSee also: linearize! and with_linearized\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.neqns-Tuple{SteadyStateData}","page":"ModelBaseEcon","title":"ModelBaseEcon.neqns","text":"neqns(ssd::SteadyStateData)\n\nReturn the total number of equations in the steady state system, including the ones derived from the dynamic system and the ones added explicitly as steady state constraints.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.peval-Tuple{Any,Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.peval","text":"peval(params, what)\n\nEvaluate the given expression in the context of the given parameters.\n\nIf what is a ModelParam, its current value is returned. If there's a chance it might be out of date, call update_links!.\n\nIf what is a Symbol or an Expr, all mentions of parameter names are substituted by their values and the the expression is evaluated.\n\nIf what is any other value, it is returned unchanged.\n\nSee also: Parameters, @alias, @link, ModelParam, update_links!.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.printsstate-Tuple{IO,SteadyStateData}","page":"ModelBaseEcon","title":"ModelBaseEcon.printsstate","text":"printsstate([io::IO,] ssd::SteadyStateData)\n\nDisplay steady state solution.\n\nSteady state solution is presented in a table, where the first column is the name of the variable, the second and third columns are the corresponding values of the level and the slope. If the value is not determined (as per its mask value) then it is displayed as \"*\".\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.update_links!-Tuple{ModelBaseEcon.AbstractModel}","page":"ModelBaseEcon","title":"ModelBaseEcon.update_links!","text":"update_links!(model)\nupdate_links!(params)\n\nRecompute the current values of all parameters.\n\nTypically when a new value of a parameter is assigned, all parameter links and aliases that depend on it are updated recursively. If a parameter mutable, e.g. a Vector or another collection, its value can be updated in place without re-assigning it, thus the automatic updated does not happen. In this case, it is necessary to call update_links!.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.with_linearized-Tuple{Function,Model}","page":"ModelBaseEcon","title":"ModelBaseEcon.with_linearized","text":"with_linearized(F::Function, model::Model; <arguments>)\n\nApply the given function on a new model that is the linear approximation  of the given model about its steady state.  This is meant to be used with the do syntax, as in the example below.\n\nKeyword arguments\n\nsstate - linearize about the provided steady state solution\ndeviation::Bool - whether or not the linearized model will tread data passed \n\nto is as deviation from the steady state\n\nSee also: linearize! and with_linearized\n\nExample\n\nwith_linearized(m) do lm\n    # do something awesome with linearized model `lm`\nend\n# model `m` is still non-linear.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@alias-Tuple{Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.@alias","text":"@alias name\n\nCreate a parameter alias. Use `@alias` in the [`@parameters`](@ref) section of your\n\nmodel definition.\n\n@parameters model begin\n    a = 5\n    b = @alias a\nend\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@autoexogenize-Tuple{Any,Vararg{Expr,N} where N}","page":"ModelBaseEcon","title":"ModelBaseEcon.@autoexogenize","text":"@autoexogenize model begin\n    varname = shkname\n    ...\nend\n\nDefine a mapping between variables and shocks that can be used to conveniently  swap exogenous and endogenous variables.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@d-Tuple","page":"ModelBaseEcon","title":"ModelBaseEcon.@d","text":"No documentation found.\n\nBinding ModelBaseEcon.fsym does not exist.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@dlog-Tuple","page":"ModelBaseEcon","title":"ModelBaseEcon.@dlog","text":"No documentation found.\n\nBinding ModelBaseEcon.fsym does not exist.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@equations-Tuple{Any,Expr}","page":"ModelBaseEcon","title":"ModelBaseEcon.@equations","text":"Usage example:\n\n@equations model begin\n    y[t] = a * y[t-1] + b * y[t+1] + y_shk[t]\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@initialize-Tuple{Symbol}","page":"ModelBaseEcon","title":"ModelBaseEcon.@initialize","text":"@initialize model\n\nPrepare a model instance for analysis. Call this macro after all variable names, shock names and equations have been defined.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@lag-Tuple","page":"ModelBaseEcon","title":"ModelBaseEcon.@lag","text":"No documentation found.\n\nBinding ModelBaseEcon.fsym does not exist.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@lead-Tuple","page":"ModelBaseEcon","title":"ModelBaseEcon.@lead","text":"No documentation found.\n\nBinding ModelBaseEcon.fsym does not exist.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@link-Tuple{Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.@link","text":"@link expr\n\nCreate a parameter link. Use @link in the @parameters section of your model definition.\n\nIf your parameter depends on other parameters, then you use @link to declare that. The expression can be any valid Julia code.\n\n@parameters model begin\n    a = 5\n    b = @link a + 1\nend\n\nWhen a parameter the link depends on is assigned a new value, the link that depends on it gets updated automatically.\n\nnote: Important note\nThere are two cases in which the value of a link does not get updated automatically. If the parameter it depends on is mutable, e.g. a Vector, it is possible for it to get updated in place. The other case is when the link contains global variable or custom function.In such case, it is necessary to call update_links!.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@load_example-Tuple{Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.@load_example","text":"Deprecated. Use @using_example instead.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@movav-Tuple","page":"ModelBaseEcon","title":"ModelBaseEcon.@movav","text":"No documentation found.\n\nBinding ModelBaseEcon.fsym does not exist.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@movsum-Tuple","page":"ModelBaseEcon","title":"ModelBaseEcon.@movsum","text":"No documentation found.\n\nBinding ModelBaseEcon.fsym does not exist.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@parameters-Tuple{Any,Vararg{Expr,N} where N}","page":"ModelBaseEcon","title":"ModelBaseEcon.@parameters","text":"@parameters model begin\n    name = value\n    ...\nend\n\nDeclare and define the model parameters. \n\nThe parameters must have values. Provide the information in a series of assignment statements wrapped inside a begin-end block. The names can be used in equations as if they were regular variables.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@parameters-Tuple{}","page":"ModelBaseEcon","title":"ModelBaseEcon.@parameters","text":"params = @parameters\n\nWhen called without any arguments, return an empty Parameters container, with its evaluation module set to the module in which the macro is being called.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@shocks-Tuple{Any,Expr}","page":"ModelBaseEcon","title":"ModelBaseEcon.@shocks","text":"@shocks model names...\n@shocks model begin\n    names...\nend\n\nDefine the names of transition shocks in the model.\n\nExample\n\n```jldoctest @shocks model ashk bshk c_shk\n\nIf the list is long, use a begin-end block separating names with newline or semicolon\n\n@shocks model begin     ashk; bshk     c_shk end ````\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@steadystate-Tuple{Any,Symbol,Expr}","page":"ModelBaseEcon","title":"ModelBaseEcon.@steadystate","text":"@steadystate model [type] equation\n\nAdd a steady state equation to the model.\n\nThe steady state system of the model is automatically derived from the dynamic system. Use this macro to define additional equations for the steady state. This is particularly useful in the case of a non-linear model that might have multiple steady state, or the steady state might be difficult to solve for, to help the steady state solver find the one you want to use.\n\nmodel is the model instance you want to update\ntype (optional) is the type of constraint you want to add. This can be level\n\nor slope. If missing, the default is level\n\nequation is the expression defining the steady state constraint. In the\n\nequation, use variables and shocks from the model, but without any t-references.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@using_example-Tuple{Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.@using_example","text":"@using_example name\n\nLoad models from the package examples/ folder. The @load_example version is deprecated - stop using it now.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@variables-Tuple{Any,Expr}","page":"ModelBaseEcon","title":"ModelBaseEcon.@variables","text":"@variables model names...\n@variables model begin\n    names...\nend\n\nDefine the names of transition variables in the model.\n\nExample\n\n```jldoctest @variables model a b c\n\nIf the list is long, use a begin-end block separating names with newline or semicolon\n\n@variables model begin     a; b     c end ````\n\n\n\n\n\n","category":"macro"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon-Reference","page":"TimeSeriesEcon","title":"TimeSeriesEcon Reference","text":"","category":"section"},{"location":"Reference/TimeSeriesEcon/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"Modules = [TimeSeriesEcon]","category":"page"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.TimeSeriesEcon","page":"TimeSeriesEcon","title":"TimeSeriesEcon.TimeSeriesEcon","text":"TimeSeriesEcon\n\nThis package is part of the StateSpaceEcon ecosystem. TimeSeriesEcon.jl provides functionality to work with low-Frequency discrete macroeconomic time-series data.\n\nFrequencies (abstract type):\n\nUnit\nMonthly\nQuarterly\nYearly\n\nTypes:\n\nMIT{Frequency} (aka \"Moment In Time\")\na primitive type denoting monthly, quarterly, and yearly dates\nTSeries{Frequency}\nan AbstractVector that can be indexed using MIT\n\nFunctions:\n\nMIT Constructors/Functions\nmm(year::Int, period::Int): returns a monthly MIT type instance\nqq(year::Int, period::Int): returns a quarterly MIT type instance\nyy(year::Int): returns a yearly MIT type instance\nii(x::Int): returns a unit MIT type instance\nyear(x::MIT): returns a Int64 year value associated with x\nperiod(x::MIT): returns a Int64 period value associated with x\nfrequencyof(x::MIT): returns <: Frequency assosicated wtih x\n\nFunctions operating on TSeries\nmitrange(x::TSeries): returns a UnitRange{MIT{Frequency}} for the given x\nfirstdate(x::TSeries): returns MIT{Frequency} first date associated with x  \nlastdate(x::TSeries): returns MIT{Frequency} last date associated with x\nppy(x::TSeries): returns the number of periods per year for x::TSeries. (ppy also accepts x::MIT and x::Frequency) \nshift(x::TSeries, i::Int64): shifts the dates of x by firstdate(x) - i\nshift!: in-place version of shift\npct(x::TSeries, shift_value::Int64; islog::Bool = false): calculates percent rate of change of x::TSeries\napct(x::TSeries, islog::Bool = false): calculates annualized percent rate of change of x::TSeries\nnanrm!(x::TSeries, type::Symbol=:both): removes NaN from x::TSeries\n\n\n\n\n\n","category":"module"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.Frequency","page":"TimeSeriesEcon","title":"TimeSeriesEcon.Frequency","text":"Frequency\n\nFrequency is an abstract type. \n\nMonthly, Quarterly, Yearly, Unit abstract types are subtypes of Frequency.\n\nExamples\n\njulia> Quarterly <: Frequency\ntrue\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.MIT","page":"TimeSeriesEcon","title":"TimeSeriesEcon.MIT","text":"MIT{Frequency}(x::Int64)\n\nMIT is a primitive type (Signed 64) representing a discrete date.\n\nNote: Please use yy, qq, 'mm', ii to instantiate MITs.  MITs are mainly used internally for the package development.\n\nExamples\n\njulia> MIT{Yearly}(2000)\n2000Y\njulia> MIT{Monthly}(2020*12 + 3)\n2020M4\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.Monthly","page":"TimeSeriesEcon","title":"TimeSeriesEcon.Monthly","text":"Monthly\n\nSee also: Frequency ```\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.Quarterly","page":"TimeSeriesEcon","title":"TimeSeriesEcon.Quarterly","text":"Quarterly\n\nSee also: Frequency ```\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.TSeries","page":"TimeSeriesEcon","title":"TimeSeriesEcon.TSeries","text":"struct TSeries{Frequency} <: AbstractVector{Float64}\n\nData structure representing a time-series vector. The following  operations are allowed:\n\nindexing using MIT (aka \"moment-in-time\") and UnitRange{MIT}\nassignment using MIT and UnitRange{MIT}\n\nIn addition, most of the operations available to Julia vectors (+, -, *, etc.) are supported by TSeries as well.\n\nExamples\n\nCreate TSeries\n\njulia> x = TSeries(qq(2020, 1), ones(4))\nTSeries{Quarterly} of length 4\n2020Q1: 1.0\n2020Q2: 1.0\n2020Q3: 1.0\n2020Q4: 1.0\n\nIndex into TSeries\n\njulia> x[qq(2020, 1)]\n1.0\n\njulia> x[qq(2020, 1):qq(2020, 2)]\nTSeries{Quarterly} of length 2\n2020Q1: 1.0\n2020Q2: 1.0\n\nAssignment using MIT\n\njulia> x[qq(2020, 1)] = 100; x\nTSeries{Quarterly} of length 4\n2020Q1: 100.0\n2020Q2: 1.0\n2020Q3: 1.0\n2020Q4: 1.0\n\njulia> x[qq(2020, 1):qq(2020, 2)] = 100; x\nTSeries{Quarterly} of length 4\n2020Q1: 100.0\n2020Q2: 100.0\n2020Q3: 1.0\n2020Q4: 1.0\n\nArithmetic Operations on TSeries\n\njulia> x = TSeries(qq(2020, 1), ones(4))\nTSeries{Quarterly} of length 4\n2020Q1: 1.0\n2020Q2: 1.0\n2020Q3: 1.0\n2020Q4: 1.0\n\njulia> 2*x + 98\nTSeries{Quarterly} of length 4\n2020Q1: 100.0\n2020Q2: 100.0\n2020Q3: 100.0\n2020Q4: 100.0\n\njulia> log(exp(x))\nTSeries{Quarterly} of length 4\n2020Q1: 1.0\n2020Q2: 1.0\n2020Q3: 1.0\n2020Q4: 1.0\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.Unit","page":"TimeSeriesEcon","title":"TimeSeriesEcon.Unit","text":"Unit\n\nSee also: Frequency ```\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.Yearly","page":"TimeSeriesEcon","title":"TimeSeriesEcon.Yearly","text":"Yearly\n\nSee also: Frequency ```\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#Base.:*-Union{Tuple{T}, Tuple{TSeries{T,C} where C<:AbstractArray{Float64,1},Number}} where T<:Frequency","page":"TimeSeriesEcon","title":"Base.:*","text":"3 * ts\nts * 3 returns timeseries with every element multiplied by 3\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#Base.:/-Union{Tuple{T}, Tuple{TSeries{T,C} where C<:AbstractArray{Float64,1},Number}} where T<:Frequency","page":"TimeSeriesEcon","title":"Base.:/","text":"ts / 3 returns timeseries with every element divided by 3\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#Base.diff-Union{Tuple{TSeries{T,C} where C<:AbstractArray{Float64,1}}, Tuple{T}, Tuple{TSeries{T,C} where C<:AbstractArray{Float64,1},Int64}} where T<:Frequency","page":"TimeSeriesEcon","title":"Base.diff","text":"diff(x::TSeries, k::Int64 = -1)\n\nSame as Iris implementation of diff\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#Base.getindex-Union{Tuple{T}, Tuple{TSeries{T,C} where C<:AbstractArray{Float64,1},AbstractArray{MIT{T},1}}} where T<:Frequency","page":"TimeSeriesEcon","title":"Base.getindex","text":"getindex using Vector{MIT}. Note the difference between Vector{MIT} and UnitRange{MIT}\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#Base.getindex-Union{Tuple{T}, Tuple{TSeries{T,C} where C<:AbstractArray{Float64,1},AbstractUnitRange{MIT{T}}}} where T<:Frequency","page":"TimeSeriesEcon","title":"Base.getindex","text":"getindex using UnitRange{MIT}\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#Base.getindex-Union{Tuple{T}, Tuple{TSeries{T,C} where C<:AbstractArray{Float64,1},MIT{T}}} where T<:Frequency","page":"TimeSeriesEcon","title":"Base.getindex","text":"getindex using MIT\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#Base.hcat-Union{Tuple{Vararg{TSeries{T,C} where C<:AbstractArray{Float64,1},N}}, Tuple{T}, Tuple{N}} where T<:Frequency where N","page":"TimeSeriesEcon","title":"Base.hcat","text":"Horizonatal Concatenation of `TSeries`\n\nExamples\n\njulia> a = TSeries(ii(1), ones(3));\njulia> b = TSeries(ii(2), ones(3));\njulia> [a b]\n4×2 Array{Float64,2}:\n   1.0  NaN\n   1.0    1.0\n   1.0    1.0\n NaN      1.0\n\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#Base.setindex!-Union{Tuple{T}, Tuple{TSeries{T,C} where C<:AbstractArray{Float64,1},AbstractArray{#s13,1} where #s13<:Number,AbstractUnitRange{MIT{T}}}} where T<:Frequency","page":"TimeSeriesEcon","title":"Base.setindex!","text":"setindex a vector using UnitRange{MIT}\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#Base.setindex!-Union{Tuple{T}, Tuple{TSeries{T,C} where C<:AbstractArray{Float64,1},Number,AbstractUnitRange{MIT{T}}}} where T<:Frequency","page":"TimeSeriesEcon","title":"Base.setindex!","text":"setindex a value using UnitRange{MIT}\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#Base.setindex!-Union{Tuple{T}, Tuple{TSeries{T,C} where C<:AbstractArray{Float64,1},Number,MIT{T}}} where T<:Frequency","page":"TimeSeriesEcon","title":"Base.setindex!","text":"setindex a value using MIT\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#Base.setindex!-Union{Tuple{T}, Tuple{TSeries{T,C} where C<:AbstractArray{Float64,1},TSeries{T,C} where C<:AbstractArray{Float64,1},AbstractUnitRange{MIT{T}}}} where T<:Frequency","page":"TimeSeriesEcon","title":"Base.setindex!","text":"setindex values from other TSeries using UnitRange{MIT}\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#Base.setindex!-Union{Tuple{T}, Tuple{TSeries{T,C} where C<:AbstractArray{Float64,1},TSeries{T,C} where C<:AbstractArray{Float64,1},MIT{T}}} where T<:Frequency","page":"TimeSeriesEcon","title":"Base.setindex!","text":"setindex values from other TSeries using MIT\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.apct","page":"TimeSeriesEcon","title":"TimeSeriesEcon.apct","text":"apct(x::TSeries, islog::Bool)\n\nCalculate annualised percent rate of change in x.\n\nNote: The implementation is similar to IRIS.\n\nExamples\n\njulia> x = TSeries(qq(2018, 1), Vector(1:8));\n\njulia> apct(x)\nTSeries{Quarterly} of length 7\n2018Q2: 1500.0\n2018Q3: 406.25\n2018Q4: 216.04938271604937\n2019Q1: 144.140625\n2019Q2: 107.35999999999999\n2019Q3: 85.26234567901243\n2019Q4: 70.59558517284461\n\nSee also: pct\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.firstdate-Tuple{TSeries}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.firstdate","text":"firstdate(x::TSeries)\n\nReturn an MIT indicating the first date in the TSeries.\n\nExamples\n\njulia> firstdate(TSeries(qq(2020, 1), ones(10)))\n2020Q1\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.frequencyof-Tuple{Any}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.frequencyof","text":"frequencyof(::MIT)\nfrequencyof(::Type{MIT})\n\nReturn the Frequency type of the given MIT instance of type.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.frequencyof-Union{Tuple{TSeries{T,C} where C<:AbstractArray{Float64,1}}, Tuple{T}} where T<:Frequency","page":"TimeSeriesEcon","title":"TimeSeriesEcon.frequencyof","text":"Can be applied to a TSeries instance or a range of MIT to return its Frequency.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.ii-Tuple{Int64}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.ii","text":"ii(x::Int64)\n\nRepresents an Integer date and return MIT{Unit} type instance\n\nExamples\n\njulia> ii(123)\nii(123)\n\njulia> ii(123) + 5\nii(128)\n\njulia> typeof(ii(123))\nMIT{Unit}\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.lastdate-Tuple{TSeries}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.lastdate","text":"lastdate(x::TSeries)\n\nReturn an MIT indicating the last date in the TSeries.\n\nExamples\n\njulia> lastdate(TSeries(qq(2020, 1), ones(10)))\n2022Q2\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.leftcropnan!-Tuple{TSeries}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.leftcropnan!","text":"leftcropnan!(x::TSeries)\n\nRemove NaN values from starting at the beginning of x, in-place.\n\nNote: an internal function.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.mitrange-Tuple{TSeries}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.mitrange","text":"mitrange(x::TSeries)\n\nReturn an UnitRange{MIT{<:Frequency}} associated with x.\n\nExamples\n\njulia> mitrange(TSeries(qq(2020, 1), ones(4)))\n2020Q1:2020Q4\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.mm-Tuple{Any,Any}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.mm","text":"mm(y::Int64, p::Int64)\n\nRepresents a Monthly date and returns MIT{Monthly} type instance.\n\nExamples\n\njulia> mm(2020, 1)\n2020M1\n\njulia> mm(2020, 1) + 5\n2020M6\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.nanrm!","page":"TimeSeriesEcon","title":"TimeSeriesEcon.nanrm!","text":"nanrm!(s::TSeries, type::Symbol)\n\nRemove NaN values that are either at the beginning of the s and/or end of x.\n\nExamples\n\njulia> s = TSeries(yy(2018), [NaN, NaN, 1, 2, NaN]);\n\njulia> nanrm!(s);\n\njulia> s\nTSeries{Yearly} of length 2\n2020Y: 1.0\n2021Y: 2.0\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.pct-Tuple{TSeries,Int64}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.pct","text":"pct(x::TSeries, shift_value::Int64, islog::Bool)\n\nCalculate percentage growth in x given a shift_value.\n\nNote: The implementation is similar to IRIS.\n\nExamples\n\njulia> x = TSeries(yy(2000), Vector(1:4));\n\njulia> pct(x, -1)\nTSeries{Yearly} of length 3\n2001Y: 100.0\n2002Y: 50.0\n2003Y: 33.33333333333333\n\nSee also: apct\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.period-Union{Tuple{MIT{T}}, Tuple{T}} where T<:Frequency","page":"TimeSeriesEcon","title":"TimeSeriesEcon.period","text":"period(x::MIT)\n\nReturn ::Int64 representing period for a given MIT\n\nExamples\n\njulia> period(mm(2020, 1))\n1\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.ppy-Union{Tuple{MIT{F}}, Tuple{F}} where F<:Frequency","page":"TimeSeriesEcon","title":"TimeSeriesEcon.ppy","text":"ppy(::MIT)\nppy(::Type{MIT})\n\nWhen applied to an MIT instance or type, return the ppy of its frequency.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.ppy-Union{Tuple{TSeries{T,C} where C<:AbstractArray{Float64,1}}, Tuple{T}} where T<:Frequency","page":"TimeSeriesEcon","title":"TimeSeriesEcon.ppy","text":"ppy(::TSeries)\nppy(::Type{TSeries})\n\nWhen applied to a TSeries instance or type, return the ppy of its frequency.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.ppy-Union{Tuple{Type{T}}, Tuple{T}} where T<:Monthly","page":"TimeSeriesEcon","title":"TimeSeriesEcon.ppy","text":"ppy(::Frequency)\n\nReturns the number of periods per year for a given Frequency, MIT, and TSeries\n\nExamples\n\njulia> ppy(Quarterly)                   # Frequency\n4\n\njulia> ppy(mm(2020, 1))                 # MIT\n12\n\njulia> ppy(TSeries(yy(2020), ones(3)))   # TSeries\n1\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.qq-Tuple{Any,Any}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.qq","text":"qq(y::Int64, p::Int64)\n\nRepresents a Quarterly date and returns MIT{Quarterly} type instance.\n\nExamples\n\njulia> qq(2020, 1)\n2020Q1\n\njulia> qq(2020, 1) + 5\n2021Q2\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.rightcropnan!-Tuple{TSeries}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.rightcropnan!","text":"rightcropnan!(x::TSeries)\n\nRemove NaN values from the end of x\n\nNote: an internal function.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.shift!-Union{Tuple{T}, Tuple{TSeries{T,C} where C<:AbstractArray{Float64,1},Int64}} where T<:Frequency","page":"TimeSeriesEcon","title":"TimeSeriesEcon.shift!","text":"shift!(x::TSeries, n::Int64)\n\nShift dates of x back by k periods, in-place.  Note: The implementation of is similar to IRIS ts{1}.\n\nExamples\n\njulia> x = TSeries(qq(2020, 1), ones(4));\n\njulia> shift!(x, 1);\n\njulia> x\nTSeries{Quarterly} of length 4\n2019Q4: 1.0\n2020Q1: 1.0\n2020Q2: 1.0\n2020Q3: 1.0\n\nSee also: shift\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.shift-Union{Tuple{T}, Tuple{TSeries{T,C} where C<:AbstractArray{Float64,1},Int64}} where T<:Frequency","page":"TimeSeriesEcon","title":"TimeSeriesEcon.shift","text":"shift(x::TSeries, n::Int64)\n\nShift dates of x back by k periods.  Note: The implementation of is similar to IRIS ts{1}.\n\nExamples\n\njulia> shift(TSeries(qq(2020, 1), ones(4)), 1)\nTSeries{Quarterly} of length 4\n2019Q4: 1.0\n2020Q1: 1.0\n2020Q2: 1.0\n2020Q3: 1.0\n\n\njulia> shift(TSeries(qq(2020, 1), ones(4)), -1)\nTSeries{Quarterly} of length 4\n2020Q2: 1.0\n2020Q3: 1.0\n2020Q4: 1.0\n2021Q1: 1.0\n\nSee also: shift!\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.year-Union{Tuple{MIT{T}}, Tuple{T}} where T<:Frequency","page":"TimeSeriesEcon","title":"TimeSeriesEcon.year","text":"year(x::MIT)\n\nReturn ::Int64 representing year for a given MIT\n\nNote: an internal method for now.\n\nExamples\n\njulia> year(mm(2020, 1))\n2020\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.yy","page":"TimeSeriesEcon","title":"TimeSeriesEcon.yy","text":"yy(y::Int64)\n\nRepresents a Yearly date and returns MIT{Yearly} type instance.\n\nExamples\n\njulia> yy(2020)\n2020Y\n\njulia> yy(2020) + 5\n2025Y\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.@rec-Tuple{Any,Any}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.@rec","text":"@rec(eqn, rng)\n\nComputes recursive calculations for the given eqn and rng.\n\nExamples\n\njulia> s = TSeries(ii(1), zeros(1));\n\njulia> # Initial values\n\njulia> s[ii(1)] = 0;\n\njulia> s[ii(2)] = 1;\n\njulia> @rec s[t] = s[t-1] + s[t-2] ii(3):ii(10)\n\njulia> s\nTSeries{Unit} of length 10\nii(1): 0.0\nii(2): 1.0\nii(3): 1.0\nii(4): 2.0\nii(5): 3.0\nii(6): 5.0\nii(7): 8.0\nii(8): 13.0\nii(9): 21.0\nii(10): 34.0\n\n\n\n\n\n","category":"macro"},{"location":"Tutorials/TimeSeriesEcon/main/#TimeSeriesEcon","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"","category":"section"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"All the code contained here is also available in this file: main.jl.","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"Pages = [\"main.md\"]\nDepth = 3","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"using TimeSeriesEcon\nusing Plots","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/#Part-1:-MIT-and-TSeries","page":"TimeSeriesEcon","title":"Part 1: MIT and TSeries","text":"","category":"section"},{"location":"Tutorials/TimeSeriesEcon/main/#Initialize-MITs-and-TSeries","page":"TimeSeriesEcon","title":"Initialize MITs and TSeries","text":"","category":"section"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"MIT (Moment-in-Time) is a primitive type based on 64-bit signed integers that  represents discrete dates. There are two ways to initialize  MITs: ","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"(1) directly 2020M8, or \n(2) using the functional form mm(2020, 8).","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"Internally, MIT contains Frequency information - more on this in the next section. ","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"mit_integer = 2000U  # ii(2000)\n\nmit_monthly = 2020M8 # mm(2020, 8)\n\nmit_quarterly = 2020Q3 # qq(2020, 3)\n\nmit_yearly = 2020Y  # yy(2020)","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"TSeries is subtype of AbstractVector and represents 1-dimensional time-series. A key feature of TSeries is the ability to use MITs as indices to get and set values. ","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"note: Note\nTSeries converts all values to Float64. The automatic conversion feature might be changed in the future.","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"series_monthly = TSeries(2020M1, rand(1:10, 6))","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"There are various ways to initialize TSeries - here, we provided an MIT that represents the first date in the series and a vector of random values.","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"As you can see, the frequency of MIT carries over to a TSeries instance.","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/#Frequency","page":"TimeSeriesEcon","title":"Frequency","text":"","category":"section"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"Every instance of MIT and TSeries is equipped with Frequency information, which is stored as a parameter.","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"frequencyof(2020M8)\nfrequencyof(series_monthly)","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"As such, we can avoid performing operations on TSeries or MITs of different frequencies. Also, having Frequency parameter simplifies the retrieval of frequency specific information.","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"year(2020M8)\nperiod(2020M8)\n\nppy(2020M8) # number of periods per year","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/#Part-2:-Indexing-using-MITs","page":"TimeSeriesEcon","title":"Part 2: Indexing using MITs","text":"","category":"section"},{"location":"Tutorials/TimeSeriesEcon/main/#Access","page":"TimeSeriesEcon","title":"Access","text":"","category":"section"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"Just as integers are used to index into Julia vectors, MITs are used to index into TSeries. ","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"Indexing using a single MIT returns a float value associated with that date.\nIndexing using a range of MITs will return another TSeries instance","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"series_monthly\n\nseries_monthly[2020M1]\nseries_monthly[2020M1:2020M3]","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/#Assign","page":"TimeSeriesEcon","title":"Assign","text":"","category":"section"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"series_monthly[2020M1] = -1;\nseries_monthly\n\nseries_monthly[2020M2:end] = -1;\nseries_monthly","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"You can also assign values outside of the bounds that were initially declared.","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"series_monthly[end + 2] = -1;\nseries_monthly","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/#Part-3:-Plots-and-helpful-functions","page":"TimeSeriesEcon","title":"Part 3: Plots and helpful functions","text":"","category":"section"},{"location":"Tutorials/TimeSeriesEcon/main/#Plotting-support","page":"TimeSeriesEcon","title":"Plotting support","text":"","category":"section"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"Using the Plots package, we can plot multiple TSeries with varying frequency.","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"plot(TSeries(2000Q1, rand(1:3, 10)), \n     TSeries(2000M1, rand(4:6, 30)),\n     legend=true, \n     title=\"TSeries Plot\", \n     labels=[\"Quarterly\", \"Monthly\"],\n     size=(600, 400)\n    );","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"savefig(\"tseries.png\")","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"(Image: TSeries Graph)","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/#Conversions","page":"TimeSeriesEcon","title":"Conversions","text":"","category":"section"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"note: Note\nSupport for frequency conversion from low to high is under development.","category":"page"},{"location":"Tutorials/TimeSeriesEcon/main/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"tsmonthly = TSeries(2020M1, collect(1:12));\n\n# Monthly -> Quarterly\ntsquarterly = convert(TSeries{Quarterly}, tsmonthly)\n\n# Monthly -> Yearly\ntsyearly = convert(TSeries{Yearly}, tsmonthly)","category":"page"},{"location":"Tutorials/README/#README","page":"README","title":"README","text":"","category":"section"},{"location":"Tutorials/README/","page":"README","title":"README","text":"This project contains a list of tutorials demonstrating the use of StateSpaceEcon group of Julia packages. Each tutorial is in its own subdirectory. They are meant to run in a Julia session running in the root directory of the project, which is what happens in VSCode, not in the subdirectory of the specific tutorial.","category":"page"},{"location":"Tutorials/README/#Installation","page":"README","title":"Installation","text":"","category":"section"},{"location":"Tutorials/README/","page":"README","title":"README","text":"The tutorials are designed to run in the Julia environment in the root of the project. Before the first use, make sure to instantiate the environment.","category":"page"},{"location":"Tutorials/README/","page":"README","title":"README","text":"] activate .\n] instantiate","category":"page"},{"location":"Tutorials/README/","page":"README","title":"README","text":"After that, make sure the environment is active when you run the tutorial codes.","category":"page"},{"location":"Tutorials/README/#List-of-tutorials","page":"README","title":"List of tutorials","text":"","category":"section"},{"location":"Tutorials/README/","page":"README","title":"README","text":"Each tutorial is in its own subdirectory and contains a main.jl and main.md in addition to other files. The two main files contain the same code and explanations. If running the tutorial code yourself, you should use the .jl file.","category":"page"},{"location":"Tutorials/README/","page":"README","title":"README","text":"Smets and Wouters 2007\nTimeSeriesEcon","category":"page"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon-Reference","page":"StateSpaceEcon","title":"StateSpaceEcon Reference","text":"","category":"section"},{"location":"Reference/StateSpaceEcon/","page":"StateSpaceEcon","title":"StateSpaceEcon","text":"Pages = [\"statespaceecon.md\"]","category":"page"},{"location":"Reference/StateSpaceEcon/#Steady-state-solver","page":"StateSpaceEcon","title":"Steady state solver","text":"","category":"section"},{"location":"Reference/StateSpaceEcon/","page":"StateSpaceEcon","title":"StateSpaceEcon","text":"Modules = [StateSpaceEcon.SteadyStateSolver]\nPrivate = false","category":"page"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver","text":"SteadyStateSolver\n\nA module that is part of StateSpaceEcon package. Contains methods for finding a steady state of a model.\n\n\n\n\n\n","category":"module"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.check_sstate-Tuple{Model}","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.check_sstate","text":"check_sstate(model; <options>)\n\nRun a diagnostic test to determine if the steady state solution stored within the given model object is indeed a solution of the steady state system of equations.\n\nReturn the number of steady state equations that are violated by the current steady state solution. If verbose=true, also display diagnostic information in the form of listing all bad equations and their residuals.\n\nOptions\n\nStandard options (default values from model.options)\n\nverbose \ntol - an equation is considered satisfied if its residual, in absolute value, is smaller than this number.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.clear_sstate!-Tuple{Model}","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.clear_sstate!","text":"clear_sstate!(model; lvl=0.1, slp=0.0, <options>)\n\nSet the steady state values to the provided defaults and presolve.\n\nArguments\n\nmodel - the model instance\nlvl, slp - the initial guess for the level and the slope. Each could be a number or a vector of length equal to the number of variable in the mode.\n\nOptions\n\nStandard options (default values are taken from model.options)\n\nverbose\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.diagnose_sstate-Tuple{Model}","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.diagnose_sstate","text":"diagnose_sstate([point,] model)\n\nRun diagnostics on the steady state of the given model. If point is not given, then we check the steady state solution stored inside the given model.\n\nReturn a tuple of \"bad\" equations and \"bad\" variables. \n\nThe set of \"bad\" equations is one that is inconsistent, i.e. there is no solution. This might happen if the system is overdetermined.\n\nThe set of \"bad\" variables contains variables that cannot be solved uniquely. This might happen if the system is underdetermined. In this case, try adding steady state constraints until you get a unique solution. See @steadystate in ModelBaseEcon.\n\nwarning: Internal function\nThe output from this function may be difficult to read.<br> Call check_sstate instead.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.initial_sstate!-Tuple{Model,AbstractArray{Float64,1}}","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.initial_sstate!","text":"initial_sstate!(model, init; <options>)\n\nSet the steady state values from the given vector and presolve.\n\nCall this function to specify initial guesses for the iterative steady state solver. If the value of a steady state variable is known, it is better to use @steadystate to add that as a steady state constraint.\n\nArguments\n\nmodel - the model.\ninit - a vector of length equal to twice the number of variables in the model. The level and slope values are staggered, i.e., the level and slope of variable j are in init[2j-1] and init[2j].\n\nOptions\n\nStandard options (default values are taken from model.options)\n\nverbose\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.sssolve!-Tuple{Model}","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.sssolve!","text":"sssolve!(model; <options>)\n\nSolve the steady state problem for the given model.\n\nOptions\n\nStandard options (default values are taken from model.options)\n\nverbose\ntol, maxiter - control the stopping criteria of the solver\n\nSpecific options\n\npresolve::Bool - whether or not to use a presolve pass. Default is true.\nmethod::Symbol - choose the solution algorithm. Valid options are :nr for Newton-Raphson, :lm for Levenberg-Marquardt, and :auto. The :auto method starts with the LM algorithm and automatically switches to NR when it starts to converge. Default is :nr.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#Plans","page":"StateSpaceEcon","title":"Plans","text":"","category":"section"},{"location":"Reference/StateSpaceEcon/","page":"StateSpaceEcon","title":"StateSpaceEcon","text":"Modules = [StateSpaceEcon.Plans]\nPrivate = false","category":"page"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans","text":"Plans\n\nModule part of StateSpaceEcon. This module implements the Plan data structure, which is used in simulations. The plan object contains information about the range of the simulation and which variables and shocks are exogenous or endogenous at each period of the range.\n\nConstructors\n\nPlan(model, range)\n\nModify the plan\n\nexogenize!, endogenize! - make variables exogenous or endogenous\nexog_endo!, endo_exog! - swap exogenous and endogenous variables\nautoexogenize! - exogenize and endogenize variables according to the list in the model\n\nPrepare data for simulation\n\nzeroarray, zerodict, zerodata - prepare a matrix or a dictionary or a SimData of data for the simulation containing zeros.\nsteadystatearray, steadystatedict, steadystatedata - prepare a matrix or a dictionary or a SimData of data for the simulation containing the steady state.\n\n\n\n\n\n","category":"module"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.Plan","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.Plan","text":"Plan{T <: MIT}\n\nA data structure representing the simulation plan. It holds information about the time range of the simulation and which variables/shocks are exogenous at each period.\n\n\n\n\n\n","category":"type"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.Plan-Tuple{Model,AbstractUnitRange}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.Plan","text":"Plan(model, range)\n\nCreate a default simulation plan for the given model over the given range. The range of the plan is augmented to include periods before and after the given range, over which initial and final conditions will be applied. \n\nInstead of a range, one could also pass in a single moment in time (MIT) instance, in which case it is interpreted as a range of length 1.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.autoexogenize!-Tuple{Plan,Model,Any}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.autoexogenize!","text":"autoexogenize!(plan, model, date)\n\nModify the given plan according to the \"autoexogenize\" protocol defined in the given model. All variables in the autoexogenization list become endogenous and their corresponding shocks become exogenous over the given date or range. date can be a moment in time (same frequency as the given plan), a range, an iterable, or a container.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.endo_exog!-Tuple{Plan,Any,Any,Any}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.endo_exog!","text":"endo_exog!(plan, endo_vars, exog_vars, date)\n\nModify the given plan so that the given variables listed in exog_vars will be exogenous and the variables listed in endo_vars will be endogenous on the given dates. exog_vars and endo_vars can each be a Symbol or a String or a Vector of such. date can be a moment in time (same type as the plan), or a range or an iterable or a container.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.endogenize!-Tuple{Plan,Any,Any}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.endogenize!","text":"endogenize!(plan, vars, date)\n\nModify the given plan so that the given variables will be endogenous on the given dates. vars can be a Symbol or a String or a Vector of such. date can be a moment in time (same type as the plan), or a range or an iterable or a container.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.exog_endo!-Tuple{Plan,Any,Any,Any}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.exog_endo!","text":"exog_endo!(plan, exog_vars, endo_vars, date)\n\nModify the given plan so that the given variables listed in exog_vars will be exogenous and the variables listed in endo_vars will be endogenous on the given dates. exog_vars and endo_vars can each be a Symbol or a String or a Vector of such. date can be a moment in time (same type as the plan), or a range or an iterable or a container.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.exogenize!-Tuple{Plan,Any,Any}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.exogenize!","text":"exogenize!(plan, vars, date)\n\nModify the given plan so that the given variables will be exogenous on the given dates. vars can be a Symbol or a String or a Vector of such. date can be a moment in time (same type as the plan), or a range or an iterable or a container.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.plansum-Tuple{Model,Plan}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.plansum","text":"plansum(model, plan)\n\nReturn the total number of exogenous variables in the simulation plan. Periods over which initial and final conditions are imposed are not counted in this sum.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.setexog!-Tuple{Plan,Int64,Any}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.setexog!","text":"setexog!(plan, t, vinds)\n\nModify the plan at time t such that vinds are exogenous and the rest are endogenous.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.steadystatearray-Tuple{Model,AbstractUnitRange}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.steadystatearray","text":"steadystatearray(model, plan)\nsteadystatearray(model, range)\n\nCreate a matrix of the proper dimensions for a simulation with the given model with the given plan or over the given range. The matrix is initialized with the steady state level of each variable. If a range is given rather than a plan, it is augmented with periods before and after the given range in order to accommodate initial and final conditions.\n\nSee also: zeroarray, zerodict, steadystatearray, steadystatedict\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.steadystatedata-Tuple{Model,AbstractUnitRange}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.steadystatedata","text":"steadystatedata(model, plan)\nsteadystatedata(model, range)\n\nCreate a SimData containing a TSeries of the appropriate range for each variable in the model for a simulation with the given plan or over the given range. The matrix is initialized with the steady state level of each variable. If a range is given rather than a plan, it is augmented with periods before and after the given range in order to accommodate initial and final conditions.\n\nSee also: zeroarray, zerodict, steadystatearray, steadystatedict\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.steadystatedict-Tuple{Model,AbstractUnitRange}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.steadystatedict","text":"steadystatearray(model, plan)\nsteadystatearray(model, range)\n\nCreate a dictionary containing a TSeries of the appropriate range for each variable in the model for a simulation with the given plan or over the given range. The matrix is initialized with the steady state level of each variable. If a range is given rather than a plan, it is augmented with periods before and after the given range in order to accommodate initial and final conditions.\n\nSee also: zeroarray, zerodict, steadystatearray, steadystatedict\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.zeroarray-Tuple{Model,Plan}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.zeroarray","text":"zeroarray(model, plan)\nzeroarray(model, range)\n\nCreate a matrix of the proper dimension for a simulation with the given model with the given plan or over the given range. If a range is given, the data is prepared for the default plan. This means that appropriate number of periods are added before and after the range to account for initial and final conditions.\n\nSee also: zeroarray, zerodict, steadystatearray, steadystatedict\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.zerodata-Tuple{Model,Plan}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.zerodata","text":"zerodata(model, plan)\nzerodata(model, range)\n\nCreate a NamedTuple containing a TSeries of the appropriate range for each variable in the model for a simulation with the given plan or over the given range. If a range is given rather than a plan, the data is prepared for the default plan over that range. This means that appropriate number of periods are added before and after the range to account for initial and final conditions.\n\nSee also: zeroarray, zerodict, steadystatearray, steadystatedict\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.zerodict-Tuple{Model,Plan}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.zerodict","text":"zerodict(model, plan)\nzerodict(model, range)\n\nCreate a dictionary containing a TSeries of the appropriate range for each variable in the model for a simulation with the given plan or over the given range. If a range is given rather than a plan, the data is prepared for the default plan over that range. This means that appropriate number of periods are added before and after the range to account for initial and final conditions.\n\nSee also: zeroarray, zerodict, steadystatearray, steadystatedict\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#Stacked-time-solver","page":"StateSpaceEcon","title":"Stacked time solver","text":"","category":"section"},{"location":"Reference/StateSpaceEcon/","page":"StateSpaceEcon","title":"StateSpaceEcon","text":"Modules = [StateSpaceEcon.StackedTimeSolver]\nPrivate = false","category":"page"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver","text":"StackedTimeSolver\n\nA module that is part of StateSpaceEcon package. Contains methods for solving the dynamic system of equations for the model and running simulations.\n\n\n\n\n\n","category":"module"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.FCType","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.FCType","text":"FCType\n\nAn enumeration type representing the possible types of final conditions.\n\nfcgiven - the final conditions are provided by the user.\nfclevel - the final conditions are prescribed from the levels of the steady state solution.\nfcslope - the final conditions are such that the slope of the dynamic solution matches the slope of the steady state solution.\n\n\n\n\n\n","category":"type"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.array2data-Tuple{AbstractArray{Float64,2},AbstractArray{#s68,1} where #s68<:AbstractString,MIT}","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.array2data","text":"array2data(data, vars, start_date)\n\nConvert the simulation data array to a named tuple.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.array2dict-Tuple{AbstractArray{Float64,2},AbstractArray{#s68,1} where #s68<:AbstractString,MIT}","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.array2dict","text":"array2dict(data, vars, start_date)\n\nConvert the simulation data array to a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.dict2array-Tuple{Dict{#s32,#s31} where #s31 where #s32<:AbstractString,AbstractArray{#s30,1} where #s30<:AbstractString}","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.dict2array","text":"dict2array(d, vars; range)\n\nConvert a dictionary of TSeries to a 2d array of simulation data for the given range.  The range argument is optional and defaults to nothing.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.dictoverlay-Tuple{Dict{String,#s41} where #s41,Dict{String,#s40} where #s40}","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.dictoverlay","text":"dictoverlay(d1, d2)\n\nMerge two dictionaries. Common key where the values are TSeries of the same frequency are overlayed. Otherwise, a common key takes the value of the last Dict containing it.\n\nSee also: seriesoverlay\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.seriesoverlay-Tuple{TSeries,TSeries}","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.seriesoverlay","text":"seriesoverlay(ts1, ts2)\n\nReturn a new TSeries over the full range of both arguments. The overlapping part contains values from the last argument.\n\nSee also: dictoverlay\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.simulate-Tuple{Model,Plan,AbstractArray{Float64,2}}","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.simulate","text":"simulate(model, plan, data; <options>)\n\nRun a simulation for the given model, simulation plan and exogenous data.\n\nArguments\n\nmodel - the Model instance to simulate.\nplan - the Plan for the simulation.\ndata - a 2D Array containing the exogenous data. This includes the initial and final conditions.\n\nOptions as keyword arguments\n\nfctype::FCType - set the desired final condition type for the simulation. The default value is fcgiven. Other possible values include fclevel and fcslope.\ninitial_guess::AbstractMatrix{Float64} - a 2D Array containing the initial guess for the solution. This is used to start the Newton-Raphson algorithm. The default value is an empty array (zeros(0,0)), in which case we use the exogenous data for the initial condition. You can use the steady state solution using steadystatearray.\nlinearize::Bool - set to true to instruct the solver to use the liearized model. If the model is already linearized, this option has the effect that the model gets linearized about the current steady stat and with the value of deviation given here. Otherwise the model is linearized about the steady state. After the simulation is computed, the model is restored to its original state. Default value is false.\ndeviation::Bool - set to true if the data is in deviations from the steady state. This is only relevant if the linearize option is set to true. Default value is false.\nanticipate::Bool - set to false to instruct the solver that all shocks are unanticilated by the agents. Default value is true.\nverbose::Bool - control whether or not to print progress information. Default value is taken from model.options.\ntol::Float64 - set the desired accuracy. Default value is taken from model.options.\nmaxiter::Int - algorithm fails if the desired accuracy is not reached within this maximum number of iterations. Default value is taken from model.options.\n\nSee also:\n\nExamples\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#Various","page":"StateSpaceEcon","title":"Various","text":"","category":"section"},{"location":"Reference/StateSpaceEcon/","page":"StateSpaceEcon","title":"StateSpaceEcon","text":"Modules = [StateSpaceEcon]\nPrivate = false","category":"page"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StateSpaceEcon","page":"StateSpaceEcon","title":"StateSpaceEcon.StateSpaceEcon","text":"StateSpaceEcon\n\nA package for Macroeconomic modelling.\n\n\n\n\n\n","category":"module"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SimData","page":"StateSpaceEcon","title":"StateSpaceEcon.SimData","text":"SimData\n\nData structure containing the time series data for a simulation.\n\nIt is a collection of TSeries of the same frequency and containing data for the same range. When used for simulation, the range must include the initial conditions, the simulation range and the final conditions, although it could extend beyond that. It must contain time series for all variables and shocks in the model, although it might contain other time series.\n\n\n\n\n\n","category":"type"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.printmatrix-Tuple{Any,Vararg{Any,N} where N}","page":"StateSpaceEcon","title":"StateSpaceEcon.printmatrix","text":"printmatrix(mat [, Val(F), colnames])\n\nDisplay a matrix in full while controlling the formatting of each value and optionally showing the column names.\n\nVal(F) - display each number in the given format F. The format is in the form of a decimal point number where the whole part indicates the total width and the fractional part is the number of digits printed after the decimal point. Default is Val(12.7)\ncolnames - a list of names to display in the first row. The names are displayed as given, possibly with padding to match the width given in the Val argument. If any names are longer than that, they will not be truncated and so the display will not be aligned properly. Sorry about that!\n\n\n\n\n\n","category":"method"},{"location":"Tutorials/US_SW07/main/#Smets-and-Wouters-2007","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"You can follow the tutorial by reading this page and copying and pasting code into your Julia REPL session. In this case, you will need the model file, SW07.jl.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"All the code contained here is also available in this file: main.jl.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Pages = [\"main.md\"]\nDepth = 3","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"using StateSpaceEcon\nusing ModelBaseEcon\nusing TimeSeriesEcon\n\nusing Test\nusing Plots\nusing Random\nusing Distributions\n\n# Fix the random seed for reproducibility.\nRandom.seed!(1234);\n\n# We need the model file SW07.jl to be on the search path for modules.\nunique!(push!(LOAD_PATH, realpath(\".\"))) # hide\n","category":"page"},{"location":"Tutorials/US_SW07/main/#Part-1:-The-model","page":"Smets and Wouters 2007","title":"Part 1: The model","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/#Loading-the-model","page":"Smets and Wouters 2007","title":"Loading the model","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The model is described in its own dedicated module, which is contained in its own file, SW07.jl. We can load the module with using SW07; the model itself is a global variable called model within that module.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"using SW07\nm = SW07.model","category":"page"},{"location":"Tutorials/US_SW07/main/#Examining-the-model","page":"Smets and Wouters 2007","title":"Examining the model","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"This model is too big to fit all of its details in the REPL window, so only summary information is displayed. We can see the entire model with fullprint.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"fullprint(m)","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We can also examine individual components using the commands parameters, variables, shocks, equations.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"parameters(m)","category":"page"},{"location":"Tutorials/US_SW07/main/#Setting-the-model-parameters","page":"Smets and Wouters 2007","title":"Setting the model parameters","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We must not change any part of the model in the active Julia session except for the model parameters and steady state constraints. If we want to add variables, shocks, or equations, we must do so in the model module file and restart Julia to load the new model.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"When it comes to the model parameters, we can access them by their names from the model object using dot notation.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"m.crr # read a parameter value\nm.cgy = 0.5187 # modify a parameter value","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"note: Note\nIn this model the values of the parameters have been set according to the replication data.","category":"page"},{"location":"Tutorials/US_SW07/main/#Model-flags-and-options","page":"Smets and Wouters 2007","title":"Model flags and options","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"In addition to model parameters, which are values that appear in the model equations, the model object also holds two other sets of parameters, namely flags and options.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Flags are (usually boolean) values which characterize the type of model we have. For example, a linear model should have its linear flag set to true. Typically, this is done in the model file before calling @initialize.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"m.flags","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Options are values that adjust the operations of the algorithms. For example, we have tol and maxiter, which set the desired accuracy and maximum number of iterations for the iterative solvers. These can be adjusted as needed at any time. Another useful option is verbose, which controls the level of verbosity of the different commands.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Many functions in StateSpaceEcon have optional arguments of the same name as a model option. When the argument is not explicitly given in the function call, these functions will use the value from the model option of the same name.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"m.verbose = true\nm.options","category":"page"},{"location":"Tutorials/US_SW07/main/#Part-2:-The-steady-state-solution","page":"Smets and Wouters 2007","title":"Part 2: The steady state solution","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The steady state is a special solution of the dynamic system that remains constant over time. It is important on its own, but also it can be useful in several ways. For example, linearizing the model requires a particular solution about which to linearize, and the steady state is typically used for this purpose.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"In addition to the steady state, we also consider another kind of special solution which grows linearly in time. If we know that the steady state solution is constant (i.e., its slope is zero), we can set the model flag ssZeroSlope to true. This is not required; however in a large model it might help the steady state solver converge faster to the solution.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The model object m stores information about the steady state. This includes the steady state solution itself, as well as a (possibly empty) set of additional constraints that apply only to the steady state. This information can be accessed via m.sstate.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"m.sstate","category":"page"},{"location":"Tutorials/US_SW07/main/#steady_state_constraints","page":"Smets and Wouters 2007","title":"Steady state constraints","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Sometimes the steady state is not unique, and we can use steady state constraints to specify the particular steady state we want. Also, if the model is non-linear, these constraints can be used to help the steady state solver converge. Steady state constraints can be added with the @steadystate macro. The constraint can be as simple as giving a specific value; we can also write an equation with multiple variables. We're allowed to use model parameters in these equations as well.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"@steadystate m a = 5\nm.sstate","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We can clean up the constraints by emptying the constraints container.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"empty!(m.sstate.constraints)\nm.sstate","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"note: Important note\nSteady state constraints that are always valid can be pre-defined in the model file. In that case, all calls to the @steadystate macro must be made after calling @initialize.","category":"page"},{"location":"Tutorials/US_SW07/main/#Solving-for-the-steady-state","page":"Smets and Wouters 2007","title":"Solving for the steady state","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The steady state solution is stored within the model object. Before solving, we have to specify an initial condition. If the model is linear, this makes no difference, but in a non-linear model a good or a bad initial guess might be the difference between success and failure of the steady state solver.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We specify the initial guess by calling clear_sstate!. This call removes any previously stored solution, sets the initial guess, and runs the pre-solve pass of the steady state solver. The initial guess can be given with the lvl and slp arguments; if not provided, an initial guess is chosen automatically.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Once that's done, we call sssolve! to find the steady state. This function returns a Vector{Float64} containing the steady state solution, and it also writes that solution into the model object. The vector is of length 2*nvariables(m) and contains the level and the slope for each variable.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"clear_sstate!(m)\nsssolve!(m);","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"If in doubt, we can use check_sstate to make sure the steady state solution stored in the model object indeed satisfies the steady state system of equations. This function returns the number of equations that are not satisfied. A value of 0 is what we want to see. In verbose mode, it also lists the problematic equations and their residuals.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"check_sstate(m)","category":"page"},{"location":"Tutorials/US_SW07/main/#Examining-the-steady-state","page":"Smets and Wouters 2007","title":"Examining the steady state","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We can access the steady state solution via m.sstate using the dot notation.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"m.sstate.dc","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We can also assign new values to the steady state solution, but we should be careful to make sure it remains a valid steady state solution.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"m.sstate.dc.level = 0.43121\n@test check_sstate(m) > 0","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"As the code above shows, a wrong steady state solution (based on the specified precision in the tol option) will result in one or more equation not being satisfied. Let's put back the correct value.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"m.sstate.dc.level = 0.4312\n@test check_sstate(m) == 0","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We can examine the entire steady state solution with printsstate.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"printsstate(m)","category":"page"},{"location":"Tutorials/US_SW07/main/#Part-3:-Impulse-response","page":"Smets and Wouters 2007","title":"Part 3: Impulse response","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/#Simulation-plan","page":"Smets and Wouters 2007","title":"Simulation plan","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Before we can simulate the model, we have to decide on the length of the simulation and what data is available for each period, i.e., what values are known (exogenous). This is done with an object of type Plan.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"To create a plan, all we need is the model object and a range for the simulation.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"sim_rng = 2000Q1:2039Q4\np = Plan(m, sim_rng)","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The plan shows us the list of exogenous values (variable or shocks) for each period or sub-range of the simulation. By default, all shocks are exogenous and all variables are endogenous.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We also see that the range of the plan has been extended before and after the simulation range. This is necessary because we need to set initial and final conditions. The number of periods for initial conditions is equal to the largest lag in the model. Similarly, final conditions have to be imposed over as many periods as the largest lead.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"p.range          # the full range of the plan\ninit_rng = first(p.range):first(sim_rng)-1   # the range for initial conditions\nfinal_rng = last(sim_rng)+1:last(p.range)     # the range for final conditions\n@test length(init_rng) == m.maxlag\n@test length(final_rng) == m.maxlead","category":"page"},{"location":"Tutorials/US_SW07/main/#Exogenous-data","page":"Smets and Wouters 2007","title":"Exogenous data","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We have to provide the data for the simulation. We start with all zeros and fill in the external data, which must include initial conditions for all variable and shocks, exogenous values (according to the plan), and possibly final conditions.","category":"page"},{"location":"Tutorials/US_SW07/main/#Initial-conditions","page":"Smets and Wouters 2007","title":"Initial conditions","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"In this example, we want to simulate an impulse response, so it makes sense to start from the steady state, so that is what we set as the initial condition. We leave the initial conditions for the shocks at 0.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"exog = zerodata(m, p);\nfor var in variables(m)\n    exog[init_rng, var] = m.sstate[var].level\nend\nexog","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"tip: Pro tip\nThe above works because the steady state is stationary, i.e., all slopes are zero. If we had a model with linear growth steady state, we could do something like the following (see @rec):for var in variables(m)\n    ss = m.sstate[var]\n    exog[init_rng, var] = ss.level\n    if ss.slope != 0\n        # recursively update by adding the slope each period\n        @rec init_rng[2:end] exog[t, var] = exog[t - 1, var] + ss.slope\n    end\nend","category":"page"},{"location":"Tutorials/US_SW07/main/#Final-conditions","page":"Smets and Wouters 2007","title":"Final conditions","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"For the final conditions we can use the steady state again, because we expect that the economy will eventually return to it if the simulation is sufficiently long past the last shock. We can do this by assigning the values of the steady state to the final periods after the simulation, similarly to what we did with the initial conditions.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Alternatively, we can specify that we want to use the steady state in the call to simulate by passing fctype=fclevel. Yet another possibility is to set the final condition so that the solution slope matches the slope of the steady state by setting fctype=fcslope. In both cases, we do not need to set anything in the exogenous data array because those values would be ignored.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"tip: Pro tip\nIn the Smets and Wouters 2007 model the two ways of using the steady state for final conditions (level or slope) are equivalent, because the steady state here is stationary and unique. In models where the steady state has non-zero slope, or the steady state has zero slope but the level is not unique, we should use fctype=fcslope.","category":"page"},{"location":"Tutorials/US_SW07/main/#A-quick-sanity-check","page":"Smets and Wouters 2007","title":"A quick sanity check","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"If we were to run a simulation where the economy started in the steady state and there were no shocks at all, we'd expect that the economy would remain in steady state forever.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"ss = simulate(m, exog, p; fctype=fcslope);","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The simulated data, ss, should equal (up to the accuracy of the solution) the steady state data. Similar to zerodata, we can use steadystatedata to create a data set containing the steady state solution.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"@test ss ≈ steadystatedata(m, p)","category":"page"},{"location":"Tutorials/US_SW07/main/#Exogenous-data-2","page":"Smets and Wouters 2007","title":"Exogenous data","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"All shocks are exogenous by default. All we have left to do is to set the value of the shock.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Let's say that we want to shock epinf for the first four quarters by 0.1.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"exog[sim_rng[1:4], :epinf] = 0.1;\nexog[shocks(m)]","category":"page"},{"location":"Tutorials/US_SW07/main/#Running-the-simulation","page":"Smets and Wouters 2007","title":"Running the simulation","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We call simulate, providing the model, the exogenous data, and the plan. We also specify the type of final condition we want to impose.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"irf = simulate(m, exog, p, fctype=fcslope);","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We can now take a look at how some of the observable variables in the model have responded to this shock. We use plot from the Plots package to for that. We specify the variables we want to plot using vars and the names of the datasets being plotted (for the legend) in the names option.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"plot(ss, irf,\n     vars=(:pinfobs, :dy, :labobs, :robs),\n     names=(\"SS\", \"IRF\"),\n     legend=[true false false false],\n     size=(600, 400)\n    );","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"savefig(\"irf.png\")","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"(Image: Impulse Response Graph)","category":"page"},{"location":"Tutorials/US_SW07/main/#Part-4:-Stochastic-shocks-simulation","page":"Smets and Wouters 2007","title":"Part 4: Stochastic shocks simulation","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Now let's run a simulation with stochastic shocks. We will have random shocks over two years and then have no shocks for several years afterwards to allow time for the economy to return to its steady state.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"sim_rng = 2000Q1:2049Q4      # simulate 50 years starting 2000\nshk_rng = 2004Q1 .+ (0:7)    # shock 8 quarters starting in 2004\np = Plan(m, sim_rng)\ninit_rng = first(p.range):first(sim_rng) - 1\nfinal_rng = last(sim_rng) + 1:last(p.range)\nexog = zerodata(m, p);\nfor v in variables(m)\n    exog[init_rng, v] = m.sstate[v].level\nend","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The distributions of the shocks are assumed normal with mean zero and standard deviations that have been estimated in the replication data. We use packages Distributions and Random to draw the necessary random values.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"shk_dist = (ea = Normal(0.0, 0.4618),\n            eb = Normal(0.0, 1.8513),\n            eg = Normal(0.0, 0.6090),\n            eqs = Normal(0.0, 0.6017),\n            em = Normal(0.0, 0.2397),\n            epinf = Normal(0.0, 0.1455),\n            ew = Normal(0.0, 0.2089));\nfor (shk, dist) in pairs(shk_dist)\n    exog[shk_rng, shk] = rand(dist, length(shk_rng))\nend\nexog[shk_rng, shocks(m)]","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Now we are ready to simulate. We can set the shocks to be anticipated or unanticipated by setting the anticipate parameter in simulate.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"sim_a = simulate(m, exog, p; fctype=fcslope, anticipate=true);\nsim_u = simulate(m, exog, p; fctype=fcslope, anticipate=false);","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"As before, we can review the responses of the observed variables to these shocks using plot.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"observed = (:dy, :dc, :dinve, :labobs, :pinfobs, :dw, :robs);\nss = steadystatedata(m, p);\nplot(ss, sim_a, sim_u,\n     vars=observed,\n     names=(\"SS\", \"Anticipated\", \"Unanticipated\"),\n     legend=[true (false for i = 1:6)...],\n     linewidth=1.5,   # hide\n     size=(900, 600)  # hide\n    );","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"savefig(\"stoch_shk.png\")","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"(Image: Stochastic Shock Response Graph)","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We see that when the shocks are anticipated, the variables start to react to them right away; in the unanticipated case, there is no movement until the shocks actually hit.","category":"page"},{"location":"Tutorials/US_SW07/main/#Part-5:-Backing-out-historical-shocks","page":"Smets and Wouters 2007","title":"Part 5: Backing out historical shocks","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Now let's pretend that the simulated values are historical data and that we do not know the magnitude of the shocks. We can treat the observed (simulated) values of the variables as known by making them exogenous. At the same time we will make the shocks endogenous, so that we can solve for their values during the simulation.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The \"historic\" (simulated, assumed observed) range is from the first period of the simulation until the last shock in the previous exercise.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"hist_rng = first(sim_rng):last(shk_rng)","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We use exogenize! and endogenize! to set up a plan in which observed variables are exogenous and shocks are endogenous throughout the historic range.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"endogenize!(p, shocks(m), hist_rng);\nexogenize!(p, observed, hist_rng);\np","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"As we can see above, the plan now reflects our intentions.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Finally, we need to set up the exogenous data. This time we do not specify the shocks; instead, we assign the known data for the observed variables for the historic range. We start with initial conditions.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"exog = zerodata(m, p);\nfor v in variables(m)\n    exog[init_rng, v] = m.sstate[v].level\nend","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We take the observed data from the simulation above. We show the anticipated version first.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"for v in observed\n    exog[hist_rng, v] = sim_a[v]\nend\nback_a = simulate(m, exog, p, fctype=fcslope, anticipate=true);","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Now we show the unanticipated case.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"for v in observed\n    exog[hist_rng, v] = sim_u[v]\nend\nback_u = simulate(m, exog, p, fctype=fcslope, anticipate=false);","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"If we did everything correctly, the shocks we recovered must match exactly the shocks we used when we simulated the \"historical\" data.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"@test sim_a[shocks(m)] ≈ back_a[shocks(m)]\n@test sim_u[shocks(m)] ≈ back_u[shocks(m)]","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Moreover, we must have the unobserved variables match as well. In fact, all the data must match over the entire simulation range.","category":"page"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"@test sim_a ≈ back_a\n@test sim_u ≈ back_u","category":"page"},{"location":"Tutorials/US_SW07/main/#Appendix","page":"Smets and Wouters 2007","title":"Appendix","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/#replication_data","page":"Smets and Wouters 2007","title":"Replication Data","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The replication data can be downloaded from http://doi.org/10.3886/E116269V1","category":"page"},{"location":"Tutorials/US_SW07/main/#References","page":"Smets and Wouters 2007","title":"References","text":"","category":"section"},{"location":"Tutorials/US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Smets, F., Wouters, R., 2007. Shocks and frictions in US business cycles: A bayesian DSGE approach. The American Economic Review 97(3), 586–606.","category":"page"},{"location":"#Hello-World","page":"Hello World","title":"Hello World","text":"","category":"section"},{"location":"Tutorials/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"This section contains a list of tutorials demonstrating the use of StateSpaceEcon group of Julia packages.","category":"page"}]
}
