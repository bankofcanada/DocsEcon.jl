var documenterSearchIndex = {"docs":
[{"location":"Tutorials/1.TimeSeriesEcon/main/#Time-Series","page":"Time Series","title":"Time Series","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"In this tutorial we will see how to use the functionality provided in TimeSeriesEcon to manipulate time series data.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"All code presented here is also available in main.jl.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"Pages = [\"main.md\"]\nDepth = 3","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"using TimeSeriesEcon\nusing Statistics\nusing Plots","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"In this tutorial we need the following packages.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"using TimeSeriesEcon\nusing Statistics\nusing Plots","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#Frequency-and-Time","page":"Time Series","title":"Frequency and Time","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"In a time series the values are evenly spaced in time and each value is labelled with the moment in which it occurred. TimeSeriesEcon provides data types that represent these concepts.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#Frequency","page":"Time Series","title":"Frequency","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"The abstract type Frequency represents the idea of the frequency of a time series. All concrete frequencies are special cases. Currently we have four calendar frequencies, Yearly, HalfYearly, Quarterly,  and Monthly, which are all defined by a number of periods per year.  We have three calendar frequencies which depend on a particular calendar date:  Weekly, BDaily and Daily. Finally We also have the frequency  Unit, which is not based on the calendar and simply counts observations.  Typically there's no need to work directly with these frequency types.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#End-months-and-end-days","page":"Time Series","title":"End-months and end-days","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"The frequencies Yearly, HalfYearly, and Quarterly have  implicit default end months. These are 12, 6, and 3, respectively, corresponding to  December, June and March. Uses of Yearly will in most cases implicitly use  Yearly{12}. It is also possible to work with  frequencies with different end months,  for example, a fiscal year might end in March, in which case a Yearly{3} frequency  would be used. These end months have implications for frequency conversions (not yet  implemented), but can in most cases be ignored.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"The Weekly frequency similarly has an implicit default end-day of Sunday. Thus uses of  Weekly will in most cases implicitly use Weekly{7}.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#Moments-and-Durations","page":"Time Series","title":"Moments and Durations","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"In TimeSeriesEcon there are two data types to represent the notion of time. Data of type MIT are labels for particular moments in time, while the data type Duration represents the amount of time between two MITs. Both are generic types, in the sense that they are parametrized by a frequency. For example","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"typeof(2000Q1)\ntypeof(2021M5 - 2020M3)","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#Creating-MIT-instances","page":"Time Series","title":"Creating MIT instances","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"The most common types of MIT instances can be created using shorthands of numbers followed immediately by Y, H1, H2, Q1, Q2, Q3, or Q4. for example, the second half of 2022 would be 2022H2.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"2022Q1\n2022H1\n2020Q3\n2020Y","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"For variant end-months, append these in square brackets:","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"2022Q1{2}\n2022H1{5}\n2020Y{11} ","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"For the the higher frequencies, a Date object or string is required to create them:","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"weekly(\"2022-01-03\")\nbdaily(\"2022-01-03\")\ndaily(\"2022-01-03\")","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"Creating a BDaily MIT from a date that lands on a weekend will throw an error, this  can be overcome with  passing the bias parameter. either :previous, :next, or :nearest.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"bdaily(\"2022-01-01\", bias=:previous) # 2021-12-31","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"Daily and bdaily frequencies can also be created using string macros:","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"d\"2022-01-03\"\nbd\"2022-01-03\"\nbd\"2022-01-01\"p # 2021-12-31\nbd\"2022-01-01\"n # 2022-01-03","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#Arithmetic-with-Time","page":"Time Series","title":"Arithmetic with Time","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"We can perform arithmetic operations with values of type MIT and Duration. We just saw that the difference of two MIT values is a Duration of the same frequency. Conversely, we can add an MIT and a Duration to get an MIT. We can add and subtract two Durations, but we're not allowed to add two MITs, only subtract them.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"a = 2001Q2 - 2000Q1  # the result is a Duration{Quarterly}\nb = 2001Q2 + 2000Q1  # doesn't make sense!","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"When we have an MIT plus or minus a plain Integer, the latter is automatically converted to a Duration of the appropriate frequency. This should make our code more readable.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"2000Q1 + Duration{Quarterly}(6)  # this is clunky\n2000Q1 + 6 # same as above","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"We're not allowed to mix frequencies.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"2000Q1 + Duration{Monthly}(6)","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"Other arithmetic operations involving MITs and Durations, either with each other or with Integers are not allowed.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"2000Q1 * 5","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#Other-Operations","page":"Time Series","title":"Other Operations","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"The function frequencyof returns the frequency type of its argument.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"frequencyof(2000Y)\nfrequencyof(2020Q1 - 2019Q3)","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"There are a few operations which are valid only for calendar frequencies.  The function ppy returns the number of periods, while TimeSeriesEcon.year and period return the year and the period number. The periods are numbered from 1 to ppy. If we need both, we can use mit2yp.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"t = 2020Q3\nppy(t)\nTimeSeriesEcon.year(t)\nperiod(t)\nmit2yp(t)","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"Note that ppy returns hardcoded numbers for weekly, daily, and bdaily frequencies, regardless of the actual year of the MIT passed. In addition, the TimeSeriesEcon.year, period, and mit2yp functions do not work for Weekly frequencies, due uncertainty  surrounding weeks spanning the end of a year.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#Ranges","page":"Time Series","title":"Ranges","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"We can create a range of MIT the same way we create ranges of integers. The standard Julia operations with ranges work on MIT ranges as well.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"rng = 2000M1:2001M9\nlength(rng)\nfirst(rng)\nlast(rng)\nrng[3:5]   # subrange\nrng .+ 6  # shift forward by 6 periods","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"We can also create a range where the step is not 1 but some other integer. Technically the step should be a Duration, but once again we can use an Integer for convenience.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"rng2 = 2000M1:2:2000M8\ncollect(rng2)","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"We can create a range that runs backwards by swapping the endpoints and making the step -1. But it is easier to call the standard Julia function reverse. This can be helpful when using @rec as shown below.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"rng\nreverse(rng)","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"We can also use the string macros to create ranges of Daily and BDaily frequencies. When creating a BDaily range in this way, the first date will be rounded up and  the last date rounded down whenever these fall on a weekend.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"d\"2022-01-01:2022-01-31\"\nbd\"2022-01-01:2022-01-31\"","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#Time-Series-2","page":"Time Series","title":"Time Series","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"TimeSeriesEcon provides the data type TSeries to represent a macro-economic time series. It is similar to a Vector, but with added functionality for time series.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"The TSeries type inherits from the built-in AbstractArray and supports all the basic operations of 1-dimensional arrays in Julia. Refer to the article on Multi-dimensional Arrays in the Julia manual for details.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"Type TSeries is also a generic data type. It depends on two type-parameters: its frequency and the data type of its elements.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#Creation-of-TSeries","page":"Time Series","title":"Creation of TSeries","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/#Constructors","page":"Time Series","title":"Constructors","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"The basic constructor of a TSeries requires an MIT (to label the first observation) and a vector of data.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"vals = rand(5)\nts = TSeries(2020Q1, vals)","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"The frequency of the given MIT determines the frequency of the TSeries. Similarly, the type of the elements of the vals array determines the element type of the TSeries.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"note: Important Caveat\nBe mindful of the fact that the TSeries does not copy the original data container. Rather, the ts constructed above is just a wrapper and uses vals for its storage. Specifically, every modification to one of them is immediately reflected in the other. To break the connection use copy.ts = TSeries(2020Q1, copy(vals))","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"We can construct a TSeries with its own storage from just an MIT range. This would construct a TSeries whose storage is un-initialized (it would contain some arbitrary numbers). We can initialize the storage by providing a constant or a function, such as zeros, ones, rand.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"rng = 2020Q1:2021Q4\nTSeries(rng)  # uninitialized (arbitrary numbers that happen to be in memory)\nTSeries(rng, pi)    # constant\nTSeries(rng, rand)  # random numbers","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"note: Important\nBe mindful of the type of the constant you provide as initializer. Specifically, in Julia 0 is of type Int while 0.0 is of type Float64. If you're never going to work with TSeries that store integers (most people), then we recommend you get used to the idiom TSeries(rng, zeros), which does what you expect.TSeries(rng,0)   # element type is Int\nTSeries(rng, zeros) # element type is FLoat64","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#Other-ways-to-construct-TSeries","page":"Time Series","title":"Other ways to construct TSeries","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"We can also construct new TSeries from existing TSeries. The function similar(::TSeries) creates an uninitialized copy, meaning that the copy has the same frequency and element type, but the storage contains arbitrary values. This is useful if we just want a TSeries that we will fill in later. The other useful function is copy, which makes an exact copy. In both cases the new and the old TSeries have separate storage.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"t = TSeries(rng, 2.7)\ns = similar(t)\nc = copy(t)","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"New TSeries are also the results of arithmetic and other operation, which we discuss later in this tutorial.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#Access-to-Elements-of-TSeries","page":"Time Series","title":"Access to Elements of TSeries","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/#Reading-(Indexing)","page":"Time Series","title":"Reading (Indexing)","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"We can access the value for a specific MIT using the standard indexing notation in Julia.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"rng = 2000Q1:2001Q1;\nt = TSeries(rng, rand)\nt[2000Q1]","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"If we ask for a range of MIT, the result is a new TSeries.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"t[2000Q2:2000Q4]","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"We can also use integers. In this case the TSeries behaves like a Vector. The valid integer bounds are 1:length(ts). Note that if we use an integer range, the result is a Vector, not a TSeries.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"t[1]\nt[2:4]","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"If we attempt to read outside the stored range, we would get a BoundsError, which is the same for Vectors.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"t[1999Q1]\nt[2001Q1:2001Q3]","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"When specifying a range, we can use begin and end inside the []. This works exactly the same way for TSeries as it does for the built-in Vector.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"t[end-2:end]   # last 3 \nt[begin+1:end-1]  # drop first and last","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"note: Important\nKeep in mind that begin and end for TSeries are of type MIT. Specifically, when using them we must make sure that both limits of the range evaluate to MIT and not integer. For example, julia ts[1:end-1]  # error will result in an error because the first limit is 1, an Int, while the last limit is lastdate(ts)-1, an MIT). To make this work we need this. julia ts[begin:end-1] # correct ","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#Writing-(Indexed-Assignment)","page":"Time Series","title":"Writing (Indexed Assignment)","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"When indexing is used on the left side of an assignment, we're updating the specified element(s) of the TSeries. Again, this works the same as with Vectors.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"t[2000Q2] = 5\nt","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"When assigning to multiple locations (e.g., over a range), we must ensure that the number of values provided on the right-hand side is correct. Otherwise we would get an error.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"t[begin:begin + 2] = [1, 2, 3]\nt","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"If we want to assign a single value to multiple locations we have to make the assignment a vectorized \"dot\" operation. For this we use .= instead of =.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"t[end-2:end] .= 42\nt","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"The same way we can reset the entire TSeries to a constant using .= without specifying the range. This would update the existing TSeries in place.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"t .= pi","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"Without the dot, i.e., t = pi, t would become a completely different variable with value pi.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"Unlike Vectors, with TSeries we are allowed to assign outside the stored range. Doing this resizes the TSeries as necessary. If there is a gap, that is a part of the new range which is neither in the old range nor in the assignment range, it is filled with NaN.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"t[1999Q1:1999Q2] .= -3.7\nt","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"This only works with MIT indexing. If an integer index is out of bounds, the attempted assignment will result in the usual BoundsError, which is what we would get with a Vector.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"t[15] = 3.5   # results in an error","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"The vectorized \"dot\" assignment allows us to copy values from another TSeries. In this case, the specified range on the left of .= applies to the right side too. In other words, the values from the right hand side will be taken from the range of the assignment.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"q = TSeries(rangeof(t), 100)\nt[1999Q3:2000Q2] .= q\nt","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#Arithmetic-with-TSeries","page":"Time Series","title":"Arithmetic with TSeries","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"There are two kinds of arithmetic operations with TSeries. One kind is where we treat the time series as a single object. Similarly to vectors, we have addition of time series and multiplication of a time series by a scalar number. The other kind of arithmetic is where we treat the time series as a collection of numbers and do the operations element-wise.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"In both cases, if there are multiple time series involved in an expression they must all be of the same frequency, otherwise the operation is generally not well defined.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"When we add (or subtract) two or more TSeries their ranges are not required to be identical. The resulting TSeries has a range containing the common part of all ranges. This is in spirit with the idea that we treat values of a time series outside of its range as unknown or missing, so the result of arithmetic with unknown values remains unknown.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"x = TSeries(20Q1:20Q4, rand)\ny = TSeries(20Q3:21Q2, rand)\nx + y\nx - y","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"When we multiply (or divide) a TSeries by a scalar the resulting TSeries has the same range as the original.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"2y\ny/2   ","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"For element-wise operations we use Julia's \"dot\" notation. This notation is used for vectorized and broadcasting operations. The time series are aligned so that element-wise operations are performed on matching MIT across all TSeries in the expression. For this reason, once again, they all must have the same frequency and the range of the result is the intersection of all ranges.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"log.(x)   # use dot for vectorized function call\n1 .+ x    # broadcasting addition of scalar 1 to time series x \nx .+ y    # vectorized addition (same as regular addition of TSeries)\n2 ./ y    # broadcasting division division\ny .^ 3    # broadcasting y-cubed","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"When assigning the result of a broadcasting operation within an existing TSeries we have to use .= and may optionally specify a range on the left-hand side. When we specify a range on the left-hand side the TSeries on the left is resized, if necessary, to include the given range.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"z = copy(x)\nz .=  1 .+ y  # assign only within the common range of x and y\nz\nz[rangeof(y)] .= 3 .+ y  # resize x and assign within the full range of y\nz","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"Broadcasting operations also can be done with mixing TSeries and Vectors in the same expression. In this case, the Vector must be of the same length as the TSeries and the result is a TSeries.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"v = 3ones(size(x))\nx .+ v","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#Time-Series-Operations","page":"Time Series","title":"Time Series Operations","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/#Shifts","page":"Time Series","title":"Shifts","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"The lag or lead of a TSeries is an operation where the data remains the same but the MIT labels are shifted accordingly. Functions lag and lead produce a new TSeries, while lag! and lead! modify the given TSeries in place. A second integer argument n can be provided to indicate which lag or lead is desired, if something other than 1.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"lag(x)\nlead(x)","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#Diff-and-Undiff","page":"Time Series","title":"Diff and Undiff","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"The first difference of a TSeries can be computed with the built-in function diff. The built-in version works for any Vector, including TSeries. In addition, for time series version of diff allows a second integer argument k to indicate which lag or lead to subtract. The default is k=-1, where a negative value of k indicates a lag and a positive value indicates a lead.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"dx = diff(x)","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"The inverse operation can be done with the function undiff. In its basic form it is the same as the built-in function cumsum.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"undiff(dx)","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"We can see that the answer above does not equal x. This is because the first value of x was lost. undiff allows us to specify an \"anchor\" in the form of date => value. In this case the resulting TSeries will have the given value at the given date.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"x2 = undiff(dx, firstdate(x) => first(x))\nx ≈ x2","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"note: Good to know\nIn the call to undiff above we used first, which is a built-in Julia function that returns the first value of a collection. We also used firstdate, which works for TSeries and returns the first date in the stored range of its argument.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#Moving-Average","page":"Time Series","title":"Moving Average","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"Moving average can be computed with a call to the function moving. It takes a second integer argument n which indicates the length of the window over which the moving average will be computed. If n is positive, the window is backwards-looking (includes lags), while negative n uses a forward-looking window (includes leads). The window always includes the current value (lag 0).","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"tt = TSeries(2020Q1, collect(Float64, 1:10))\nmoving(tt, -4)\nmoving(tt, 6)","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#Recursive-assignments","page":"Time Series","title":"Recursive assignments","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"Sometimes we need to construct a time series by recursive assignments. We can do this on one line with the macro @rec. For example, we can simulate the impulse response of a simple AR(1) model. Say math a_t = (1-\\rho) a_{ss} + \\rho a_{t-1} + \\varepsilon_t. Then we can compute the impulse response with the following snippet of code.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"a_ss = 1.0\nρ = 0.6\na = fill(a_ss, 2020Q1:2022Q1)\na[begin] += 0.1\nfor t = firstdate(a)+1:lastdate(a)\n    a[t] = (1-ρ)*a_ss + ρ*a[t-1]\nend\na","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"We can rewrite the last loop more succinctly like this:","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"@rec rangeof(a, drop=1) a[t] = (1-ρ)*a_ss + ρ*a[t-1]\na","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"The first argument of @rec is the range over which the loop will run. In this case we're using rangeof(a, drop=1). Function rangeof normally returns the stored range of a TSeries. With the optional parameter drop=n we request that the first n periods be skipped. If n is negative, then the periods will be skipped at the end.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"(rangeof(a), rangeof(a, drop=1), rangeof(a, drop=-1))","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"Note also that whether using @rec or spelling out the for-loop explicitly, the TSeries will be resized if necessary. However, it is more efficient to preallocate the entire range by calling resize! first.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"resize!(a, 2020Q1:2023Q1)\n@rec rangeof(a, drop=1) a[t] = (1-ρ)*a_ss + ρ*a[t-1]\na","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#Multi-variate-Time-Series","page":"Time Series","title":"Multi-variate Time Series","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"We can store multiple time series in a variable of type MVTSeries. This is a collection of TSeries with the same frequency, the same range, and the same element type. It is like a table, where each row corresponds to an MIT and each column to a time series variable.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#Creation-of-MVTSeries","page":"Time Series","title":"Creation of MVTSeries","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"The basic constructor of MVTSeries takes an MIT, which indicates the label of the first row, a list of names for the columns, and a matrix of values. The number of columns in the given matrix must match the number of column names. The range of the resulting MVTSeries is determined from the first date and the number of rows.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"x = MVTSeries(2020Q1, (:a, :b), rand(6, 2))","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"Similarly to TSeries, if we specify a range (rather than a single MIT), the MVTSeries will be able to allocate its own storage. In this case, we can optionally provide an initializer in the form of a constant value or a function.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"MVTSeries(2020Q1:2021Q3, (:one, :too, :tree), zeros)","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"We can also build an MVTSeries from a range and a list of name-value pairs. The values can be TSeries, vectors, or constants. In the case of a TSeries, the constructor will use the necessary range, while in the case of a vector must have the correct length. This form of the MVTSeries constructor allocates its own storage space, so the data are always copied.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"data = MVTSeries(2020Q1:2021Q1;\n            hex = TSeries(2019Q1, collect(Float64, 1:20)),\n            why = zeros(5),\n            zed = 3, )","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"New MVTSeries variables can also be created with similar(::MVTSeries) and copy. They are also the result of arithmetic operations. This is the same as with TSeries, so we won't spend time repeating it.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#Access","page":"Time Series","title":"Access","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"MVTSeries behaves like a 2-dimensional matrix when indexing is done with integers. Otherwise, we can also index using MITs (or MIT ranges) for the row-indexes and Symbols (or tuples of Symbols) for the column-indexes.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"data[2020Q2, :hex]","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"An entire row can be accessed with a single MIT index.  The result of such indexing is a regular Vector.  In order to extract  an MVTSeries the index must be a unit range of MIT.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"data[2020Q2]\ndata[2020Q2:2020Q2]  # index with range","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"Similarly, we can extract an entire column by its name. The result is a TSeries.   If the index is a tuple of names, then the result is another MVTSeries containing only the selected columns.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"data[:zed]  \ndata[(:zed,)] # index with tuple","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"For convenience we can also access the columns by name using the traditional data.zed notation.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"data.zed","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"It is sometimes necessary to iterate over the columns of an MVTSeries. This can be done easily with the function columns. The following snippet of code shows an idiom for such iteration.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"using Statistics\nfor (name, value) in columns(data)\n    println(\"Average of `\", name, \"` is \", mean(value), \".\")\nend","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"note: Note\nNote that columns is specific to MVTSeries. The built-in function pairs does the same for a general collection of name-value pairs. It also works for MVTSeries.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#Plotting","page":"Time Series","title":"Plotting","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"Visualizing a TSeries is straight-forward.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"plot(a, 1 .+ 0.1*TSeries(2020M1:2023M1, rand), label=[\"a\" \"rand\"]);\nsavefig(ans, \"plot-1.png\"); # hide","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"(Image: )","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"Similarly, we can plot all time series in an MVTSeries just as easily.   Each variable will appear in its own set of axes.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"db_a = MVTSeries(2020Q1:2023Q4, \n    x = 0.5, \n    y = 0:1/15:1,\n    z = rand(16),\n)\nplot(db_a, label=[\"db_a\"]);\nsavefig(ans, \"plot-2.png\"); nothing; # hide","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"(Image: )","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"We cal also plot several MVTSeries at the same time.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"db_b = MVTSeries(2020Q1:2023Q4, \n    y = 0.5,\n    z = 1:-1/15:0, \n    w = rand(16),\n)\nplot(db_a, db_b, label=[\"db_a\" \"db_b\"]);\nsavefig(ans, \"plot-3.png\"); nothing; # hide","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"(Image: )","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"We see that all variables are plotted as long as they appear in at least one of the given MVTSeries. The plot can become very busy very quickly. There is also a limit of 10 variables (which will result in a 5times2 grid). We can select which variables to plot with the option vars=. We can also restrict the range of the plot with trange=. Any other plot attributes work as usual.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"plot(db_a, db_b, \n    label = [\"db_a\" \"db_b\"],\n    vars = [:y, :z],\n    trange = 2020Q3:2022Q3,\n    layout = (2,1),\n    right_margin = 1Plots.cm,   # hide\n    left_margin = 0.5Plots.cm,  # hide\n);\nsavefig(ans, \"plot-4.png\"); nothing; # hide","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"(Image: )","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"note: Good to Know\nThe trange= argument works only when all time series in the plot have the same frequency. When plotting time series with different frequencies, you can use xlim=. You can use MIT in the limits specified by xlimthey are converted to floating point numbers automatically. For example float(2020Q1) == 2020.0, float(2020Q2) = 2020.25, etc. An important difference to keep in mind is that trange= requires a unit range, e.g., trange=2020Q3:2022Q3, while xlim= requires a tuple, e.g., xlim=(2020Q3,2022Q3).","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#Workspaces","page":"Time Series","title":"Workspaces","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"When working with models, in addition to time series data, we encounter a lot of other types of data. For example, parameter and steady state values, simulation ranges and dates, etc. The data type Workspace is a container that can store all kinds of data. Most operations for dictionaries work also for Workspaces.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"We can create an empty Workspace and fill it with data. We can create \"variables\" in the workspace directly by assignment.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"w = Workspace()\nw.rng = 2020Q1:2021Q4\nw.start = first(w.rng)\nw.a = TSeries(w.rng)\nw.a .= a\nw","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"We can remove data from the workspace using the built-in function delete!.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"delete!(w, :start)","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"We can also give the constructor of Workspace a list of names and values like this:","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"Workspace(rng = 2020Q1:2021Q4, alpha = 0.1, v = TSeries(2020Q1, rand(6)))","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"Equivalently, we can provide the whole list of name-value pairs as a single argument:","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"datalist = [:rng => 2020Q1:2021Q4, :alpha => 0.1, :v => TSeries(2020Q1, rand(6))]\nWorkspace(datalist)","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"The last one is particularly useful for converting an MVTSeries to a Workspace, since we can use the pairs function.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"w_a = Workspace(pairs(db_a; copy = true))","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"Note that by default copy=false, which means that the time series in the new w_a would share their storage with the corresponding columns of db_a. This is more efficient than copying the data. However, if we need the new workspace to hold its own copy of the data, we can force that by setting copy=true.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"The next example is an idiom for converting a workspace back to an MVTSeries. Note that in this case we always get a copy, so there's no optional parameter copy=.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"MVTSeries(rangeof(w_a); pairs(w_a)...)","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"In the above we used rangeof(::Workspace) on the Workspace variable w_a, which returns the intersection of the ranges of all variables in the workspace. ","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#MVTSeries-vs-Workspace","page":"Time Series","title":"MVTSeries vs Workspace","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"You've probably already noticed the remarkable similarity between MVTSeries and Workspace. Both are containers for TSeries and in many ways are interchangeable. In both cases we can access data by name using the traditional \"dot\" notation (e.g., db.x), and we can also access them using indexing notation (e.g., db[:x]).","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"One important differences are that MVTSeries is a matrix, so we can use it for linear algebra and statistics. MVTSeries also has the constraint that all variables are TSeries with the same frequency.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"In contrast, Workspace is a dictionary, which can store variables of any type. So in a workspace we can have multiple time series of different frequencies. Also, a Workspace can contain nested MVTSeries or Workspaces.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"Another important difference is that we can add and delete variables in a workspace, while in an MVTSeries the columns are fixed and in order to add or remove any column we must create a new MVTSeries instance.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#overlay","page":"Time Series","title":"overlay","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"Function overlay has two modes of operation: one is when all inputs are TSeries and the other is when the arguments are a mixture of Workspace and MVTSeries.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"In the first case all time series must have the same frequency and the result is a new TSeries whose range is the union of all ranges of the inputs. For each MIT the output will have the first non-missing value found in the inputs from left to right. (NaN is considered missing, as well as values outside the allocated range.)","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"x1 = TSeries(2020Q1:2020Q4, 1.0)\nx1[2020Q2:2020Q3] .= NaN\nx2 = TSeries(2019Q3:2020Q2, 2.0)\nx2[2019Q4:2020Q1] .= NaN\nx3 = TSeries(2020Q2:2021Q1, 3.0)\nMVTSeries(; x1, x2, x3, overlay = overlay(x1, x2, x3))","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"We can force the output to have a specific range by putting that range as the first argument of overlay","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"overlay(2020Q1:2020Q4, x1, x2, x3)","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"In the second case, when we call overlay on a list of MVTSeries or Workspace variables, the result is a Workspace in which all variables are recursively overlaid. For example, a variable in the result is taken form the first input (from left to right) in which it is found. But if that variable is a TSeries, then it is overlaid from all inputs in which it appears. The same applies to other \"overlay-able\" data types, such as nested Workspaces and MVTSeries.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"w1 = Workspace(; x = x1, a = 1)\nw2 = MVTSeries(; x = x2, b = 2)    # w2.b is a `TSeries`!\nw3 = Workspace(; x = x3, a = 3, b = 3, c = 3)\noverlay(w1, w2, w3)","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"In the example above, x is a TSeries in all three inputs and so it is overlaid; a is a scalar taken from w1; b is a TSeries in w2 and a scalar in w3, so it is not overlaid and instead it is simply taken from w2, because that's where it appears first; and finally c is taken from w3, since it is missing from the other two.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#compare-and-@compare","page":"Time Series","title":"compare and @compare","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"The compare function and the accompanying @compare macro can be used to compare two Workspaces or MVTSeries. The comparison is done recursively.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"v1 = Workspace(; \n        x = 3, \n        y = TSeries(2020Q1, ones(10)), \n        z = MVTSeries(2020Q1, (:a, :b), rand(6,2)));\nv2 = deepcopy(v1);    # always use deepcopy() with Workspace\nv2.y[2020Q3] += 1e-7\nv2.z.a[2020Q3] += 0.001\nv2.b = \"Hello\"\n@compare(v1, v2)","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"Numerical values, including TSeries, are compared using isapprox. We can pass arguments to isapprox by adding them as optional parameters to the function call. For example, we can set the absolute tolerance of the comparison with atol=.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"@compare(v1, v2, atol=1e-5)","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"Keep in mind that when comparing two NaN values the result is false. This can be changed by setting nans=true. ","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"Other useful parameters include ignoremissing, which can be set to true in order to compare only variables that exist in both inputs, and showequal which can be set to true to report all variables, not only the ones that are different. compare and @compare return true if the two databases compare as equal and false otherwise.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"@compare(v1, v2, showequal, ignoremissing, atol=0.01)","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#BDaily-Holidays","page":"Time Series","title":"BDaily Holidays","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"BDaily TSeries have values falling on weekdays (Monday-Friday). In some use cases  there may be NaN values on holidays and/or NaN values on other days of the year. Some functions take additional arguments which determine the treatment  of such NaN values.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"These options are:","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"skip_all_nans - either true or false.\nskip_holidays - either true or false.\nholidays_map - either Nothing or or a TSeries{BDaily, Bool}.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"These options are available for the functions  cleanedvalues,   shift,  lag,  lead,  pct,  diff,  mean,  std,  stdm,  var,  varm,  median,  quantile,  cor, and  cov.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"The cleanedvalues function returns the values of the TSeries, excluding any values specified to be excluded as per the three options above.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#skip_all_nans","page":"Time Series","title":"skip_all_nans","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"When true, all NaN values will be skipped for the relevant calculations. For the shift, diff, and pct functions, the NaN values will be replaced with the nearest non-NaN value, in the direction of the shift. For example, when shifting the data forward (or leading), the replacement values will come from  the later period(s), whereas when shifting data backwards (or lagging, or using the diff or pct functions)  the replacement will come from the earlier periods. In this way, the pct value for a given day will be calculated against the previous non-NaN value.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#skip_holidays","page":"Time Series","title":"skip_holidays","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"When true, values on holidays will be skipped for the relevant caluclations. For the shift, diff, and pct functions, the values on holidays will be replaced with the nearest non-holiday value, similar to the treatment of NaN values in the skipallnans option. NaN values on non-holidays will still be  treated as NaN.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"Holidays are determined based on the holidays map stored in TimeSeriesEcon.getoption(:bdaily_holidays_map).","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#holidays_map","page":"Time Series","title":"holidays_map","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"This option functions like skip_holidays=true except that the passed holidays map is used, rather than the map stored in TimeSeriesEcon.getoption(:bdaily_holidays_map).","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"ts = TSeries(bd\"2022-01-03\", collect(1.0:10.0))\nts[bd\"2022-01-07\"] = NaN\npct(ts)\npct(ts, skip_all_nans=true)","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#Options","page":"Time Series","title":"Options","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"The TimeSeriesEcon module has global options which are sometimes referenced when invoking methods within the module. There are currently two options: :bdaily_creation_bias, and :bdaily_holidays_map. These can be set and retrieved with the TimeSeriesEcon.setoption and TimeSeriesEcon.getoption methods.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#bdaily*creation*bias","page":"Time Series","title":"bdailycreationbias","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"This option affects the behavior when creating BDaily MITs from dates which fall on weekends. The default is :strict, which results in errors being thrown when creating BDaily MITs from weekend dates. Other valid options are: :previous, :next, and :nearest.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"bd\"2022-01-01\"n # 2022-01-03\nTimeSeriesEcon.setoption(:bdaily_creation_bias, :next)\nbd\"2022-01-01\" # 2022-01-03\nTimeSeriesEcon.setoption(:bdaily_creation_bias, :strict)\n# bd\"2022-01-01\" # throws an error","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/#bdaily*holidays*map","page":"Time Series","title":"bdailyholidaysmap","text":"","category":"section"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"This option stores a holidays map for use with some TimeSeriesEcon methods. A holidays map is a TSeries{BDaily, Bool} spannig from bd\"1970-01-01\" to bd\"2049-12-31\", although smaller ranges are allowed. The series is true for non-holidays, and false for holidays. cleanedvalues(ts, skip_holidays=true) will therefore return values for the days where the holidays map is true.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"There are a number of built-in maps based on the Python Holidays package. To see the available options, call TimeSeriesEcon.get_holidays_options()","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"TimeSeriesEcon.get_holidays_options()","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"You can also consult the documentation of the Holidays package.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"For countries with different regions available, you can also call it with the two-character country code to get the region options.","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"TimeSeriesEcon.get_holidays_options(\"CA\")","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"To set the holidays map for a given country/region, use TimeSeriesEcon.set_holidays_map:","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"TimeSeriesEcon.set_holidays_map(\"DK\") # Denmark\nTimeSeriesEcon.set_holidays_map(\"CA\", \"ON\") # Ontario, Canada","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"note: Good to know\nThe maps may contain errors; they are maintained by a collection of volunteers. You can modify them by first setting the map, retriving it, then setting it manually: TimeSeriesEcon.setholidaysmap(\"DK\") # Denmarkhm = TimeSeriesEcon.getoption(:bdaily_holidays_map)\nfor i in 1970:2049\n  try\n      d = bdaily(\"$i-05-05\")\n      hm[d] = false\n  catch\n  end\nend\nTimeSeriesEcon.setoption(:bdaily_holidays_map, hm)","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"The current holidays map can also be unset with this command:","category":"page"},{"location":"Tutorials/1.TimeSeriesEcon/main/","page":"Time Series","title":"Time Series","text":"TimeSeriesEcon.clear_holidays_map()","category":"page"},{"location":"indexpage/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"indexpage/","page":"Index","title":"Index","text":"","category":"page"},{"location":"Tutorials/README/#README","page":"README","title":"README","text":"","category":"section"},{"location":"Tutorials/README/","page":"README","title":"README","text":"This project contains a list of tutorials demonstrating the use of StateSpaceEcon group of Julia packages. Each tutorial is in its own subdirectory. They are meant to run in a Julia REPL session running in the root directory of the project (which is what happens in VSCode), not in the subdirectory of the specific tutorial.  ","category":"page"},{"location":"Tutorials/README/#Installation","page":"README","title":"Installation","text":"","category":"section"},{"location":"Tutorials/README/","page":"README","title":"README","text":"The tutorials are designed to run in the Julia environment in the root of the project. Before the first use, make sure to instantiate the environment.","category":"page"},{"location":"Tutorials/README/","page":"README","title":"README","text":"] activate .\n] instantiate","category":"page"},{"location":"Tutorials/README/","page":"README","title":"README","text":"After that, make sure the environment is active when you run the tutorial codes.","category":"page"},{"location":"Tutorials/README/#List-of-tutorials","page":"README","title":"List of tutorials","text":"","category":"section"},{"location":"Tutorials/README/","page":"README","title":"README","text":"Each tutorial is in its own subdirectory containing a main.jl and main.md in addition to other files. The two main files contain the same code and explanations. If running the tutorial code yourself, you should use the .jl file.","category":"page"},{"location":"Tutorials/README/","page":"README","title":"README","text":"TimeSeriesEcon\nSimple RBC\nSmets and Wouters 2007\nFRB-US with VAR-based Expectations","category":"page"},{"location":"DesignPapers/final_conditions/#Final-Conditions","page":"Final Conditions","title":"Final Conditions","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"This article describes the different types of final conditions supported in StateSpaceEcon, the relevant mathematical derivations, as well as some implementation details.","category":"page"},{"location":"DesignPapers/final_conditions/#Introduction","page":"Final Conditions","title":"Introduction","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"In the stacked time algorithm all equations for all time periods are solved simultaneously as one, very large system of equations. Because of lags in some of the variables, we must impose initial conditions, i.e. values for the variables before the first period of the simulation. This is not unique to stacked time algorithm - all solution methods require initial conditions.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Similarly, because of leads in some of the variables, we must provide final conditions. Final conditions are equations in terms of variables at times beyond the last period of the simulation.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"As a running example, consider a model with one variable y_t, one shock sy_t, and one equation involving one lag and one lead:","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    f(y_t-1 y_t y_t+1 s_t) = 0","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Suppose we want to simulate 3 periods. Let's use indices t=24 for the simulation periods. In the stacked time algorithm we have to solve the following system of equations:","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"beginaligned\n    f(y_1 y_2 y_3 s_2) = 0 \n    f(y_2 y_3 y_4 s_3) = 0 \n    f(y_3 y_4 y_5 s_4) = 0\nendaligned","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"We see that we have 3 equations with 5 unknowns - we assume that the values of the shocks (s_t) are given as exogenous data. In order to find a unique solution for y_t for all t=15, we need two more equations. The first one is the initial condition.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"y_1 = Y_1","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"where Y_1 is a known value of y at time t=1. The last equation is the final condition, which would help us solve for y_5.","category":"page"},{"location":"DesignPapers/final_conditions/#Types-of-Final-Conditions","page":"Final Conditions","title":"Types of Final Conditions","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"There are four types of final conditions currently implemented in StateSpaceEcon.","category":"page"},{"location":"DesignPapers/final_conditions/#fcgiven","page":"Final Conditions","title":"fcgiven","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"This is the simplest one of them. It can be used when the values of the variable after the end of the simulation are known and we simply assign them.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"In our running example, the following equation corresponds to fcgiven.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"y_5 = Y_5","category":"page"},{"location":"DesignPapers/final_conditions/#fclevel","page":"Final Conditions","title":"fclevel","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"This is almost the same as fcgiven in that here again we simply assign known values to the variables in the final conditions. This time the values come from the steady state solution of the system. This works if the steady state of y_t is a constant.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"y_5 = ssY_5","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Where ssY is the steady state of y. Note that the steady state is not necessarily a constant. In the case of balanced growth path and more than one final conditions period, we still assign the known values of ssY_t as computed from its known level and slope.","category":"page"},{"location":"DesignPapers/final_conditions/#fcslope","page":"Final Conditions","title":"fcslope","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"In this case we write an equation which sets the first difference of y_t at the end of the simulation (for all final conditions periods) to the slope of the steady state. This works if the steady state solution of y_t is a balanced path with linear growth. It can also be used with constant steady state - in that case the \"linear growth\" has slope 0.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"y_5 - y_4 = ssY_5 - ssY_4","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Note that ssY_t+1 - ssY_t = ssY_slope is simply the slope of the steady state - a constant that does not depend on t.","category":"page"},{"location":"DesignPapers/final_conditions/#fcnatural","page":"Final Conditions","title":"fcnatural","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"This is the case when we believe that the solution path beyond the end of the simulation is a straight line, but we don't know its slope, i.e., we allow the slope to be solved for. Practically, this final condition imposes the constraint that the second difference of the variable is zero after the last simulation period.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"   y_5 - 2 y_4 + y_3 = 0","category":"page"},{"location":"DesignPapers/final_conditions/#The-Stacked-Time-System-of-Equations","page":"Final Conditions","title":"The Stacked Time System of Equations","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Once we stack all equations for all simulation time periods into a single system of equations, we get a system with more unknowns than equations, as we saw above. In addition to initial and final conditions, we also have to impose exogenous constraints.","category":"page"},{"location":"DesignPapers/final_conditions/#Vector-of-Unknowns","page":"Final Conditions","title":"Vector of Unknowns","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Let us denote by x the vector of all unknowns. To be specific, the variables and shocks are assigned consecutive and unique indices from 1 to N. Also, the time periods of the simulation, together with the necessary number of time periods before (initial conditions) and after (final conditions) the simulation, are numbered sequentially starting from 1 to T. Thus vector x has N T components. We have adopted the convention that the first T components correspond to values of the first variable, components from T+1 to 2T are for variable 2 and so on.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"We divide the unknowns into three groups based on how they are treated by the solver. The first group contains the unknowns whose values are already known. These include initial conditions and exogenous constraints. We denote these x_e.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"The second group is the set of \"active unknowns\". These are the ones we are actually solving for in the simulation. We denote them x_s.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"The third group consists of the unknowns determined by final conditions. We denote that vector x_c.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"In our example, the vectors of unknowns would look like this:","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"beginaligned\n    x = y_1 y_2 y_3 y_4 y_5 s_1 s_2 s_3 s_4 s_5 \n    x_e = y_1 s_1 s_2 s_3 s_3 s_4 s_5 \n    x_s = y_2 y_3 y_4 \n    x_c = y_5\nendaligned","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"In what follows, we will renumber the unknowns in x such that x_e are in the beginning, x_s are in the middle and x_c are at the end. In the code we don't actually do this, but it makes it easier to discuss the linear algebra in the following sections.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    x =  x_e  x_s  x_c ","category":"page"},{"location":"DesignPapers/final_conditions/#Equations","page":"Final Conditions","title":"Equations","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"The equations are also grouped into the same three groups and for the purpose of this exposition we put them in the same order as we did with the unknowns above.","category":"page"},{"location":"DesignPapers/final_conditions/#The-System-of-Equations","page":"Final Conditions","title":"The System of Equations","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Without loss of generality we have a system of equations F(x) = 0. Starting with an initial guess x^0, the Newton-Raphson method consists in the iteration","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    x^n+1 = x^n - J(x^n)^-1 F(x^n)qquadmathrmfor n=012","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"where J(x^n) is the Jacobian of F evaluated at x^n.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"warning: Important\nWe need to distinguish between initial condition and initial guess. The former refers to the values of the model variables prior to the simulation range. The latter is the vector of unknowns at the start of the iterative solution method. To distinguish the two, we use upper index (superscript) to denote the successive iterations of the Newton-Raphson method, while the lower index (subscript) is used to denote the variable group e, s, or c.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"The computational step here consists in solving the linear system with matrix J and right hand side F. We can write this system into a 3-by-3 block-matrix form, with rows corresponding to equations and columns corresponding to unknowns split into the three groups.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    beginbmatrix I  0  0  E_s  S  C_s  E_c  S_c  C endbmatrix\n    cdot\n    beginbmatrix delta x_e  delta x_s  delta x_c endbmatrix\n    =\n    beginbmatrix 0  F_s  F_c endbmatrix","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"The first row corresponds to exogenous and initial conditions. Notice that the unknown here is not x but the update delta x. If we assign the correct exogenous and initial values in x^0 then the residuals of this group of equations will be all zeros, F_e = 0, and so the update delta x_e will also be always zero.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Therefore the entire system reduces to solving the following:","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    beginbmatrix S  C_s  S_c  C endbmatrix\n    cdot\n    beginbmatrix delta x_s  delta x_c endbmatrix\n    =\n    beginbmatrix F_s  F_c endbmatrix","category":"page"},{"location":"DesignPapers/final_conditions/#Solution-Method","page":"Final Conditions","title":"Solution Method","text":"","category":"section"},{"location":"DesignPapers/final_conditions/#Case-1:-fcgiven","page":"Final Conditions","title":"Case 1: fcgiven","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"In this case we have","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    beginbmatrix S  C_s  0  I endbmatrix\n    cdot\n    beginbmatrix delta x_s  delta x_c endbmatrix\n    =\n    beginbmatrix F_s  0 endbmatrix","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Once again we assume that the correct values for x_c are assigned in the initial guess, x^0. Therefore the update delta x_c is always zero. Therefore in this case we simply solve","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    S cdot delta x_s = F_s","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Note that even though we are not explicitly solving for delta x_e and delta x_c, the matrix S and the right hand side F_s here depend on the values x_e and x_c, since they are part of x^n when evaluating F(x^n) and J(n^n).","category":"page"},{"location":"DesignPapers/final_conditions/#Case-2:-fclevel","page":"Final Conditions","title":"Case 2: fclevel","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"This is identical to case 1.","category":"page"},{"location":"DesignPapers/final_conditions/#Case-3:-fcslope","page":"Final Conditions","title":"Case 3: fcslope","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"This is an interesting case. Pay attention because this part is tricky.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"We have the following equations.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"beginaligned\n    S cdot delta x_s + C_s cdot delta x_c = F_s \n    S_c cdot delta x_s + C cdot delta x_c = F_c\nendaligned","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"We eliminate delta x_c from the system. To do so, we multiply the second equation by C_s C^-1 and subtract the result from the first equation.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    left( S - C_s C^-1 S_c right) cdot delta x_s = F_s - C_s C^-1 F_c","category":"page"},{"location":"DesignPapers/final_conditions/#Solve-for-\\delta-x_s","page":"Final Conditions","title":"Solve for delta x_s","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Suppose that F_c = 0. We will discuss later how we make sure that's the case. Then the solution for delta x_s is given by","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    left( S - C_s C^-1 S_c right) cdot delta x_s = F_s","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"The only difference with case 1 and 2 is that the system matrix is modified by subtracting C_s C^-1 S_c. The matrix C^-1 S_c is constant. This matrix is specific to the fcslope type of final conditions for the given model. It only depends on the number of variables and the number of final conditions periods. It can be pre-computed and stored.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"The matrix C_s on the other hand depends on x^n and so it needs to be re-computed at every iteration.","category":"page"},{"location":"DesignPapers/final_conditions/#Solve-for-\\delta-x_c","page":"Final Conditions","title":"Solve for delta x_c","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"How do we make sure that F_c = 0? Remember that the final conditions equation in our example model is","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"y_5 - y_4 = ssY_slope","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Imagine how this would generalize to an arbitrary model. Now notice that the residual F_c depends on x^n and the slope of the steady state ssY_slope. Since we know the x^n_s part of x^n prior to solving the system, we can set the x^n_c part of x^n so that the final conditions are satisfied. In other words, this would make sure that F_c = 0. One way to do this is to simply start from the values of the variables at the last period of the simulation (which are in x^n_s; that's y_4 in our example) and compute all future values (which are in x^n_c,; that's y_5 in the example) by adding the corresponding steady state slope (that is y_5 = y_4 + ssY_slope). We must do this on every iteration before we evaluate F(x^n) and J(x^n).","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Actually, that's not true. It turns out that we only need to do this to the initial guess x^0. After that, once we compute delta x_s by solving the above system, we can solve the following system for delta x_c.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    C cdot delta x_c = - S_c cdot delta x_s","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"With delta x computed this way, the resulting x^n+1 will produce F_c=0 at the next iteration. This can be verified directly.","category":"page"},{"location":"DesignPapers/final_conditions/#The-Matrices:-C,-S_c-and-C{-1}S_c","page":"Final Conditions","title":"The Matrices: C, S_c and C^-1S_c","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"These matrices have 0 everywhere except for some non-zero blocks, which we discuss here.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Our running example has only one period of final conditions and a single variable, which is a trivial case. In order to see what happens in a more general case, suppose we have 4 periods of final conditions and several variables. In matrix C we will have a block, C_b, like the one below for each variable in the model. Each C_b will be the same square block with as many rows and columns as the number of final condition periods.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"C_b = beginbmatrix\n    1  0  0  0  -1  1  0  0  0  -1  1  0  0  0  -1  1\n    endbmatrix","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Matrix S_c also contains identical blocks S_cb for each variable. The number of rows is the same as C_b, while the number of columns equals the number of simulation periods. The -1 in the top-right corner is in the column corresponding to the last period of the simulation. (In our trivial example above that would be t=4)","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"S_cb = beginbmatrix\n            0  cdots  0  -1 \n            0  cdots  0  0 \n            0  cdots  0  0 \n            0  cdots  0  0\n          endbmatrix","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Now it is straightforward to compute C^-1 S_c. It also has block-structure with blocks like this:","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":" left(C^-1S_cright)_b = beginbmatrix\n            0  cdots  0  -1 \n            0  cdots  0  -1 \n            0  cdots  0  -1 \n            0  cdots  0  -1 \n        endbmatrix","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"The column with -1 again corresponds to the last period of the simulation.","category":"page"},{"location":"DesignPapers/final_conditions/#Case-4:-fcnatural","page":"Final Conditions","title":"Case 4: fcnatural","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"This case is identical to case 3. The only thing that changes is the matrices.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"This time for our example we will use 5 periods of final conditions, so that the patterns would be more obvious. We have the following.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"C_b = beginbmatrix\n    -1   0   0   0   0 \n     2  -1   0   0   0 \n    -1   2  -1   0   0 \n     0  -1   2  -1   0 \n     0   0  -1   2  -1 \n    endbmatrix","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"For S_c this time we have non-zeros in two columns corresponding to the last two periods of the simulation.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"S_cb = beginbmatrix\n            0  cdots  0  -1  2 \n            0  cdots  0  0  -1 \n            0  cdots  0  0   0 \n            0  cdots  0  0   0 \n            0  cdots  0  0   0 \n          endbmatrix","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"Finally, we have","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":" left(C^-1S_cright)_b = beginbmatrix\n            0  cdots  0  1  -2 \n            0  cdots  0  2  -3 \n            0  cdots  0  3  -4 \n            0  cdots  0  4  -5 \n            0  cdots  0  5  -6 \n        endbmatrix","category":"page"},{"location":"DesignPapers/final_conditions/#Handling-of-log-variables","page":"Final Conditions","title":"Handling of log-variables","text":"","category":"section"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"If we have log variables the final conditions the cases of fclevel and fcgiven are the same as above.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"In the case of fcslope the balanced growth path solution is actually a geometric sequence. What we call its \"slope\" here is actually the common ratio, that is ssY_slope = ssY_t  ssY_t-1 for all t. We have final condition equations that look like this:","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    y_5  y_4 = ssY_slope","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"In the case of fcnatural, we again impose the condition that the solution must be a geometric sequence, although this time the common ratio is unknown and we must solve for it. We have final conditions like this","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"    y_5  y_4 = y_4  y_3","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"In both cases it is better to work with an equivalent formulation in terms of logs.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"beginaligned\n    log(y_5) = log(y_4) + log(ssY_slope) qquad  mathrmfor fcslope \n    log(y_5) = 2 log(y_4) - log(y_3) qquad  mathrmfor fcnatural\nendaligned","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"If we were to implement this directly, the matrix blocks C_b and S_cb corresponding to log-variables would not be constant (as they were above for non-log variables), because they would contain the derivatives of the above log functions and would therefore need to be re-computed on each iteration.","category":"page"},{"location":"DesignPapers/final_conditions/","page":"Final Conditions","title":"Final Conditions","text":"However, in our implementation of log-variables, we apply the log-transformation and so the unknowns we actually solve for are log(y_t). Thus, the final conditions are in fact identical to the ones for non-log variables and we don't need to do anything special here.","category":"page"},{"location":"DesignPapers/final_conditions/#Conclusion","page":"Final Conditions","title":"Conclusion","text":"","category":"section"},{"location":"DesignPapers/log_variables/#Log-variables","page":"Log-variables","title":"Log-variables","text":"","category":"section"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"This article describes the intended meaning of declaring a variable using the @log annotation, and the internal handling of such variables.","category":"page"},{"location":"DesignPapers/log_variables/#What-is-a-log-variable","page":"Log-variables","title":"What is a log-variable","text":"","category":"section"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"A variable should be declared using the @log annotation when its balanced growth path is exponential growth or decay. Specifically this means that","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"X_t = c X_t-1","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"for some c, which we call its slope. The balanced growth path forms a geometric sequence with common ratio c. The growth rate, let's call it r, is related to the slope as c = 1 + r.","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"This has implications to how we solve for the steady state of such variable and also to how we impose final conditions of type fcslope and fcnatural.","category":"page"},{"location":"DesignPapers/log_variables/#Implementation-details","page":"Log-variables","title":"Implementation details","text":"","category":"section"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"Internally we work with the log transformation of log variables. All equations and data provided by the user should be in terms of the declared variable. This log transformation is done internally, automatically, and should be completely transparent to the user.","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"It is not strictly necessary to use such transformation. However, this approach simplifies several aspects of the implementation. In addition, a log-variable is always positive and usually appears as argument to logarithms, fractional powers and division, which might produce domain errors if the argument becomes negative or zero, for example during the solver iterations. By working with the log of the variable, which is allowed to be any real number, we avoid such problems.","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"Applying this transformation affects the following parts of the implementation.","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"Transform the dynamic equations and their corresponding steady state equations.\nTransform the steady-state constraints.\nApply appropriate final conditions in the case of fcslope and fcnatural.\nTransform the linearization about a solution with log-variables.","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"We also need to transform the user provided data before running the solution algorithms and then transform the solution back by applying the inverse transformation before returning it to the user. This includes","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"initial conditions,\nexogenous data,\nsteady state solution,\nsimulation result,\ndata given in deviation from the steady state.","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"We address each of these in the remainder of this article.","category":"page"},{"location":"DesignPapers/log_variables/#Transformations-of-the-equations","page":"Log-variables","title":"Transformations of the equations","text":"","category":"section"},{"location":"DesignPapers/log_variables/#Dynamic-equations","page":"Log-variables","title":"Dynamic equations","text":"","category":"section"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"When a mention of a variable is encountered in an equation, we replace that mention by a new symbol whose name is made up from the name of the variable and the lag or lead value. For example, equation Y[t] = Y[t-1] + 0.1 becomes #Y#0# = #Y#-1# + 0.1, where #Y#0# and #Y#-1# are the new variable names corresponding to the contemporaneous and lag 1 values of Y.","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"When a variable is declared @log X, the new symbols created for the different lags have the meaning of the log of that variable. For example, equation X[t] / X[t-1] = 1.01 becomes exp(#logX#0#) / exp(#logX#-1#) = 1.01.","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"All we have to do from this point on is to make sure that the data values for these variables are transformed accordingly. In particular, there is no need to do anything about transforming the gradients of the equation residual functions, since they are automatically computed from the transformed equation by automatic differentiation.","category":"page"},{"location":"DesignPapers/log_variables/#Steady-state-equations-derived-from-dynamic-equations","page":"Log-variables","title":"Steady state equations derived from dynamic equations","text":"","category":"section"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"For regular variables we substitute","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"Y_t = lvl_Y + (t-t_ref) * slp_Y","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"in the dynamic equations. t_ref is a reference time: time at which Y[t_ref] = lvl_Y. All lags and leads of Y are unknowns in the dynamic system, while here, in the steady state system, we have two unknowns, namely lvl_Y and slp_Y. For this reason, we take each equation at two different values of t.","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"In the case of @log X variable, we have the steady state substitution","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"X_t = exp(lvl_logX + (t-t_ref) * slp_logX)","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"Since the dynamic equations have already been transformed in terms of log(X_t), we actually have to do the substitution","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"log(X_t) = lvl_logX + (t-t_ref) slp_logX","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"which is the same as for non-log variables. So once again we don't need to do anything to the equations, we only need to transform the data.","category":"page"},{"location":"DesignPapers/log_variables/#Steady-state-constraints","page":"Log-variables","title":"Steady state constraints","text":"","category":"section"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"Here we expect the user to provide equations in terms of the original meaning of the log-variable. When X is mentioned in a level type constraint, we replace it by exp(lvl_logX) and similarly in a slope type constraint we replace is by exp(slp_logX).","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"This works well when the constraint is simply assigning a known value. The user must keep in mind that we interpret the slope as the common ratio of the geometric sequence and provide values in these terms.","category":"page"},{"location":"DesignPapers/log_variables/#Final-conditions","page":"Log-variables","title":"Final conditions","text":"","category":"section"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"This is discussed at the end of the article on final conditions. TLDR: we don't need to do anything special since we're working with the log-transformed variables.","category":"page"},{"location":"DesignPapers/log_variables/#Linearization","page":"Log-variables","title":"Linearization","text":"","category":"section"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"TODO","category":"page"},{"location":"DesignPapers/log_variables/#Transforming-the-data","page":"Log-variables","title":"Transforming the data","text":"","category":"section"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"Every value of user-provided data for a log-variable we must apply log() before using it internally. Also, every value we compute for a log-variable, we must apply exp() before returning it to the user.","category":"page"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"There is nothing special about this, we just have to make sure to do it.","category":"page"},{"location":"DesignPapers/log_variables/#Data-provided-in-deviation","page":"Log-variables","title":"Data provided in deviation","text":"","category":"section"},{"location":"DesignPapers/log_variables/","page":"Log-variables","title":"Log-variables","text":"TODO","category":"page"},{"location":"Reference/FAME/#FAME-Reference","page":"FAME","title":"FAME Reference","text":"","category":"section"},{"location":"Reference/FAME/","page":"FAME","title":"FAME","text":"Modules = [FAME]","category":"page"},{"location":"Reference/FAME/#FAME.chli","page":"FAME","title":"FAME.chli","text":"global chli\n\nThe internal state of FAME.jl. There is no reason for users to play with this.\n\n\n\n\n\n","category":"constant"},{"location":"Reference/FAME/#FAME.Chli","page":"FAME","title":"FAME.Chli","text":"struct Chli ⋯ end\n\nThe internal state of FAME.jl. There is no reason for users to play with this.\n\n\n\n\n\n","category":"type"},{"location":"Reference/FAME/#FAME.FameDatabase","page":"FAME","title":"FAME.FameDatabase","text":"mutable struct FameDatabase … end\n\nFame database. See also opendb, closedb!, postdb, listdb.\n\n\n\n\n\n","category":"type"},{"location":"Reference/FAME/#FAME.FameDate","page":"FAME","title":"FAME.FameDate","text":"FameDate\n\n64-bit integer type that FAME uses to encode dates of different frequencies.\n\n\n\n\n\n","category":"type"},{"location":"Reference/FAME/#FAME.FameIndex","page":"FAME","title":"FAME.FameIndex","text":"FameIndex\n\nInteger 64-bit type that represents the internal index FAME uses to access elements of series.\n\n\n\n\n\n","category":"type"},{"location":"Reference/FAME/#FAME.FameObject","page":"FAME","title":"FAME.FameObject","text":"mutable struct FameObject{CL,FT,FR,DT} … end\n\nFAME object of class CL, type FT, frequency FR and data type DT.\n\nA FameObject is returned by quick_info and a vector of FameObjects is returned by listdb. \n\nAlso, a FameObject can be constructed directly by calling FameObject(name, class, type, frequency) or FameObject(name, class, type, frequency, first_index, last_index). The values of class, type, and frequency can be symbols (like, :scalar, :precision, etc.) or integers. Refer to the FAME CHLI documentation for the code values.\n\n\n\n\n\n","category":"type"},{"location":"Reference/FAME/#FAME.FameRange","page":"FAME","title":"FAME.FameRange","text":"struct FameRange … end\n\nRange includes a frequency code and two endpoints start and end. This is a type used by the CHLI library.\n\n\n\n\n\n","category":"type"},{"location":"Reference/FAME/#FAME.HLIError","page":"FAME","title":"FAME.HLIError","text":"struct HLIError <: Exception … end\n\nException type for errors returned by CHLI calls.\n\n\n\n\n\n","category":"type"},{"location":"Reference/FAME/#FAME.Period","page":"FAME","title":"FAME.Period","text":"struct Period{FREQ} … end\n\nA FAME period includes the frequency, year and period. \n\n\n\n\n\n","category":"type"},{"location":"Reference/FAME/#FAME.check_status-Tuple{Ref{Int32}}","page":"FAME","title":"FAME.check_status","text":"check_status(status)\n\nCheck the status code returned by cfmXYZ functions. If status indicates success we do nothing, otherwise we trigger an HLIError with the error code and the message.\n\n\n\n\n\n","category":"method"},{"location":"Reference/FAME/#FAME.close_chli-Tuple{}","page":"FAME","title":"FAME.close_chli","text":"close_chli()\n\nFinalize FAME and unload the CHLI library. Normally, it should not be necessary to call this function. If you want to restart FAME, e.g., in order to clear the work database, call init_chli.\n\n\n\n\n\n","category":"method"},{"location":"Reference/FAME/#FAME.closedb!-Tuple{FameDatabase}","page":"FAME","title":"FAME.closedb!","text":"closedb!(db::FameDatabase)\n\nClose the given FAME database.\n\n\n\n\n\n","category":"method"},{"location":"Reference/FAME/#FAME.do_read!","page":"FAME","title":"FAME.do_read!","text":"do_read!(obj::FameObject, db::FameDatabase)\n\nRead data for the given FameObject from the given FameDatabase. obj is modified in place and returned.\n\nA FameObject can be created directly, or it could be returned by quick_info or listdb.\n\n\n\n\n\n","category":"function"},{"location":"Reference/FAME/#FAME.do_write","page":"FAME","title":"FAME.do_write","text":"do_write(obj::FameObject, db::FameDatabase)\n\nWrite the given FameObject to the given FameDatabase. If an object by the same name already exists, it is deleted before the new object is written.\n\n\n\n\n\n","category":"function"},{"location":"Reference/FAME/#FAME.fame","page":"FAME","title":"FAME.fame","text":"fame(io, command::String)\nfame(command::String; quiet=false)\n\nRun the FAME command command and write the output to io or the screen. If io is not specified the output can be suppressed with quiet=true.\n\n\n\n\n\n","category":"function"},{"location":"Reference/FAME/#FAME.init_chli-Tuple{}","page":"FAME","title":"FAME.init_chli","text":"init_chli()\n\nLoad the CHLI library and initialize FAME. If it is already loaded, we first close it and then load it fresh. See also close_chli.\n\n\n\n\n\n","category":"method"},{"location":"Reference/FAME/#FAME.item_option","page":"FAME","title":"FAME.item_option","text":"item_option(name, values...)\n\nSet ITEM option. These are used when matching a wildcard to database objects. Option names include \"CLASS\", \"TYPE\", \"FREQUENCY\", \"ALIAS\".\n\nWhen the values argument is not given, it defaults to \"ON\". Otherwise values should be strings and indicate which ITEMs are to be turned on.\n\n\n\n\n\n","category":"function"},{"location":"Reference/FAME/#FAME.listdb","page":"FAME","title":"FAME.listdb","text":"listdb(db::FameDatabase, [wc; filters...])\n\nList objects in the database that match the given wildcard and filters. Return a Vector{FameObject}.\n\nThe wildcard wc is a string containing wildcard characters. '^' matches any one character, while '?' matches any zero or more characters. If not given, the  default is '?' which would list the entire database.\n\nThe filters:\n\nalias::Bool - whether or not to match alias names. \nclass::String - which class of object to match. Multiple classes can be given in a comma-separated string, e.g., class=\"SERIES,SCALAR\".\ntype::String - which type of object to match, e.g., type=\"NUMERIC,PRECISION\".\nfreq::String - which frequency of object to match, e.g., freq=\"QUARTERLY\".\n\n\n\n\n\n","category":"function"},{"location":"Reference/FAME/#FAME.opendb","page":"FAME","title":"FAME.opendb","text":"opendb(dbname, [mode])\n\nOpen a FAME database and return an instance of FameDatabase for it.\n\ndbname can be a path to a .db file or a string specifying a database over a remote connection in the following format.\n\n\"[<tcp_port>@]<host> [<username> [<password>] ] <db>\"\n\nmode can be an integer (consult the CHLI help), or a Symbol. Valid modes include :readonly, :create, :overwrite, :update, :shared, :write, :direct_write.\n\n\n\n\n\n","category":"function"},{"location":"Reference/FAME/#FAME.postdb-Tuple{FameDatabase}","page":"FAME","title":"FAME.postdb","text":"postdb(db::FameDatabase)\n\nPost the given FAME database. If you've made any updates to the database you must post it before closing, otherwise all your changes will be lost.\n\n\n\n\n\n","category":"method"},{"location":"Reference/FAME/#FAME.quick_info-Tuple{FameDatabase, String}","page":"FAME","title":"FAME.quick_info","text":"quick_info(db, name)\n\nGet information about object named name in the given database. The information inlcudes its class, type, frequency, and range. Return a FameObject in which all these attributes are set correctly, but the data does not contain the correct values.\n\n\n\n\n\n","category":"method"},{"location":"Reference/FAME/#FAME.readfame","page":"FAME","title":"FAME.readfame","text":"readfame(db, args...; \n    namecase=lowercase,\n    prefix=nothing, glue=\"_\",\n    collect=[], \n    wc_options...)\n\nRead data from FAME database into Julia. The data is returned in a Workspace.\n\ndb is a FameDatabase or a String. If db is a String, the database will be opened in :readonly mode and closed after loading the data.\n\nIf the db string containing a path to a file, the path should be encapsulated in  escaped double quotes whenever the path contains spaces.\n\nIf db is the only argument, then all objects in the database will be loaded. Arguments and options can be used to restrict which objects will be loaded.\n\nEach positional argument after the first one should be a string or a Symbol. \n\nIf it is a string that contains a wildcard character ('?' or '^', see Fame help about wildcards) then we call listdb to obtain a list of objects matching the given wildcard. In this case, we pass the given wc_options... to listdb. You can use them to limit the wildcard search to specific class, type, frequency, etc. See listdb for details.\nOtherwise (Symbol or a string not containing wildcard characters), an object with the given name will be loaded. wc_options... are ignored, meaning that the object will be loaded no matter its class, type, frequency, etc.\n\nThe following options can be used to modify how the Julia identifiers are constructed from the FAME names.\n\nnamecase - FAME identifiers are case-insensitive and FAME always returns them in upper case. By default we convert the names to lower case. You can pass any function that takes a string and returns a string as the value of the namecase option. The default is lowercase. For example, this may be a good idea if your database contains names with symbols that are not allowed in Julia identifiers. Currently, we just call Symbol(namecase(fo.name)), but you may want to substitute such symbols for something else, e.g. namecase=(x->lowercase(replace(x, \"@\"=>\"_\"))).\nprefix, if given, will be stripped (together with glue) from the beginning of the FAME name. If the name does not begin with the given prefix then it will remain unchanged. If you want to load only names starting with the given prefix you must use the appropriate wildcard. Default is prefix=nothing, which disables this functionality. Note that prefix=nothing and prefix=\"\" are not the same.\ncollect can be a string/symbol, a vector whose elements are strings/symbols or vectors of strings/symbols, etc. If the name begins with one of the given collect values (together with the glue), then the object will be loaded in a nested Workspace. The idea is that nested Workspaces written to the database would be loaded in the same structure by providing the list of names of the nested Workspaces in the collect option value. See the examples below.\nglue is used to join the prefix or the collect strings to the rest of the name. Use the same value as in writefame in order for this to work.\n\nExamples\n\njulia> w = Workspace(; a = 1, b=TSeries(2020Q1, randn(10)),\n       s = MVTSeries(2020M1, (:q, :p), randn(24,2)),\n       c = Workspace(; alpha = 0.1, beta = 0.8, \n       n = Workspace(; s = \"Hello World\")\n       ))\nWorkspace with 4-variables\n  a ⇒ 1\n  b ⇒ 10-element TSeries{Quarterly} with range 2020Q1:2022Q2\n  s ⇒ 24×2 MVTSeries{Monthly} with range 2020M1:2021M12 and variables (q,p)\n  c ⇒ Workspace with 3-variables\n\njulia> writefame(\"data.db\", w); listdb(\"data.db\")\n7-element Vector{FameObject}:\n A: scalar,numeric,undefined,0:0,0:0\n B: series,precision,quarterly_december,2020:1,2022:2\n C_ALPHA: scalar,precision,undefined,0:0,0:0\n C_BETA: scalar,precision,undefined,0:0,0:0\n C_N_S: scalar,string,undefined,0:0,0:0\n S_P: series,precision,monthly,2020:1,2021:12\n S_Q: series,precision,monthly,2020:1,2021:12\n\njulia> # read only variables in the list\njulia> readfame(\"data.db\", \"a\", \"b\")\nWorkspace with 2-variables\n  a ⇒ 1.0\n  b ⇒ 10-element TSeries{Quarterly} with range 2020Q1:2022Q2\n\njulia> # read everything as it is in the database\njulia> readfame(\"data.db\")\nWorkspace with 7-variables\n        a ⇒ 1.0\n        b ⇒ 10-element TSeries{Quarterly} with range 2020Q1:2022Q2\n  c_alpha ⇒ 0.1\n   c_beta ⇒ 0.8\n    c_n_s ⇒ 11-codeunit String\n      s_p ⇒ 24-element TSeries{Monthly} with range 2020M1:2021M12\n      s_q ⇒ 24-element TSeries{Monthly} with range 2020M1:2021M12\n\njulia> # prefix is stripped where it appears (still loading everything)\njulia> readfame(\"data.db\", prefix=\"c\")\nWorkspace with 7-variables\n      a ⇒ 1.0\n      b ⇒ 10-element TSeries{Quarterly} with range 2020Q1:2022Q2\n  alpha ⇒ 0.1\n   beta ⇒ 0.8\n    n_s ⇒ 11-codeunit String\n    s_p ⇒ 24-element TSeries{Monthly} with range 2020M1:2021M12\n    s_q ⇒ 24-element TSeries{Monthly} with range 2020M1:2021M12\n\njulia> # wildcard search, no prefix (name remains unchanged)\njulia> readfame(\"data.db\", \"s?\")\nWorkspace with 2-variables\n  s_p ⇒ 24-element TSeries{Monthly} with range 2020M1:2021M12\n  s_q ⇒ 24-element TSeries{Monthly} with range 2020M1:2021M12\n\njulia> # prefix (stripped) with matching wildcard search\njulia> readfame(\"data.db\", \"s?\", prefix=\"s\")  \nWorkspace with 2-variables\n  p ⇒ 24-element TSeries{Monthly} with range 2020M1:2021M12\n  q ⇒ 24-element TSeries{Monthly} with range 2020M1:2021M12\n\njulia> # collect with matching wildcard\njulia> readfame(\"data.db\", \"c?\", collect=\"c\")   \nWorkspace with 1-variables\n  c ⇒ Workspace with 3-variables\n\njulia> # nested collect - matches the original structure of nested Workspaces\njulia> readfame(\"data.db\", collect=[\"c\"=>[\"n\"], \"s\"])  \nWorkspace with 4-variables\n  a ⇒ 1.0\n  b ⇒ 10-element TSeries{Quarterly} with range 2020Q1:2022Q2\n  c ⇒ Workspace with 3-variables\n  s ⇒ Workspace with 2-variables\n\njulia> readfame(\"\"/home/usr/my data directory/data.db\"\", \"a\", \"b\")   \nWorkspace with 2-variables\n  a ⇒ 1.0\n  b ⇒ 10-element TSeries{Quarterly} with range 2020Q1:2022Q2\n\n\n\n\n\n\n","category":"function"},{"location":"Reference/FAME/#FAME.refame","page":"FAME","title":"FAME.refame","text":"refame(name, value)\n\nConvert the given value to a FameObject\n\nReal => NUMERIC SCALAR (includes integers)\nFloat64 => PRECISION SCALAR\nBool => BOOLEAN SCALAR\nMIT => DATE SCALAR\nString => NAMELIST, if it is in the form \"{name1,name2,...}\", otherwise STRING SCALAR\nVector{String} => CASE SERIES of STRING\nTSeries => a SERIES of the same frequency and type. The type conversions are the same as for scalars.\n\n\n\n\n\n","category":"function"},{"location":"Reference/FAME/#FAME.unfame","page":"FAME","title":"FAME.unfame","text":"unfame(fo::FameObject)\n\nConvert a FameObject to a Julia type.\n\nPRECISION SCALAR => Float64\nNUMERIC SCALAR => Float32\nSTRING SCALAR => String\nBOOLEAN SCALAR => Bool\nNAMELIST => String (Formatted as \"{NAME1,NAME2,ETC}\", see Fame help for details.)\nDATE SCALAR => MIT (CASE becomes MIT{Unit}, Frequencies not supported by TimeSeriesEcon throw an ErrorException)\nPRECISION SERIES => TSeries\nNUMERIC SERIES => TSeries with element type Float32\nBOOLEAN SERIES => TSeries with element type Bool\nDATE SERIES => TSeries with element type MIT\nSTRING SERIES => Vector{String} (the time series metadata is lost) \n\n\n\n\n\n","category":"function"},{"location":"Reference/FAME/#FAME.version-Tuple{}","page":"FAME","title":"FAME.version","text":"version()\n\nReturn the version of FAME in use. \n\n\n\n\n\n","category":"method"},{"location":"Reference/FAME/#FAME.workdb","page":"FAME","title":"FAME.workdb","text":"workdb()\n\nReturn a FameDatabase instance for the work database. \n\nSince the work database can be open only once, we create an instance the first time and return the existing instance each subsequent time.\n\n\n\n\n\n","category":"function"},{"location":"Reference/FAME/#FAME.writefame","page":"FAME","title":"FAME.writefame","text":"writefame(db, data; options)\n\nWrite Julia data to a FAME database.\n\nArguments:\n\ndb can be a string containing the path to a FAME .db file or an instance of FameDatabase.\ndata is a collection of data which will be written to the database.\nIf data is an MVTSeries, each series will be written to the database.\nIf data is a Workspace, each element will be written as a separate FAME object. In this case any nested Workspace of MVTSeries objects will be written recursively by prepending the names.\n\nOptions:\n\nmode::Symbol - if db is a string, the database is opened with the given mode. The default is :overwrite.\nprefix::Union{Nothing,String} - the given prefix will be prepended to the name of each object written in the database. The default is nothing, i.e. nothing will be prepended. NOTE: prefix=nothing and prefix=\"\" are not the same.\nglue::String - the glue is used to join the prefix to the name. The default is \"_\".\n\nExamples:\n\njulia> w = Workspace(; a=1, b=TSeries(2020Q1,ones(10)), s=MVTSeries(2020M1, collect(\"ab\"), randn(24,2)))\nWorkspace with 2-variables\n  a ⇒ 1.0\n  b ⇒ 10-element TSeries{Quarterly} with range 2020Q1:2022Q2\n  s ⇒ 24×2 MVTSeries{Monthly} with range 2020M1:2021M12 and variables …\n\njulia> writefame(\"w.db\", w)\n\njulia> listdb(\"w.db\")\n2-element Vector{FAME.FameObject}:\n A: scalar,precision,undefined,0:0,0:0\n B: series,precision,quarterly_december,2020:1,2022:2\n S_A: series,precision,monthly,2020:1,2021:12\n S_B: series,precision,monthly,2020:1,2021:12\n\n\n\n\n\n\n","category":"function"},{"location":"Reference/FAME/#FAME.@cfm_call-Tuple{Any, Any, Vararg{Any}}","page":"FAME","title":"FAME.@cfm_call","text":"@cfm_call(:cfmXYZ, argTypes, args...)\n\nBuild an appropriate ccall to the given cfmXYZ function. When using this macro, include the status variable and check it yourself.\n\nSee also: @cfm_call_check\n\n\n\n\n\n","category":"macro"},{"location":"Reference/FAME/#FAME.@cfm_call_check-Tuple{Any}","page":"FAME","title":"FAME.@cfm_call_check","text":"@cfm_call_check(:cfmXYZ, argTypes, args...)\n\nCall the cfm function and check status. When using this macro, do not include the status variable.\n\nSee also: @cfm_call\n\n\n\n\n\n","category":"macro"},{"location":"Reference/FAME/#FAME.@cfm_global-Tuple{Any, Any}","page":"FAME","title":"FAME.@cfm_global","text":"@cfm_global(:cfmXYZ, type)\n\nFetch the value of a constant by the given name from the CHLI library.\n\nSee also: @cfm_call_check\n\n\n\n\n\n","category":"macro"},{"location":"Reference/FAME/#FAME.@fame_call-Tuple{Any, Any, Vararg{Any}}","page":"FAME","title":"FAME.@fame_call","text":"@fame_call(:fame_XYZ, argTypes, args...)\n\nBuild an appropriate ccall to the given fame_XYZ function. \n\nSee also: @cfm_call_check\n\n\n\n\n\n","category":"macro"},{"location":"Reference/FAME/#FAME.@fame_call_check-Tuple{Any, Any, Vararg{Any}}","page":"FAME","title":"FAME.@fame_call_check","text":"@fame_call_check(:fame_XYZ, argTypes, args...)\n\nBuild an appropriate ccall to the given fame_XYZ function. This macro also checks the status and throws an error if not success.\n\nSee also: @cfm_call_check\n\n\n\n\n\n","category":"macro"},{"location":"Reference/FAME/#FAME.@fame_str","page":"FAME","title":"FAME.@fame_str","text":"fame\"command\"\nfame\"command\"q\n\nRun the the FAME command and write the output to the screen, or suppress the output if the q flag is present.\n\n\n\n\n\n","category":"macro"},{"location":"Tutorials/LICENSE/","page":"-","title":"-","text":"BSD 3-Clause License","category":"page"},{"location":"Tutorials/LICENSE/","page":"-","title":"-","text":"Copyright (c) 2020, Bank of Canada All rights reserved.","category":"page"},{"location":"Tutorials/LICENSE/","page":"-","title":"-","text":"Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:","category":"page"},{"location":"Tutorials/LICENSE/","page":"-","title":"-","text":"Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.","category":"page"},{"location":"Tutorials/LICENSE/","page":"-","title":"-","text":"THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","category":"page"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon-Reference","page":"TimeSeriesEcon","title":"TimeSeriesEcon Reference","text":"","category":"section"},{"location":"Reference/TimeSeriesEcon/","page":"TimeSeriesEcon","title":"TimeSeriesEcon","text":"Modules = [TimeSeriesEcon]","category":"page"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.TimeSeriesEcon","page":"TimeSeriesEcon","title":"TimeSeriesEcon.TimeSeriesEcon","text":"TimeSeriesEcon\n\nThis package is part of the StateSpaceEcon ecosystem. Provides the data types and functionality necessary to work with macroeconomic discrete time models.\n\nWorking with time\n\nFrequencies are represented by abstract type Frequency. \nConcrete frequencies include Yearly, Quarterly and Monthly.\nMoments in time are represented by data type MIT.\nLengths of time are represented by data type Duration.\n\nWorking with time series\n\nData type TSeries represents a single time series.\nData type MVTSeries represents a multivariate time series.\n\nWorking with other data\n\nData type Workspace is a general purpose dictionary-like collection of \"variable\"-like objects.\n\nTutorial\n\nTimeSeriesEcon tutorial\n\n\n\n\n\n","category":"module"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.M1","page":"TimeSeriesEcon","title":"TimeSeriesEcon.M1","text":"Convenience constants that make MIT literal constants possible. For example, the constant Q1 makes it possible to write 2020Q1 instead of MIT{Quarterly}(2020, 1). Use U for MIT{Unit}, Y for MIT{Yearly}, Q1 to Q4 for MIT{Quarterly} and M1 to M12 for MIT{Monthly}\n\n\n\n\n\n","category":"constant"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.M10","page":"TimeSeriesEcon","title":"TimeSeriesEcon.M10","text":"Convenience constants that make MIT literal constants possible. For example, the constant Q1 makes it possible to write 2020Q1 instead of MIT{Quarterly}(2020, 1). Use U for MIT{Unit}, Y for MIT{Yearly}, Q1 to Q4 for MIT{Quarterly} and M1 to M12 for MIT{Monthly}\n\n\n\n\n\n","category":"constant"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.M11","page":"TimeSeriesEcon","title":"TimeSeriesEcon.M11","text":"Convenience constants that make MIT literal constants possible. For example, the constant Q1 makes it possible to write 2020Q1 instead of MIT{Quarterly}(2020, 1). Use U for MIT{Unit}, Y for MIT{Yearly}, Q1 to Q4 for MIT{Quarterly} and M1 to M12 for MIT{Monthly}\n\n\n\n\n\n","category":"constant"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.M12","page":"TimeSeriesEcon","title":"TimeSeriesEcon.M12","text":"Convenience constants that make MIT literal constants possible. For example, the constant Q1 makes it possible to write 2020Q1 instead of MIT{Quarterly}(2020, 1). Use U for MIT{Unit}, Y for MIT{Yearly}, Q1 to Q4 for MIT{Quarterly} and M1 to M12 for MIT{Monthly}\n\n\n\n\n\n","category":"constant"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.M2","page":"TimeSeriesEcon","title":"TimeSeriesEcon.M2","text":"Convenience constants that make MIT literal constants possible. For example, the constant Q1 makes it possible to write 2020Q1 instead of MIT{Quarterly}(2020, 1). Use U for MIT{Unit}, Y for MIT{Yearly}, Q1 to Q4 for MIT{Quarterly} and M1 to M12 for MIT{Monthly}\n\n\n\n\n\n","category":"constant"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.M3","page":"TimeSeriesEcon","title":"TimeSeriesEcon.M3","text":"Convenience constants that make MIT literal constants possible. For example, the constant Q1 makes it possible to write 2020Q1 instead of MIT{Quarterly}(2020, 1). Use U for MIT{Unit}, Y for MIT{Yearly}, Q1 to Q4 for MIT{Quarterly} and M1 to M12 for MIT{Monthly}\n\n\n\n\n\n","category":"constant"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.M4","page":"TimeSeriesEcon","title":"TimeSeriesEcon.M4","text":"Convenience constants that make MIT literal constants possible. For example, the constant Q1 makes it possible to write 2020Q1 instead of MIT{Quarterly}(2020, 1). Use U for MIT{Unit}, Y for MIT{Yearly}, Q1 to Q4 for MIT{Quarterly} and M1 to M12 for MIT{Monthly}\n\n\n\n\n\n","category":"constant"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.M5","page":"TimeSeriesEcon","title":"TimeSeriesEcon.M5","text":"Convenience constants that make MIT literal constants possible. For example, the constant Q1 makes it possible to write 2020Q1 instead of MIT{Quarterly}(2020, 1). Use U for MIT{Unit}, Y for MIT{Yearly}, Q1 to Q4 for MIT{Quarterly} and M1 to M12 for MIT{Monthly}\n\n\n\n\n\n","category":"constant"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.M6","page":"TimeSeriesEcon","title":"TimeSeriesEcon.M6","text":"Convenience constants that make MIT literal constants possible. For example, the constant Q1 makes it possible to write 2020Q1 instead of MIT{Quarterly}(2020, 1). Use U for MIT{Unit}, Y for MIT{Yearly}, Q1 to Q4 for MIT{Quarterly} and M1 to M12 for MIT{Monthly}\n\n\n\n\n\n","category":"constant"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.M7","page":"TimeSeriesEcon","title":"TimeSeriesEcon.M7","text":"Convenience constants that make MIT literal constants possible. For example, the constant Q1 makes it possible to write 2020Q1 instead of MIT{Quarterly}(2020, 1). Use U for MIT{Unit}, Y for MIT{Yearly}, Q1 to Q4 for MIT{Quarterly} and M1 to M12 for MIT{Monthly}\n\n\n\n\n\n","category":"constant"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.M8","page":"TimeSeriesEcon","title":"TimeSeriesEcon.M8","text":"Convenience constants that make MIT literal constants possible. For example, the constant Q1 makes it possible to write 2020Q1 instead of MIT{Quarterly}(2020, 1). Use U for MIT{Unit}, Y for MIT{Yearly}, Q1 to Q4 for MIT{Quarterly} and M1 to M12 for MIT{Monthly}\n\n\n\n\n\n","category":"constant"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.M9","page":"TimeSeriesEcon","title":"TimeSeriesEcon.M9","text":"Convenience constants that make MIT literal constants possible. For example, the constant Q1 makes it possible to write 2020Q1 instead of MIT{Quarterly}(2020, 1). Use U for MIT{Unit}, Y for MIT{Yearly}, Q1 to Q4 for MIT{Quarterly} and M1 to M12 for MIT{Monthly}\n\n\n\n\n\n","category":"constant"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.U","page":"TimeSeriesEcon","title":"TimeSeriesEcon.U","text":"Convenience constants that make MIT literal constants possible. For example, the constant Q1 makes it possible to write 2020Q1 instead of MIT{Quarterly}(2020, 1). Use U for MIT{Unit}, Y for MIT{Yearly}, Q1 to Q4 for MIT{Quarterly} and M1 to M12 for MIT{Monthly}\n\n\n\n\n\n","category":"constant"},{"location":"Reference/TimeSeriesEcon/#Dates.Date","page":"TimeSeriesEcon","title":"Dates.Date","text":"Dates.Date(m::MIT, values_base::Symbol=:end)\n\nReturns a Date object representing the last day in the provided MIT. Returns the first day in the provided MIT when values_base == true.\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.BDaily","page":"TimeSeriesEcon","title":"TimeSeriesEcon.BDaily","text":"struct BDaily <: CalendarFrequency end\n\nRepresents a business daily frequency (excludes weekends).\n\nSee also: Frequency\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.CalendarFrequency","page":"TimeSeriesEcon","title":"TimeSeriesEcon.CalendarFrequency","text":"abstract type CalendarFrequency <: Frequencies  end\n\nRepresents frequencies associated with a specific gregorian calendar position.\n\nSee also: Frequency, YPFrequency\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.Daily","page":"TimeSeriesEcon","title":"TimeSeriesEcon.Daily","text":"struct Daily <: CalendarFrequency end\n\nRepresents a daily frequency.\n\nSee also: CalendarFrequency\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.Duration","page":"TimeSeriesEcon","title":"TimeSeriesEcon.Duration","text":"MIT{F <: Frequency}, Duration{F <: Frequency}\n\nTwo types representing a moment in time (like 2020Q1 or 2020Y) and duration (the quantity of time between two moments).\n\nBoth of these have a Frequency as a type parameter and both internally are represented by integer values.\n\nIf you imagine a time axis of the given Frequency, MIT values are ordinal (correspond to points) while Duration values are cardinal (correspond to distances).\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.Frequency","page":"TimeSeriesEcon","title":"TimeSeriesEcon.Frequency","text":"abstract type Frequency end\n\nThe abstract supertype for all frequencies.\n\nSee also: Unit and YPFrequency\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.HalfYearly","page":"TimeSeriesEcon","title":"TimeSeriesEcon.HalfYearly","text":"struct HalfYearly{end_month} <: YPFrequency{2} end\n\nA concrete frequency defined as 2 periods per year.\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.MIT","page":"TimeSeriesEcon","title":"TimeSeriesEcon.MIT","text":"MIT{F <: Frequency}, Duration{F <: Frequency}\n\nTwo types representing a moment in time (like 2020Q1 or 2020Y) and duration (the quantity of time between two moments).\n\nBoth of these have a Frequency as a type parameter and both internally are represented by integer values.\n\nIf you imagine a time axis of the given Frequency, MIT values are ordinal (correspond to points) while Duration values are cardinal (correspond to distances).\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.MIT-Union{Tuple{F}, Tuple{N}, Tuple{Integer, Integer}} where {N, F<:YPFrequency{N}}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.MIT","text":"MIT{F}(year, period) where {F <: YPFrequency}\n\nConstruct an MIT instance from year and period. This is valid only for frequencies subtyped from YPFrequency.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.MVTSeries","page":"TimeSeriesEcon","title":"TimeSeriesEcon.MVTSeries","text":"mutable struct MVTSeries{F,T,C} <: AbstractMatrix{T}\n    firstdate::MIT{F}\n    columns::OrderedDict{Symbol,TSeries{F,T}}\n    values::C\nend\n\nMulti-variate Time series with frequency F with values of type T stored in a container of type C. By default the type is Float64 and the container is Matrix{Float64}. The rows correspond to moments in time and the columns correspond to variables. Columns are named. The values in the field columns are TSeries whose storages are views into the corresponding columns of the values matrix.\n\nConstruction:\n\nx = MVTSeries(args...)\n\nThe standard construction is MVTSeries(firstdate::MIT, names, values) Here names should be a tuple of Symbols and values should be a matrix of the same number of columns as there are names in names. The range of the MVTSeries is determined from the number of rows of values. If values is not provided, the MVTSeries is constructed empty with size (0, length(names)). Ifnamesis also not provided, theMVTSeriesis constructed empty with size(0, 0)`.\n\nThe first argument can be a range. MVTSeries(range::AbstractUnitRange{<:MIT}, names, values)  In this case the size of the MVTSeries is determined by the lengths of range and names; the values argument is interpreted as an initializer. If it is omitted or set to undef, the storage is left uninitialized. If it is a number, the storage is filled with it. It can also be an initializer function, such as zeros, ones or rand. Lastly, if the values argument is an array, it must be 2-dimensional and of the correct size.\n\nAnother possibility is to construct from a collection of name-value pairs. MVTSeries(range; var1 = val1, var2 = val2, ...) The range argument is optional, if missing it'll be determined from the ranges of the given values. The values can be TSeries, vectors or constants. Any vector must have the same length as the range.\n\nAn MVTSeries can also be constructed with copy, similar, and fill.\n\nIndexing:\n\nIndexing with integers, integer ranges, or boolean arrays works the same as with Matrix. The result from slicing with integer ranges or boolean arrays is always a Matrix, i.e., the MVTSeries structure is lost.\n\nIndexing with two indexes works as follows. The first index can be an MIT or a range of MIT and it works the same as for   TSeries. The second index can be a Symbol or a collection of Symbols, such as a tuple or a vector. begin and end work for the first index the same as with TSeries.\n\nIndexing with one index depends on the type. If it is MIT or a  range of MIT, it is treated as if the second index were :, i.e., the  entire row or multiple rows is returned. If the index is a Symbol or  a collection of Symbols, it is treated as if the first index were :,  i.e., entire column or multiple columns is returned as TSeries or MVTSeries respectively.\n\nColumns can also be accessed using \"dot\" notation. For example x[:a] is the same as x.a.\n\nCheck out the tutorial at  https://bankofcanada.github.io/DocsEcon.jl/dev/Tutorials/TimeSeriesEcon/main/\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.Monthly","page":"TimeSeriesEcon","title":"TimeSeriesEcon.Monthly","text":"struct Monthly <: YPFrequency{12} end\n\nA concrete frequency defined as 12 periods per year.\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.Q1","page":"TimeSeriesEcon","title":"TimeSeriesEcon.Q1","text":"Convenience constants that make MIT literal constants possible. For example, the constant Q1 makes it possible to write 2020Q1 instead of MIT{Quarterly}(2020, 1). Use U for MIT{Unit}, Y for MIT{Yearly}, Q1 to Q4 for MIT{Quarterly} and M1 to M12 for MIT{Monthly}\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.Q2","page":"TimeSeriesEcon","title":"TimeSeriesEcon.Q2","text":"Convenience constants that make MIT literal constants possible. For example, the constant Q1 makes it possible to write 2020Q1 instead of MIT{Quarterly}(2020, 1). Use U for MIT{Unit}, Y for MIT{Yearly}, Q1 to Q4 for MIT{Quarterly} and M1 to M12 for MIT{Monthly}\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.Q3","page":"TimeSeriesEcon","title":"TimeSeriesEcon.Q3","text":"Convenience constants that make MIT literal constants possible. For example, the constant Q1 makes it possible to write 2020Q1 instead of MIT{Quarterly}(2020, 1). Use U for MIT{Unit}, Y for MIT{Yearly}, Q1 to Q4 for MIT{Quarterly} and M1 to M12 for MIT{Monthly}\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.Q4","page":"TimeSeriesEcon","title":"TimeSeriesEcon.Q4","text":"Convenience constants that make MIT literal constants possible. For example, the constant Q1 makes it possible to write 2020Q1 instead of MIT{Quarterly}(2020, 1). Use U for MIT{Unit}, Y for MIT{Yearly}, Q1 to Q4 for MIT{Quarterly} and M1 to M12 for MIT{Monthly}\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.Quarterly","page":"TimeSeriesEcon","title":"TimeSeriesEcon.Quarterly","text":"struct Quarterly{end_month} <: YPFrequency{4} end\n\nA concrete frequency defined as 4 periods per year. The default end_month is 3.\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.TSeries","page":"TimeSeriesEcon","title":"TimeSeriesEcon.TSeries","text":"mutable struct TSeries{F, T, C} <: AbstractVector{T}\n    firstdate::MIT{F}\n    values::C\nend\n\nTime series with frequency F and values of type T stored in a container of type C. By default the type is Float64 and the container is Vector{Float64}.\n\nConstruction:\n\nts = TSeries(args...)\n\nThe standard construction is TSeries(firstdate::MIT, values::AbstractVector). If the second argument is not given, the TSeries is constructed empty.\n\nAlternatively, the first argument can be a range. In this case, the second argument is interpreted as an initializer. If it is omitted or set to undef, the storage is left uninitialized. If it is a number, the storage is filled with it. It can also be an initializer function, such as zeros, ones or rand. Lastly, if the second argument is an array, it must be 1-dimensional and of the same length as the range given in the first argument.\n\nIf only an integer number is given, as in TSeries(n::Integer), the constructed TSeries will have frequency Unit, first date 1U and length n. An initialization argument is not allowed in this case, so the storage remains uninitialized.\n\nA TSeries can also be constructed with copy, similar, and fill, ones, zeros.\n\nIndexing:\n\nIndexing with an MIT or a range of MIT works as you'd expect.\n\nIndexing with Integers works the same as with Vector.\n\nIndexing with Bool-array works as you'd expect. For example, s[s .< 0.0] .*= -1 multiplies in place the negative entries of s by -1, so effectively it's the same as s .= abs.(s).\n\nThere are important differences between indexing with MIT and not using MIT (i.e., using Integer or Bool-array).\n\nwith MIT-range we return a TSeries, otherwise we   return a Vector.\nthe range can be extended (the TSeries resized appropriately) by   assigning outside the current range. This works only with MIT.   With anything else you get a BoundsError if you try to assign outside the   Integer range.\nbegin and end are MIT, so either use both or none of them.   For example s[2:end] doesn't work because 2 is an Int and end is an   MIT. You should use s[begin+1:end].\n\nCheck out the tutorial at  https://bankofcanada.github.io/DocsEcon.jl/dev/Tutorials/TimeSeriesEcon/main/\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.Unit","page":"TimeSeriesEcon","title":"TimeSeriesEcon.Unit","text":"struct Unit <: Frequency end\n\nRepresents a non-dimensional frequency (not associated with the calendar).\n\nSee also: Frequency, YPFrequency\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.Weekly","page":"TimeSeriesEcon","title":"TimeSeriesEcon.Weekly","text":"struct Weekly{end_day} <: Frequency end\n\nRepresents a weekly frequency. The default weekly series ends on a Sunday (end_day = 7).\n\nSee also: Frequency\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.Workspace","page":"TimeSeriesEcon","title":"TimeSeriesEcon.Workspace","text":"struct Workspace\n    …\nend\n\nA collection of variables. Workspaces can store data of any kind, including numbers, MITs, ranges, strings, TSeries, MVTSeries, even nested Workspaces.\n\nConstruction\n\nEasiest is to start with and empty Workspace and fill it up later. Otherwise, content can be provided at construction time as a collection of name-value pairs, where the name must be a Symbol and the value can be anything.\n\nAccess\n\nMembers of the Workspace can be accessed using \"dot\" notation or using [] indexing, like a dictionary.\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.Y","page":"TimeSeriesEcon","title":"TimeSeriesEcon.Y","text":"Convenience constants that make MIT literal constants possible. For example, the constant Q1 makes it possible to write 2020Q1 instead of MIT{Quarterly}(2020, 1). Use U for MIT{Unit}, Y for MIT{Yearly}, Q1 to Q4 for MIT{Quarterly} and M1 to M12 for MIT{Monthly}\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.YPFrequency","page":"TimeSeriesEcon","title":"TimeSeriesEcon.YPFrequency","text":"abstract type YPFrequency{N} <: Frequency end\n\nRepresents a calendar frequency defined by a number of periods in a year. The type parameter N is the number of periods and must be a positive integer. \n\nSee also: Frequency, Yearly, HalfYearly, Quarterly, Monthly\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.Yearly","page":"TimeSeriesEcon","title":"TimeSeriesEcon.Yearly","text":"struct Yearly{end_month} <: YPFrequency{1} end\n\nA concrete frequency defined as 1 period per year. The default end_month is 12.\n\n\n\n\n\n","category":"type"},{"location":"Reference/TimeSeriesEcon/#Base.diff","page":"TimeSeriesEcon","title":"Base.diff","text":"diff(x::TSeries)\ndiff(x::TSeries, k)\n\nConstruct the first difference, or the k-th difference, of time series t. If y = diff(x,k) then y[t] = x[t] - x[t+k]. A negative value of k means that we subtract a lag and positive value means that we subtract a lead. k not given is the same as k=-1, which matches the standard definition of first difference.\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#Base.fill-Tuple{Any, AbstractUnitRange{<:MIT}, Union{Tuple{Vararg{Symbol, N}}, Vector{Symbol}} where N}","page":"TimeSeriesEcon","title":"Base.fill","text":"fill(val, range)\nfill(val, range, variables)\n\nIn the first form create a TSeries with the given range. In the second form create an MVTSeries with the given range and variables. In both cases they are filled with the given value val.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#Base.pairs-Tuple{MVTSeries}","page":"TimeSeriesEcon","title":"Base.pairs","text":"pairs(data::MVTSeries; copy = false)\n\nReturns an iterator over the named columns of data. Each iteration gives a name-value pair where name is a Symbol and value is a TSeries.\n\nSetting copy=true is equivalent to pairs(copy(data)) but slightly more efficient.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#Base.resize!-Tuple{TSeries, AbstractUnitRange{<:MIT}}","page":"TimeSeriesEcon","title":"Base.resize!","text":"resize!(t::TSeries, rng)\n\nExtend or shrink the allocated storage for t so that the new range of t equals the given rng. If t is extended, new entries are set to NaN, or the appropriate Not-A-Number value (see typenan).\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#Base.resize!-Tuple{TSeries, Integer}","page":"TimeSeriesEcon","title":"Base.resize!","text":"resize!(t::TSeries, n::Integer)\n\nExtend or shrink the allocated storage for t to n entries. The first date of t does not change. If allocation is extended, the new entries are set to NaN.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#Base.similar-Tuple{MVTSeries}","page":"TimeSeriesEcon","title":"Base.similar","text":"similar(t::MVTSeries, [eltype], [shape])\nsimilar(array, [eltype], shape)\nsimilar(array_type, [eltype], shape)\n\nCreate an uninitialized MVTSeries with the given element type and shape.\n\nIf the first argument is an MVTSeries then the element type and shape of the output will match those of the input, unless they are explicitly given in subsequent arguments. If the first argument is another array or an array type, then shape must be given in the form of a tuple where the first element is an MIT range and the second is a list of column names. The element type, eltype, also can be given optionally; if not given it will be deduced from the first argument.\n\nExample: \n\nsimilar(Array{Float64}, (2000Q1:2001Q4, (:a, :b)))\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#Base.similar-Tuple{TSeries}","page":"TimeSeriesEcon","title":"Base.similar","text":"similar(t::TSeries, [eltype], [range])\nsimilar(array, [eltype], range)\nsimilar(array_type, [eltype], range)\n\nCreate an uninitialized TSeries with the given element type and range.\n\nIf the first argument is a TSeries then the element type and range of the output will match those of the input, unless they are explicitly given in subsequent arguments. If the first argument is another array or an array type, then range must be given. The element type, eltype, can be given; if not it will be deduced from the first argument.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#Base.strip-Tuple{TSeries}","page":"TimeSeriesEcon","title":"Base.strip","text":"strip(t:TSeries)\n\nRemove leading and trailing NaN from the given time series. This version creates a new TSeries instance.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.apct-Union{Tuple{TSeries{var\"#s68\", T} where {var\"#s68\"<:YPFrequency{N}, T<:Number}}, Tuple{N}, Tuple{TSeries{var\"#s3\", T} where {var\"#s3\"<:YPFrequency{N}, T<:Number}, Bool}} where N","page":"TimeSeriesEcon","title":"TimeSeriesEcon.apct","text":"apct(x::TSeries, islog::Bool)\n\nAnnualised percent rate of change in x.\n\nExamples\n\njulia> x = TSeries(qq(2018, 1), Vector(1:8));\n\njulia> apct(x)\nTSeries{Quarterly{3}} of length 7\n2018Q2: 1500.0\n2018Q3: 406.25\n2018Q4: 216.04938271604937\n2019Q1: 144.140625\n2019Q2: 107.35999999999999\n2019Q3: 85.26234567901243\n2019Q4: 70.59558517284461\n\nSee also: pct\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.bdaily-Tuple{Dates.Date}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.bdaily","text":"bdaily(d::Date; bias_previous::Bool=true)\n\nConstruct an MIT{BDaily} from a Date object. \n\nThe optional bias_previous argument determines which side of a weekend to land on when the provided date is Saturday or Sunday. The default is true, meaning that the preceding Friday is returned.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.bdaily-Tuple{String}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.bdaily","text":"bdaily(d::String; bias_previous::Bool=true)\n\nConstruct an MIT{BDaily} from a String. The string must be convertible to a Date via the Dates.Date(d::String) method.\n\nThe optional bias_previous argument determines which side of a weekend to land on when the provided date is Saturday or Sunday. The default is true, meaning that the preceding Friday is returned.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.clean_old_frequencies!","page":"TimeSeriesEcon","title":"TimeSeriesEcon.clean_old_frequencies!","text":"clean_old_frequencies!\n\nLike clean_old_frequencies, but in place. \n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.clean_old_frequencies-Tuple{Any}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.clean_old_frequencies","text":"clean_old_frequencies(m::MIT)\nclean_old_frequencies(ts::TSeries)\nclean_old_frequencies(mvts::MVTSeries)\nclean_old_frequencies(ws::Workspace)\nclean_old_frequencies!(ws::Workspace)\n\nThe internal representation for Quarterly and Yearly frequencies has changed between v0.4 and v0.5 of the TimeSeriesEcon package. Some stored data from old frequencies may need to be processed after loading to convert the objects to ones using the new frequencies.\n\nExample:     using JLD2     ws = Workspace(load(\"storedworkspace.jld2\"))     TimeSeriesEcon.cleanold_frequencies!(ws)\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.cleanedvalues-Tuple{MVTSeries{BDaily, T} where T<:Number}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.cleanedvalues","text":"cleanedvalues(t::MVTSeries{BDaily}; skip_all_nans::Bool=false, skip_holidays::Bool=false, holidays_map::Union{Nothing, TSeries{BDaily}} = nothing)\n\nReturns a matrix of values of a BDaily MVTSeries filtered according to the provided optional arguments. \nBy default, all values are returned.\n\nOptional arguments:\n* `skip_all_nans` : When `true`, returns all rows for which none of the values are NaN. Displays a warning if rows are removed where some of the values are not Nan. Default is `false`.\n* `skip_holidays` : When `true`, returns all rows which do not fall on a holiday according to the holidays map set in TimeSeriesEcon.getoption(:bdaily_holidays_map). Default: `false`.\n* `holidays_map`  : Returns all rows that do not fall on a holiday according to the provided map which must be a BDaily TSeries of Booleans. Default is `nothing`.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.cleanedvalues-Tuple{TSeries{BDaily, T} where T<:Number}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.cleanedvalues","text":"cleanedvalues(t::TSeries{BDaily}; skip_all_nans::Bool=false, skip_holidays::Bool=false, holidays_map::Union{Nothing, TSeries{BDaily}} = nothing)\n\nReturns the values of a BDaily TSeries filtered according to the provided optional arguments. By default, all values are returned.\n\nOptional arguments:\n* `skip_all_nans` : When `true`, returns all values which are not NaN values. Default is `false`.\n* `skip_holidays` : When `true`, returns all values which do not fall on a holiday according to the holidays map set in TimeSeriesEcon.getoption(:bdaily_holidays_map). Default: `false`.\n* `holidays_map`  : Returns all values that do not fall on a holiday according to the provided map which must be a BDaily TSeries of Booleans. Default is `nothing`.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.clear_holidays_map-Tuple{}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.clear_holidays_map","text":"clear_holidays_map()\n\nClears the current holidays map.\n\nSee also: get_holidays_options, set_holidays_map\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.colnames-Tuple{MVTSeries}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.colnames","text":"colnames(x::MVTSeries)\n\nReturn the names of the columns of x as an iterable.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.columns-Tuple{MVTSeries}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.columns","text":"columns(x::MVTSeries)\n\nReturn the columns of x as a dictionary. \n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.compare","page":"TimeSeriesEcon","title":"TimeSeriesEcon.compare","text":"@compare x y [options]  compare(x, y [; options])\n\nCompare two Workspace recursively and print out the differences. MVTSeries and Dict with keys of type Symbol are treated like Workspace. TSeries and other Vector are compared using isapprox, so feel free to supply rtol or atol.\n\nOptional argument name can be used for the top name. Default is \"_\".\n\nParameter showequal=true causes the report to include objects that are the same. Default behaviour, with showequal=false, is to report only the differences. \n\nParameter ignoremissing=true causes objects that appear in one but not the other workspace to be ignored. That is, they are not printed and do not affect the return value true or false. Default is ignoremissing=false meaning they will be printed and return value will be false.\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.daily-Tuple{Dates.Date}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.daily","text":"daily(d::Date)\n\nConvert a Date object to an MIT{Daily}.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.daily-Tuple{String, Vararg{Any}}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.daily","text":"daily(d::String)\n\nConvert a String object to an MIT{Daily}. The string must be convertible to a Date via the Dates.Date(d::String) method.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.fconvert-Tuple{Type{<:Frequency}, TSeries}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.fconvert","text":"fconvert(F, t)\n\nConvert the time series t to the desired frequency F.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.fconvert-Tuple{Type{Quarterly}, TSeries{var\"#s89\", T} where {var\"#s89\"<:Union{Monthly, Quarterly{3}, Yearly{12}}, T<:Number}}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.fconvert","text":"fconvert(F1, x::TSeries{F2}; method) where {F1 <: YPFrequency, F2 <: YPFrequency}\n\nConvert between frequencies derived from YPFrequency.\n\nCurrently this works only when the periods per year of the higher frequency is an exact multiple of the periods per year of the lower frequency.\n\nConverting to Higher Frequency\n\nThe only method available is method=:const, where the value at each period of the higher frequency is the value of the period of the lower frequency it belongs to.\n\nx = TSeries(2000Q1:2000Q3, collect(Float64, 1:3))\nfconvert(Monthly, x)\n\nConverting to Lower Frequency\n\nThe range of the result includes periods that are fully included in the range of the input. For each period of the lower frequency we aggregate all periods of the higher frequency within it. We have 4 methods currently available: :mean, :sum, :begin, and :end.  The default is :mean.\n\nx = TSeries(2000M1:2000M7, collect(Float64, 1:7))\nfconvert(Quarterly, x; method = :sum)\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.firstdate-Tuple{TSeries}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.firstdate","text":"firstdate(x)\n\nReturn the first date of the range of allocated storage for the given TSeries or MVTSeries instance.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.frequencyof","page":"TimeSeriesEcon","title":"TimeSeriesEcon.frequencyof","text":"frequencyof(x)\nfrequencyof(T)\n\nReturn the Frequency type of the given value x or type T.\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.get_holidays_options","page":"TimeSeriesEcon","title":"TimeSeriesEcon.get_holidays_options","text":"get_holidays_options(country::Union{String,Nothing}=nothing)\n\nReturns a dictionary of country codes for supported countries and their subdivisions (where applicable)\n\nHoliday calendars are produced using the python-holidays libary. See their site for more.\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.getoption-Tuple{Symbol}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.getoption","text":"getoption(option::Symbol)\n\nReturns the current value of the provided option.\n\nSee also setoption\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.istypenan-Tuple{Any}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.istypenan","text":"istypenan(x)\n\nReturn true if the given x is a not-n-number of its type, otherwise return false.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.lag","page":"TimeSeriesEcon","title":"TimeSeriesEcon.lag","text":"lag(x::TSeries, k=1)\n\nShift the dates of x by k period to produce the k-th lag of x. This is the same shift(x, -k).\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.lag!","page":"TimeSeriesEcon","title":"TimeSeriesEcon.lag!","text":"lag!(x::TSeries, k=1)\n\nIn-place version of lag\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.lastdate-Tuple{TSeries}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.lastdate","text":"lastdate(x)\n\nReturn the last date of the range of allocated storage for the given TSeries or MVTSeries instance.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.lead","page":"TimeSeriesEcon","title":"TimeSeriesEcon.lead","text":"lead(x::TSeries, k=1)\n\nShift the dates of x by k period to produce the k-th lead of x. This is the same shift(x, k).\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.lead!","page":"TimeSeriesEcon","title":"TimeSeriesEcon.lead!","text":"lead!(x::TSeries, k=1)\n\nIn-place version of lead\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.mit2yp","page":"TimeSeriesEcon","title":"TimeSeriesEcon.mit2yp","text":"mit2yp(x::MIT)\n\nRecover the year and period from the given MIT value. This is valid only for frequencies subtyped from YPFrequency.\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.mm-Tuple{Integer, Integer}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.mm","text":"mm(year, period)\n\nConstruct an MIT{Monthly} from an year and a period.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.moving","page":"TimeSeriesEcon","title":"TimeSeriesEcon.moving","text":"moving(x, n)\n\nCompute the moving average of x over a window of n periods. If n > 0 the window is backward-looking (-n+1:0) and if n < 0 the window is forward-looking (0:-n-1).\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.overlay","page":"TimeSeriesEcon","title":"TimeSeriesEcon.overlay","text":"overlay(arg1, args...)\n\nReturn the first argument, from left to right, that is valid. At least one argument must be given. Validity is determined by calling istypenan. If it returns true, the observation is not valid; false means it is.\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.overlay-Tuple{Vararg{MVTSeries}}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.overlay","text":"overlay(data::MVTSeries, datan::MVTSeries...)\n\nWhen all arguments are MVTSeries the result is an MVTSeries of the overlayed range and the ordered union of the columns. Each column is an overlay of the corresponding TSeries.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.overlay-Tuple{Vararg{TSeries}}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.overlay","text":"overlay([rng,] t1, t2, ...)\n\nConstruct a TSeries in which each observation is taken from the first valid observation in the list of arguments. A valid observation is one for which istypenan returns false.\n\nAll TSeries in the arguments list must be of the same frequency. The data type of the resulting TSeries is decided by the standard promotion of numerical types in Julia. Its range is the union of the ranges of the arguments, unless the optional rng is ginven in which case it becomes the range.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.overlay-Tuple{Vararg{Union{Workspace, AbstractDict{Symbol}, MVTSeries}}}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.overlay","text":"overlay(data1, data2, ...)\n\nWhen overlaying Workspaces and MVTSeries the result is a Workspace and each member is overlaid recursively.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.pct","page":"TimeSeriesEcon","title":"TimeSeriesEcon.pct","text":"pct(x; islog=false)\n\nObservation-to-observation percent rate of change in x.\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.period-Tuple{MIT}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.period","text":"period(mit)\n\nReturn the period of an MIT. This is valid only for frequencies subtyped from YPFrequency.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.ppy","page":"TimeSeriesEcon","title":"TimeSeriesEcon.ppy","text":"ppy(x)\nppy(T)\n\nReturn the periods per year for the frequency associated with the given value x or type T.\n\nIt returns approximations for CalendarFrequencies. Used in part for comparing frequencies.\n\nYPFrequency.\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.qq-Tuple{Integer, Integer}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.qq","text":"qq(year, period)\n\nConstruct an MIT{Quarterly} from an year and a period.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.rangeof","page":"TimeSeriesEcon","title":"TimeSeriesEcon.rangeof","text":"rangeof(s)\n\nReturn the stored range of the given TSeries or MVTSeries instance.\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.rangeof-Tuple{Union{Workspace, MVTSeries, TSeries}}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.rangeof","text":"rangeof(s; drop::Integer)\n\nReturn the stored range of s adjusted by dropping drop periods. If drop is positive, we drop from the beginning and if drop is negative we drop from the end. This adds convenience when using @rec\n\nExample\n\njulia> q = TSeries(20Q1:21Q4);\njulia> rangeof(q; drop=1)\n20Q2:21Q4\n\njulia> rangeof(q; drop=-4)\n20Q1:20Q4\n\njulia> q[begin:begin+1] .= 1;\njulia> @rec rangeof(q; drop=2) q[t] = q[t-1] + q[t-2];\njulia> q\n8-element TSeries{Quarterly{3}} with range 20Q1:21Q4:\n    20Q1 : 1.0\n    20Q2 : 1.0\n    20Q3 : 2.0\n    20Q4 : 3.0\n    21Q1 : 5.0\n    21Q2 : 8.0\n    21Q3 : 13.0\n    21Q4 : 21.0\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.rangeof-Tuple{Workspace}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.rangeof","text":"rangeof(w)\n\nCalculate the range of a Workspace as the intersection of the ranges of all TSeries, MVTSeries and Workspace members of w. If there are objects of different frequencies there will be a mixed-frequency error.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.rawdata-Tuple{TSeries}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.rawdata","text":"rawdata(t)\n\nReturn the raw storage of t. For a TSeries this is a Vector. For an MVTSeries this is a Matrix.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.reindex","page":"TimeSeriesEcon","title":"TimeSeriesEcon.reindex","text":"reindex(ts, from => to; copy = false)\nreindex(w, from => to; copy = false)\nreindex(rng, from => to)\n\nThe function reindex re-indexes the TSeries or MVTSeries ts,  or those contained in the Workspace w,  or the UnitRange rng,  so that the MIT from becomes the MIT to leaving the data unchanged. For a Workspace, only objects  with the same frequency as the first element of the pair will be reindexed; also, nested Workspaces are reindexed recursively.\n\nBy default, the data is not copied.\n\nExample: With a TSeries or an MVTSeries \n\nts = MVTSeries(2020Q1,(:y1,:y2),randn(10,2))\nts2 = reindex(ts,2021Q1 => 1U; copy = true)\nts2.y2[3U] = 9999\nts\nts2\n\nWith a Workspace\n\nw = Workspace();\nw.a = TSeries(2020Q1,randn(10))\nw.b = TSeries(2021Q1,randn(10))\nw.c = 1\nw.d = \"string\"\nw1 = reindex(w, 2021Q1 => 1U)\nw2 = reindex(w, 2021Q1 => 1U; copy = true)\nw.a[2020Q1] = 9999\nMVTSeries(; w1_a = w1.a, w2_a = w2.a)\n\nreindex(2022Q4, 2022Q1 => 1U) === 4U\n\nWith a UnitRange\n\nreindex(2021Q1:2022Q4, 2022Q1 => 1U)\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.replace_nans_if_warranted!-Tuple{TSeries, Integer}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.replace_nans_if_warranted!","text":"replace_nans_if_warranted!(ts::TSeries, k::Integer)\n\nAn internal function used to replace NaNs in a BDaily TSeries with their next or previous valid value. When skipholidays is true or a holidaysmap is passed the process only replaces NaNs when the source of the NaN is on a holiday.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.sanitize_frequency-Tuple{Type{<:Frequency}}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.sanitize_frequency","text":"sanitize_frequency(F::Frequency)\n\nReturn a concrete frequency type corresponding to the given, possibly abstract, frequency type. If F is already a concrete type, return F itself. Otherwise, if a default concrete frequency exists for the given abstract type, return that.\n\nFor example, the default Quarterly frequency is Quarterly{3}.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.set_holidays_map","page":"TimeSeriesEcon","title":"TimeSeriesEcon.set_holidays_map","text":"set_holidays_map(country::String, subdivision::Union{String,Nothing}=nothing)\n\nSets the current holidays map to the given country and subdivision. Holiday maps span from 1970-01-01 to 2049-12-31.\n\nSee also: get_holidays_options, clear_holidays_map\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.setoption-Tuple{Symbol, Any}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.setoption","text":"setoption(option::Symbol, value)\n\nSets the provided option to the provided values.\n\nCurrent available options are:\n\n:bdaily_holidays_map: This option holds a tseries of boolean values spanning from 1970-01-01 to 2049-12-31. Values on dates   with a false entry will not be returned when calling the values function on a BDaily TSeries    with the holidays=true option.\n:bdaily_skip_nans: This option controls the treatment of NaN values in BDaily arrays when performing   shift, lag,diff, and pct functions on them. When true, NaNs are replaced with the most relevant non-NaN value when available.\n:bdaily_skip_holidays: When true, the values function will always be called with holidays=true for BDaily series.    This also controls the behavior of the shift, lag, diff, and pct functions, but only NaNs falling on holidays are replaced.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.shift!-Tuple{TSeries, Int64}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.shift!","text":"shift!(x::TSeries, n)\nshift!(x::TSeries{BusinessDailies}, n, holidays_map=nothing)\n\nIn-place version of shift.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.shift-Tuple{TSeries, Int64}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.shift","text":"shift(x::TSeries, n)\n\nShift the dates of x by n periods. By convention positive n gives the lead and negative n gives the lag. shift creates a new TSeries and copies the data over. See shift! for in-place version.\n\nFor example:\n\njulia> shift(TSeries(2020Q1, 1:4), 1)\nTSeries{Quarterly{3}} of length 4\n2019Q4: 1.0\n2020Q1: 2.0\n2020Q2: 3.0\n2020Q3: 4.0\n\n\njulia> shift(TSeries(2020Q1, 1:4), -1)\nTSeries{Quarterly{3}} of length 4\n2020Q2: 1.0\n2020Q3: 2.0\n2020Q4: 3.0\n2021Q1: 4.0\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.shift-Tuple{TSeries{BDaily, T} where T<:Number, Int64}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.shift","text":"shift(x::TSeries{BDaily}, n, skip_all_nans::Bool=false, skip_holidays::Bool=false, holidays_map::Union{Nothing, TSeries{BDaily}}=nothing)\n\nAs shift but with behavor depending on the TimeSeriesEcon options :bdaily_skip_nans, :bdaily_skip_holidays and the optional holidays_map argument.\n\nWhen skip_all_nans is  true, any NaN values replaced with the nearest valid value.  Replacements will come from later time periods when k >= 0 and from earlier time periods when k < 0.\n\nWhen skip_all_nans is false but skip_holidays is true or a  holidays_map is passed to the function, then NaN originating from Holidays will be replaced with the nearest valid value. Replacements will come from later time periods when k >= 0 and from earlier time periods when k < 0.\n\nOptions:\n\nskipallnans : A Boolean. Default is false.\nskip_holidays : A Boolean. Default is false.\nholidays_map : A Boolean-values BDaily TSeries with true values on days which are not holidays. Default is nothing.\n\nExample:\n\njulia> shift(TSeries(bdaily(\"2022-07-04\"), [1,2,NaN,4]), 1, skip_all_nans=true)\n4-element TSeries{TimeSeriesEcon.BDaily} with range 2022-07-01:2022-07-06:\n2022-07-01 : 1.0\n2022-07-04 : 2.0\n2022-07-05 : 4.0\n2022-07-06 : 4.0\n\n\njulia> shift(TSeries(bdaily(\"2022-07-04\"), [1,2,NaN,4]), -1, skip_all_nans=true)\n4-element TSeries{TimeSeriesEcon.BDaily} with range 2022-07-05:2022-07-08:\n2022-07-05 : 1.0\n2022-07-06 : 2.0\n2022-07-07 : 2.0\n2022-07-08 : 4.0\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.strip!-Tuple{TSeries}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.strip!","text":"strip!(t::TSeries)\n\nRemove leading and training NaN from the given time series. This is done in-place.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.strip!-Tuple{Workspace}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.strip!","text":"strip!(w::Workspace; recursive=true)\n\nApply strip! to all TSeries members of the given workspace. This includes nested workspaces, unless recursive=false.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.typenan","page":"TimeSeriesEcon","title":"TimeSeriesEcon.typenan","text":"typenan(x)\ntypenan(T)\n\nReturn a value that indicates not-a-number of the same type as the given x or of the given type T.\n\nFor floating point types, this is NaN. For integer types, we use typemax(). This is not ideal, but it'll do for now.\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.undiff","page":"TimeSeriesEcon","title":"TimeSeriesEcon.undiff","text":"If second argument is anchor_value::Number, assume the anchor date is firstdate(dvar)-1\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.undiff-2","page":"TimeSeriesEcon","title":"TimeSeriesEcon.undiff","text":"If second argument is anchor_value::Number, assume the anchor date is firstdate(dvar)-1\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.undiff-3","page":"TimeSeriesEcon","title":"TimeSeriesEcon.undiff","text":"undiff(dvar, [date => value])\nundiff!(var, dvar; fromdate=firstdate(dvar)-1)\n\nInverse of diff, i.e. var remains unchanged under undiff!(var, diff(var)) or undiff(diff(var), firstdate(var)=>first(var)). This is the same as cumsum, but specific to time series.\n\nIn the case of undiff the second argument is an \"anchor\" Pair specifying a known value at some time period. Typically this will be the period just before the first date of dvar, but doesn't have to be. If the date falls outside the rangeof(dvar) we extend dvar with zeros as necessary. If missing, this argument defaults to firstdate(dvar)-1 => 0.\n\nIn the case of undiff!, the var argument provides the \"anchor\" value and the storage location for the result. The fromdate parameter specifies the date of the \"anchor\" and the anchor value is taken from var. See important note below.\n\nThe in-place version (undiff!) works only with TSeries. The other version (undiff) works with MVTSeries as well as TSeries. In the case of MVTSeries the anchor value must be a Vector, or a Martix with 1 row, of the same length as the number of columns of dvar.\n\nnote: Note\nIn the case of undiff! the meaning of parameter fromdate is different from the meaning of date in the second argument of undiff. This only matters if fromdate falls somewhere in the middle of the range of dvar.In the case of undiff!, all values of dvar at, and prior to, fromdate are ignored (considered zero). Effectively, values of var up to, and including, fromdate remain unchanged. By contrast, in undiff with date => value somewhere in the middle of the range of dvar, the operation is applied over the full range of dvar, both before and after date, and then the result is adjusted by adding or subtracting a constant such that in the end we have result[date]=value.\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.undiff!","page":"TimeSeriesEcon","title":"TimeSeriesEcon.undiff!","text":"undiff(dvar, [date => value])\nundiff!(var, dvar; fromdate=firstdate(dvar)-1)\n\nInverse of diff, i.e. var remains unchanged under undiff!(var, diff(var)) or undiff(diff(var), firstdate(var)=>first(var)). This is the same as cumsum, but specific to time series.\n\nIn the case of undiff the second argument is an \"anchor\" Pair specifying a known value at some time period. Typically this will be the period just before the first date of dvar, but doesn't have to be. If the date falls outside the rangeof(dvar) we extend dvar with zeros as necessary. If missing, this argument defaults to firstdate(dvar)-1 => 0.\n\nIn the case of undiff!, the var argument provides the \"anchor\" value and the storage location for the result. The fromdate parameter specifies the date of the \"anchor\" and the anchor value is taken from var. See important note below.\n\nThe in-place version (undiff!) works only with TSeries. The other version (undiff) works with MVTSeries as well as TSeries. In the case of MVTSeries the anchor value must be a Vector, or a Martix with 1 row, of the same length as the number of columns of dvar.\n\nnote: Note\nIn the case of undiff! the meaning of parameter fromdate is different from the meaning of date in the second argument of undiff. This only matters if fromdate falls somewhere in the middle of the range of dvar.In the case of undiff!, all values of dvar at, and prior to, fromdate are ignored (considered zero). Effectively, values of var up to, and including, fromdate remain unchanged. By contrast, in undiff with date => value somewhere in the middle of the range of dvar, the operation is applied over the full range of dvar, both before and after date, and then the result is adjusted by adding or subtracting a constant such that in the end we have result[date]=value.\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.undiff-Tuple{MVTSeries, AbstractVecOrMat}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.undiff","text":"If second argument is anchor_value::Vector, assume the anchor date is firstdate(dvar)-1\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.undiff-Tuple{TSeries, Pair{<:MIT, <:TSeries}}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.undiff","text":"If second argument is a pair ad::MIT => av::TSeries, take the anchor value to be av[ad]\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.undiff-Tuple{TSeries, TSeries}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.undiff","text":"If second argument is anchor::TSeries, assume anchor date is firstdate(dvar)-1 and take value form anchor\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.weekly-Tuple{Dates.Date}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.weekly","text":"weekly(d::Date) \nweekly(d::String)\nweekly(d::Date, end_day::Integer)\nweekly(d::String, end_day::Integer)\n\nThese functions return an MIT{Weekly} from a provided Date object or String. The String must be convertible to a Date object via the Dates.Date(d::String) method.\n\nReturns an object of type MIT{Weekly{endday}} when the endday argument is provided.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.year-Tuple{MIT}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.year","text":"year(mit)\n\nReturn the year of an MIT. This is valid only for frequencies subtyped from YPFrequency.\n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.ytypct-Tuple{Any}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.ytypct","text":"ytypct(x)\n\nYear-to-year percent change in x. \n\n\n\n\n\n","category":"method"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.yy","page":"TimeSeriesEcon","title":"TimeSeriesEcon.yy","text":"yy(year, period)\n\nConstruct an MIT{Yearly} from an year and a period.\n\n\n\n\n\n","category":"function"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.@bd_str-Tuple{Any, Any}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.@bd_str","text":"bd_str(d, bias)\n\nA macro which converts a string to an MIT{BDaily} or a UnitRange{MIT{BDaily}}.\n\nThe optional biasdetermines which business day is returned when the provided  date is on a Saturday or Sunday. Available options are\"n\"or\"next\"for  biasing the next business day, and \"p\", or \"previous\" for the next business day,\"near\"or\"nearest\"for biasing the nearest business day, and\"s\"or\"strict\"` in which case passing a day on a weekend will return an error.\n\nTo return a UnitRange, provide a single string with two dates separated by :.  In this case the first date will be biased to the following business day and the second date will be biased to the previous business day. The bias argument cannot  be provided when converting a range of dates.\n\nExample:     aprilfirst = bd\"2022-04-01\"     secondweekofapril = bd\"2022-04-04:2022-04-08\"\n\n\n\n\n\n","category":"macro"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.@compare","page":"TimeSeriesEcon","title":"TimeSeriesEcon.@compare","text":"@compare x y [options]  compare(x, y [; options])\n\nCompare two Workspace recursively and print out the differences. MVTSeries and Dict with keys of type Symbol are treated like Workspace. TSeries and other Vector are compared using isapprox, so feel free to supply rtol or atol.\n\nOptional argument name can be used for the top name. Default is \"_\".\n\nParameter showequal=true causes the report to include objects that are the same. Default behaviour, with showequal=false, is to report only the differences. \n\nParameter ignoremissing=true causes objects that appear in one but not the other workspace to be ignored. That is, they are not printed and do not affect the return value true or false. Default is ignoremissing=false meaning they will be printed and return value will be false.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.@d_str-Tuple{Any}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.@d_str","text":"d_str(d)\n\nA macro which converts a string to an MIT{Daily} or a UnitRange{MIT{Daily}}.\n\nTo return a UnitRange, provide a single string with two dates separated by :.\n\nExample:     christmas = d\"2022-12-25\"     daysoffebruary = d\"2022-02-01:2022-02-28\"\n\n\n\n\n\n","category":"macro"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.@rec-Tuple{Any, Any}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.@rec","text":"@rec [index=]range expression\n\nCompute recursive operations on time series. The first argument is the range and the second argument is an expression to be evaluated over that range.\n\nThe expression is meant to be an assignment, but it doesn't have to be. \n\nThe range specification can include an optional indexing variable name. If not given, the variable name defaults to t.\n\nExamples\n\njulia> s = TSeries(1U)\nEmpty TSeries{Unit} starting 5U\n\njulia> s[1U] = s[2U] = 1; s\n2-element TSeries{Unit} with range 1U:2U:\n      1U : 1.0\n      2U : 1.0\n\njulia> @rec t=3U:10U s[t] = s[t-1] + s[t-2]\n\njulia> s\n10-element TSeries{Unit} with range 1U:10U:\n      1U : 1.0\n      2U : 1.0\n      3U : 2.0\n      4U : 3.0\n      5U : 5.0\n      6U : 8.0\n      7U : 13.0\n      8U : 21.0\n      9U : 34.0\n     10U : 55.0\n\n\n\n\n\n","category":"macro"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.@showall-Tuple{Any}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.@showall","text":"@showall X\n\nPrint all data in X without truncating the output to fit the size of the   screen.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.@w_str-Tuple{Any}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.@w_str","text":"w_str(d)\n\nA macro which converts a string to an MIT{Weekly{7}} or a UnitRange{MIT{Weekly{7}}}.\n\nTo return a UnitRange, provide a single string with two dates separated by :.\n\nThe resulting week(s) will be the week(s) containing the provided date(s).\n\nExample:     weekofchristmas = w\"2022-12-25\"     weekoverlappingwith_february = w\"2022-02-01:2022-02-28\"\n\n\n\n\n\n","category":"macro"},{"location":"Reference/TimeSeriesEcon/#TimeSeriesEcon.@weval-Tuple{Any, Any}","page":"TimeSeriesEcon","title":"TimeSeriesEcon.@weval","text":"@weval W expression\n\nEvaluate an expression using the members of Workspace W as if they were variables.\n\n\n\n\n\n","category":"macro"},{"location":"DesignPapers/equation_changes/#Equation-Changing-Syntax","page":"Equation Changing Syntax","title":"Equation Changing Syntax","text":"","category":"section"},{"location":"DesignPapers/equation_changes/","page":"Equation Changing Syntax","title":"Equation Changing Syntax","text":"This document covers the syntax for making modifications to an existing model held in memory.","category":"page"},{"location":"DesignPapers/equation_changes/#A-simple-example","page":"Equation Changing Syntax","title":"A simple example","text":"","category":"section"},{"location":"DesignPapers/equation_changes/","page":"Equation Changing Syntax","title":"Equation Changing Syntax","text":"Given an existing model, m1, the following example creates a copy of the model with the addition/modification of the equation labeled :technology.","category":"page"},{"location":"DesignPapers/equation_changes/","page":"Equation Changing Syntax","title":"Equation Changing Syntax","text":"m2 = deepcopy(m1)\n@equations m2 begin\n    :technology => log(A[t]) = λ * log(A[t-1]) + ea[t] + ea[t+1]\nend\n@reinitialize(m2)\nsssolve!(m2; method=:auto)\ncheck_sstate(m2)","category":"page"},{"location":"DesignPapers/equation_changes/","page":"Equation Changing Syntax","title":"Equation Changing Syntax","text":"The above example follows these four steps.","category":"page"},{"location":"DesignPapers/equation_changes/","page":"Equation Changing Syntax","title":"Equation Changing Syntax","text":"Make a copy of the model using deepcopy.\nMake changes to the model as required. This can be done in a series of @variables, @logvariables, @neglogvariables, @steadystatevariables, @exogenous, @shocks, @autoexogenize, @steadystate, and @equations blocks.\nNote that new @steadystate criteria must be added after the call to @reinitialize.\nReinitialize the model with @reinitialize. Changes to an initialized model must always be completed with a call to @reinitialize.\nSolve the steadystate of the model with sssolve!.","category":"page"},{"location":"DesignPapers/equation_changes/#Removing-model-properties","page":"Equation Changing Syntax","title":"Removing model properties","text":"","category":"section"},{"location":"DesignPapers/equation_changes/","page":"Equation Changing Syntax","title":"Equation Changing Syntax","text":"@delete can be used inside any of the model construction macros to remove an existing variable/equation/etc. When removing equations and steadystate equations, the equation key must be used (without the :). When removing autoexogenize pairs, the entire pair must be defined with an implication arrow (=>).","category":"page"},{"location":"DesignPapers/equation_changes/","page":"Equation Changing Syntax","title":"Equation Changing Syntax","text":"Example:","category":"page"},{"location":"DesignPapers/equation_changes/","page":"Equation Changing Syntax","title":"Equation Changing Syntax","text":"@equations m begin\n    @delete _EQ188 _EQ189\nend\n@variables m @delete c\n@shocks m begin\n    @delete c_shk\nend\n@autoexogenize m begin\n    @delete A => ea\nend","category":"page"},{"location":"DesignPapers/equation_changes/","page":"Equation Changing Syntax","title":"Equation Changing Syntax","text":"The @delete macro works at the level of the line within a block. This means that new variables can be defined in the same @variables block as the one which removes variables. ","category":"page"},{"location":"DesignPapers/equation_changes/","page":"Equation Changing Syntax","title":"Equation Changing Syntax","text":"Example:","category":"page"},{"location":"DesignPapers/equation_changes/","page":"Equation Changing Syntax","title":"Equation Changing Syntax","text":"@variables model begin\n    @delete c\n    d; e; f\nend","category":"page"},{"location":"DesignPapers/equation_changes/#Defining-equations-with-keys","page":"Equation Changing Syntax","title":"Defining equations with keys","text":"","category":"section"},{"location":"DesignPapers/equation_changes/","page":"Equation Changing Syntax","title":"Equation Changing Syntax","text":"The arrow implication, => is used within the equations block to define a named key for the given equation. The key is optional. For example, the block below contains both named and unnamed equations. ","category":"page"},{"location":"DesignPapers/equation_changes/","page":"Equation Changing Syntax","title":"Equation Changing Syntax","text":"@equations model begin\n    @log 1/(C[t]) = β * (1 / (C[t+1]*(1+g))) * (r[t+1]+1-δ)\n    @log (L[t])^γ = w[t] / C[t]\n    :rates => @log r[t] = α * A[t] * (K[t-1]/(1+g)) ^ (α-1) * (L[t]) ^ (1-α)\n    :wages => @log w[t] = (1-α) * A[t] * (K[t-1]/(1+g)) ^ α * (L[t]) ^ (-α)\n    K[t] + C[t] = A[t] * (K[t-1]/(1+g)) ^ α * (L[t]) ^ (1-α) + (1-δ) * (K[t-1]/(1+g))\n    :technology => log(A[t]) = λ * log(A[t-1]) + ea[t]\n    dlA[t] = log(A[t]) - log(A[t-1])\nend # equations","category":"page"},{"location":"DesignPapers/equation_changes/","page":"Equation Changing Syntax","title":"Equation Changing Syntax","text":"Equations without an explicit key will receive one following an __EQ# template. For example, printing the equations from the above block would result in this output:","category":"page"},{"location":"DesignPapers/equation_changes/","page":"Equation Changing Syntax","title":"Equation Changing Syntax","text":"  :_EQ1       => @log 1 / C[t] = β * ((1 / (C[t + 1] * (1 + g))) * ((r[t + 1] + 1) - δ))\n  :_EQ2       => @log L[t] ^ γ = w[t] / C[t]\n  :rates      => @log r[t] = α * (A[t] * ((K[t - 1] / (1 + g)) ^ (α - 1) * L[t] ^ (1 - α)))\n  :wages      => @log w[t] = (1 - α) * (A[t] * ((K[t - 1] / (1 + g)) ^ α * L[t] ^ -α))\n  :_EQ5       => K[t] + C[t] = A[t] * ((K[t - 1] / (1 + g)) ^ α * L[t] ^ (1 - α)) + (1 - δ) * (K[t - 1] / (1 + g))\n  :technology => log(A[t]) = λ * log(A[t - 1]) + ea[t]\n  :_EQ7       => dlA[t] = log(A[t]) - log(A[t - 1])","category":"page"},{"location":"DesignPapers/equation_changes/","page":"Equation Changing Syntax","title":"Equation Changing Syntax","text":"When running an @equations macro on and exitsting model, all unnamed equations are added to the model. Named equations will replace existing equations with the same name, if any, and will be added otherwise.","category":"page"},{"location":"DesignPapers/equation_changes/#Finding-equation-keys","page":"Equation Changing Syntax","title":"Finding equation keys","text":"","category":"section"},{"location":"DesignPapers/equation_changes/","page":"Equation Changing Syntax","title":"Equation Changing Syntax","text":"Equation keys are automatically assigned to equations without an explicit key. The findequations(model, symbol) function can be used to find the keys for the equations in the model which contain the given symbol.","category":"page"},{"location":"DesignPapers/equation_changes/","page":"Equation Changing Syntax","title":"Equation Changing Syntax","text":"(Image: findequations function).","category":"page"},{"location":"Tutorials/2.simple_RBC/main/#Simple-RBC-Model","page":"Simple RBC Model","title":"Simple RBC Model","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"You can follow the tutorial by reading this page and copying and pasting code into your Julia REPL session. In this case, you will need the model file, simple_RBC.jl.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Pages = [\"main.md\"]\nDepth = 3","category":"page"},{"location":"Tutorials/2.simple_RBC/main/#Part-1:-The-model","page":"Simple RBC Model","title":"Part 1: The model","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/#The-simple-RBC-model","page":"Simple RBC Model","title":"The simple RBC model","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"In this tutorial, we will use the simple RBC model presented by Villemot (2013).","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"In period t=1ldotsinfty, a representative household consumes C_t; it also provides labour L_t and rents capital K_t-1 to the firm. K_t is the capital stock at the end of period t, and is available to be rented out during t+1.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Consumption, labour and capital are chosen in order to maximize the sum of discounted expected utility","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"displaystylesum_t=1^inftybeta^t-1E_tleftlog(C_t)-fracL_t^1+gamma1+gammaright","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"under the sequence of budget constraints","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"displaystyle K_t=K_t-1(1-delta)+w_tL_t+r_tK_t-1-C_t","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"where","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"beta=frac11+rho is the discount rate and rho in (0infty) is the rate of time preference,\ngamma in (0infty) is the labour supply parameter,\ndelta in (01) is the rate of depreciation of capital,\nw_t is the real wage, and\nr_t is the real rental rate.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"In period t, the firm uses labour L_t and capital K_t-1 to produce Y_t according to the production function","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"displaystyle Y_t=A_tK_t-1^alpha((1+g)^tL_t)^1-alpha","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"where","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"g in (0infty) is the growth rate, and \nalpha is the output elasticity of labour.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The firm chooses labour and capital in order to maximize profits","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"displaystyle max_L_tK_t-1 A_t K_t-1^alpha ((1+g)^t L_t)^1-alpha - r_t K_t-1 - w_t L_t","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"A_t is a technological shock that follows the AR(1) process","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"displaystyle log(A_t)=lambdalog(A_t-1)+e_t","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"where","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"e_t is an i.i.d. zero-mean normally distributed error term with standard deviation gamma, and\nlambda in (01) is a parameter governing the persistence of the shock.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/#The-household-problem","page":"Simple RBC Model","title":"The household problem","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The Lagrangian of the constrained maximization is","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"displaystyle mathcalL(C_tL_tK_t) = sum_t=1^inftybeta^t-1E_tleftlog(C_t)-fracL_t^1+gamma1+gamma-mu_t(K_t-K_t-1(1-delta)-w_tL_t-r_tK_t-1+C_t)right","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The first order conditions are","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"beginaligned\n    fracpartialmathcalLpartial C_t = beta^t-1 left(frac1C_t - mu_t right) = 0 \n    fracpartialmathcalLpartial L_t = beta^t-1 left(L_t^gamma - mu_t w_t right) = 0 \n    fracpartialmathcalLpartial K_t = -beta^t-1 mu_t + beta^t E_t\n        left(mu_t+1(1-delta+r_t+1) right) = 0\nendaligned","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Once we eliminate the Lagrange multiplier mu_t, we get","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"beginaligned\n    L_t^gamma = fracw_tC_t \n    frac1C_t = beta E_t left(frac1C_t+1(r_t+1+1-delta) right)\nendaligned","category":"page"},{"location":"Tutorials/2.simple_RBC/main/#The-firm-problem","page":"Simple RBC Model","title":"The firm problem","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The first order conditions are","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"beginaligned\n    r_t = alpha A_t K_t-1^alpha-1((1+g)^t L_t)^1-alpha \n    w_t = (1-alpha)A_t K_t-1^alpha ((1+g)^t)^1-alpha L_t^-alpha\nendaligned","category":"page"},{"location":"Tutorials/2.simple_RBC/main/#The-goods-market-equilibrium","page":"Simple RBC Model","title":"The goods market equilibrium","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Aggregate demand must equal aggregate supply to clear the goods market.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"displaystyle K_t + C_t = K_t-1(1-delta)+A_t K_t-1^alpha ((1+g)^t L_t)^1-alpha","category":"page"},{"location":"Tutorials/2.simple_RBC/main/#The-dynamic-equilibrium","page":"Simple RBC Model","title":"The dynamic equilibrium","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The dynamic equations are obtained by combining the first order conditions of the household and firm problems  with the goods market equilibrium.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Based on the goods market equilibrium, consumption and capital must be growing at the same rate: g_c=g_k=g.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Thus, we can define stationary variables as","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"beginaligned\n    hatC_t = fracC_t(1+g)^t \n    hatK_t = fracK_t(1+g)^t \n    hatw_t = fracw_t(1+g)^t\nendaligned","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Once stationarized (see Villemot (2013)), the dynamic equations can be written as:","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"beginaligned\n    frac1hatC_t = frac11+rho E_t left(frac1hatC_t+1(1+g)(r_t+1+1-delta) right) \n    L_t^gamma = frachatw_thatC_t \n    r_t = alpha A_t left( frachatK_t-11+g right)^alpha-1 L_t^1-alpha \n    hatw_t = (1-alpha) A_t left( frachatK_t-11+g right)^alpha L_t^-alpha \n    hatK_t + hatC_t = frachatK_t-11+g (1-delta) + A_t left( frachatK_t-11+g right)^alpha L_t^1-alpha\nendaligned","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The next part will discuss how to implement the simple RBC model in StateSpaceEcon.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/#Part-2:-Implementation-of-the-model-in-StateSpaceEcon","page":"Simple RBC Model","title":"Part 2: Implementation of the model in StateSpaceEcon","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/#Installing-the-packages","page":"Simple RBC Model","title":"Installing the packages","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We start by installing the packages needed for this tutorial.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"using StateSpaceEcon, ModelBaseEcon, TimeSeriesEcon, Test, Plots, Random, Distributions\n# Fix the random seed for reproducibility.\nRandom.seed!(1234);\n","category":"page"},{"location":"Tutorials/2.simple_RBC/main/#Writing-the-model-file","page":"Simple RBC Model","title":"Writing the model file","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"In StateSpaceEcon, a model is written in its own dedicated module, which is contained in its own file, simple_RBC.jl.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"A docstring can be added to the model to provide more details:","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"    \"\"\"\n    Simple RBC Model\n    Model available at: https://archives.dynare.org/DynareShanghai2013/order1.pdf\n    Presentation: Villemot, S., 2013. First order approximation of stochastic models. Shanghai Dynare Workshop.\n    \"\"\"\n    module simple_RBC\n        ...\n    end","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Then, the module is created with the same name as the model and the associated file name. The model will be constructed with macros taken from the package ModelBaseEcon. So, we need to load ModelBaseEcon within the module simple_RBC with using ModelBaseEcon. The model itself will be a global variable called model within the module simple_RBC. The command const declares global variables that will not change and the function Model() constructs a new model object.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"module simple_RBC\n    using ModelBaseEcon\n    const model = Model()\n    # Write the rest of the model below.\nend # module","category":"page"},{"location":"Tutorials/2.simple_RBC/main/#Flags-and-Options","page":"Simple RBC Model","title":"Flags and Options","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The model object has flags and options. ","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Flags are (usually boolean) values which characterize the type of model we have. For example, we can specify that the model is stationary by setting the flag ssZeroSlope to true.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"model.flags.ssZeroSlope = true","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Once we call @initialize at the end of the model file, the flags must not be changed after that.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Options are values that adjust the operations of the algorithms. They can be assigned in the  model file as well, but they can also be changed at any time after that.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We can preset model options with the function setoption!. Below, we set the desired accuracy with tol and we set maxiter for the maximum number of iterations for the iterative solvers. Auxiliary variables will not be created and substituted to help the solver (substitutions). We will opt for QR factorization, which is slower but more robust than LU factorization. Finally, we will set verbose to true to provide more information from the commands.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"setoption!(model) do o\n    o.tol = 1e-14\n    o.maxiter = 100\n    o.substitutions = false\n    o.factorization = :qr\n    o.verbose = true\nend # options","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Many functions in StateSpaceEcon have optional arguments of the same name as a model option. When the argument is not explicitly given in the function call, these functions will use the value from the model option of the same name.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/#Model-Parameters","page":"Simple RBC Model","title":"Model Parameters","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The rest of the model file deals with the economics of the model. Different elements of the model are declared with macros, which do not have to be in any particular order.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The model object holds model parameters, which are values that can be used in the model equations. The macro @parameters declares the parameters and assigns their values. A link between parameters can be created with the macro @link. Below, the parameter beta depends on the parameter rho.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"@parameters model begin\n    α = 0.33\n    δ = 0.1\n    ρ = 0.03\n    λ = 0.97\n    γ = 0\n    g = 0.015\n    β = @link 1/(1+ρ)\nend # parameters","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We must not declare new parameters after @initialize has been called. However, the values of existing parameters can be changed at any time and the new values take effect immediately (with some exceptions that we discuss below).","category":"page"},{"location":"Tutorials/2.simple_RBC/main/#Variables","page":"Simple RBC Model","title":"Variables","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Similarly, model variables are specified with the macro @variables. Variables can be declared one line at a time (as with the parameters previously), or over one line by separating them with semicolons ;. ","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"In this model all variables are strictly positive. We can take advantage of this by declaring the variables with the macro @logvariables. This indicates to the solver to work with the log of the variables. For instance, instead of working with C_t, the solver will work directly with the logarithm as a standalone variable (logC_t=log(C_t)). The substitution C_t = e^logC_t is done automatically in all equations. This is completely invisible to the user, but it can help the solver to avoid computing the logarithm of a negative value.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"@logvariables model begin\n    \"Consumption\" C\n    \"Capital Stock\" K\n    \"Labour\" L\n    \"Real Wage\" w\n    \"Real Rental Rate\" r\n    \"Technological shock\" A\nend # variables","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Similarly, the macro @shocks declares model shocks.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"@shocks model begin\n    ea\nend # shocks","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"In this case, the begin … end block is not mandatory and the technology shock can be declared in one line.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"@shocks model ea","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The macro @autoexogenize links a variable with a shock. This can be useful to back out historical shocks with the command autoexogenize! (see below for an example).","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"@autoexogenize model begin\n    A = ea\nend # autoexogenize","category":"page"},{"location":"Tutorials/2.simple_RBC/main/#Equations","page":"Simple RBC Model","title":"Equations","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The dynamic equations of the model are defined with the macro @equations. The variables have to be indexed with t. For instance, K[t-1] refers to the capital stock at the end of t-1 and C[t+1] refers to the expectation at t for consumption at t+1, or E_t(C_t+1). When variables can be separated by a logarithm, it will help the solver to put the macro @log in front of an equation. In this way, the residual will be computed as the difference between the logarithm of the left-hand side and the logarithm of the right-hand side. For instance, the solver will prefer to work with the second equation below, because it is linear. ","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"beginaligned\n    L_t^gamma = fracw_tC_t \n    gammalog(L_t) = log(w_t) - log(C_t)\nendaligned","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"@equations model begin\n    @log 1/(C[t]) = β * (1 / (C[t+1]*(1+g))) * (r[t+1]+1-δ)\n    @log (L[t])^γ = w[t] / C[t]\n    @log r[t] = α * A[t] * (K[t-1]/(1+g)) ^ (α-1) * (L[t]) ^ (1-α)\n    @log w[t] = (1-α) * A[t] * (K[t-1]/(1+g)) ^ α * (L[t]) ^ (-α)\n    K[t] + C[t] = A[t] * (K[t-1]/(1+g)) ^ α * (L[t]) ^ (1-α) + (1-δ) * (K[t-1]/(1+g))\n    log(A[t]) = λ * log(A[t-1]) + ea[t]\nend # equations","category":"page"},{"location":"Tutorials/2.simple_RBC/main/#Initialization-of-the-Model","page":"Simple RBC Model","title":"Initialization of the Model","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Once the parameters, the variables, the shocks and the equations have been specified, the macro @initialize constructs the model within the module simple_RBC.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"@initialize(model)","category":"page"},{"location":"Tutorials/2.simple_RBC/main/#Loading-the-model","page":"Simple RBC Model","title":"Loading the model","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We load the module that contains the model with using simple_RBC; the model itself is a global variable called model within that module, which we assign to m in the Main module.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"unique!(push!(LOAD_PATH, realpath(\".\")));\nusing simple_RBC\nm = simple_RBC.model","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"note: Important note\nFor the \"using simple_RBC\" command to work, we need the model file simple_RBC.jl to be on the search path for modules. We can do this by:Running the file that contains the model module with  include(\"/[path to file]/simple_RBC.jl\") (in this case we don't need  using simple_RBC);\nAdding the file path to  LOAD_PATH  global variable (which we did above);\nPutting the model in its own standalone package and adding it to the  current Julia environment with  using Pkg; Pkg.add(\"/[path to the package]/simple_RBC\").","category":"page"},{"location":"Tutorials/2.simple_RBC/main/#Examining-the-model","page":"Simple RBC Model","title":"Examining the model","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"If the model has more than 20 equations the display gets truncated. We can see the entire model with fullprint.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"fullprint(m)","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We can see the flags and the options of the model.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"m.flags\nm.options","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We can also examine individual components using the commands parameters, variables, shocks and equations.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"parameters(m)\nvariables(m)\nshocks(m)\nequations(m)","category":"page"},{"location":"Tutorials/2.simple_RBC/main/#Setting-the-model-parameters","page":"Simple RBC Model","title":"Setting the model parameters","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We must not change any part of the model in the active Julia session except for the values of the model parameters and steady state constraints if any (see the Smets and Wouters (2007) tutorial). If we want to add variables, shocks, or equations, we must do so in the model module file and restart a new Julia session to load the new model.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"When it comes to the model parameters, we can access them by their names from the model object using the dot notation.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"m.β # read a parameter value\nm.α = 0.33 # modify a parameter value","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Parameters can be linked to other parameters with the macro @link:","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"parameters(m)[:β]","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"If rho changes, beta will automatically be updated.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"m.ρ = 0.05\nm.β\nm.ρ = 0.03\nm.β","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"However, the dynamic links only work with parameter values. Otherwise, the function update_links! needs to be called to refresh all the links.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"update_links!(m)","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"note: Important note\nWhen do we need to call update_links!? Links will not be automatically updated if:Links contain a reference outside the model parameters, such as a global variable, the steady state or another model object;\nA parameter is not a number, such as if an element of a parameter vector is updated.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/#Part-3:-The-steady-state-solution","page":"Simple RBC Model","title":"Part 3: The steady state solution","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The steady state is a special solution of the dynamic system that remains constant over time. It is important on its own, but also it can be useful in several ways. For example, linearizing the model requires a particular solution about which to linearize, and the steady state is typically used for this purpose.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"In addition to the steady state, we also consider another kind of special solution which grows linearly in time. If we know that the steady state solution is constant (i.e., its slope is zero), we can set the model flag ssZeroSlope to true. This is not required; however in a large model it might help the steady state solver converge faster to the solution.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The model object m stores information about the steady state. This includes the steady state solution itself, as well as a (possibly empty) set of additional constraints that apply only to the steady state. This information can be accessed via m.sstate.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"m.sstate","category":"page"},{"location":"Tutorials/2.simple_RBC/main/#Solving-for-the-steady-state","page":"Simple RBC Model","title":"Solving for the steady state","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The steady state solution is stored within the model object. Before solving, we have to specify an initial condition. If the model is linear, this makes no difference, but in a non-linear model a good or a bad initial guess might be the difference between success and failure of the steady state solver.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We specify the initial guess by calling clear_sstate!. This call removes any previously stored solution, sets the initial guess, and runs the pre-solve pass of the steady state solver. The initial guess can be given with the lvl and slp arguments; if not provided, an initial guess is chosen automatically.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Once that's done, we call sssolve! to find the steady state. We can see below that sssolve! cannot find a steady state solution.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"clear_sstate!(m)\nsssolve!(m);","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Sometimes the Newton-Raphson solution algorithm, which is used by default because it is the fastest, fails to converge. If this happens, we can use method=:auto, which starts with the Levenberg-Marquardt algorithm and automatically switches to Newton-Raphson when it starts to converge.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"clear_sstate!(m)\nsssolve!(m; method = :auto)","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The function sssolve! returns a Vector{Float64} containing the steady state solution, and it also writes that solution into the model object. The vector is of length 2*nvariables(m) and contains the level and the slope for each variable.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"If in doubt, we can use check_sstate to make sure the steady state solution stored in the model object indeed satisfies the steady state system of equations. This function returns the number of equations that are not satisfied. A value of 0 is what we want to see. In verbose mode, it also lists the problematic equations and their residuals.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"check_sstate(m)","category":"page"},{"location":"Tutorials/2.simple_RBC/main/#Examining-the-steady-state","page":"Simple RBC Model","title":"Examining the steady state","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We can access the steady state solution via m.sstate using the dot notation.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"m.sstate.C","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We can also assign new values to the steady state solution, but we should be careful to make sure it remains a valid steady state solution.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"m.sstate.C.level = 1.0050\n@test check_sstate(m) > 0","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"As the code above shows, a wrong steady state solution (based on the specified precision in the tol option) will result in one or more equation not being satisfied. Let's put back the correct value.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"m.sstate.C.level = 1.0030433070390223\n@test check_sstate(m) == 0","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We can examine the entire steady state solution with printsstate.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"printsstate(m)","category":"page"},{"location":"Tutorials/2.simple_RBC/main/#Part-4:-Impulse-response","page":"Simple RBC Model","title":"Part 4: Impulse response","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/#Simulation-plan","page":"Simple RBC Model","title":"Simulation plan","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Before we can simulate the model, we have to decide on the length of the simulation and what data is available for each period, i.e., what values are known (exogenous). This is done with an object of type Plan.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"To create a plan, all we need is the model object and a range for the simulation.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"sim_rng = 2000Q1:2039Q4\np = Plan(m, sim_rng)","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The plan shows us the list of exogenous values (variables or shocks) for each period or sub-range of the simulation. By default, all shocks are exogenous and all variables are endogenous.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We also see that the range of the plan has been extended before and after the simulation range. This is necessary because we need to set initial and final conditions. The number of periods for initial conditions is equal to the largest lag in the model. Similarly, final conditions have to be imposed over as many periods as the largest lead.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"p.range          # the full range of the plan\ninit_rng = first(p.range):first(sim_rng)-1   # the range for initial conditions\nfinal_rng = last(sim_rng)+1:last(p.range)     # the range for final conditions\n@test length(init_rng) == m.maxlag\n@test length(final_rng) == m.maxlead","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The function exportplan can be used to save a plan to a TXT or CSV file which can be opened to visualize the plan. Alternatively, the function importplan can load the plan back into Julia from the TXT or CSV file.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/#Exogenous-data","page":"Simple RBC Model","title":"Exogenous data","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We have to provide the data for the simulation. We start with all zeros and fill in the external data, which must include initial conditions for all variable and shocks, exogenous values (according to the plan), and possibly final conditions.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/#Initial-conditions","page":"Simple RBC Model","title":"Initial conditions","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"In this example, we want to simulate an impulse response, so it makes sense to start from the steady state.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"exog = steadystatedata(m, p)","category":"page"},{"location":"Tutorials/2.simple_RBC/main/#Final-conditions","page":"Simple RBC Model","title":"Final conditions","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"For the final conditions, we can use the steady state again, because we expect that the economy will eventually return to it if the simulation is sufficiently long past the last shock. We can do this by assigning the values of the steady state to the final periods after the simulation, similarly to what we did with the initial conditions.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Alternatively, we can specify that we want to use the steady state in the call to simulate by passing fctype=fclevel. Yet another possibility is to set the final condition so that the solution slope matches the slope of the steady state by setting fctype=fcslope. In both cases, we do not need to set anything in the exogenous data array because those values would be ignored.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"tip: Pro tip\nIn the simple RBC model, the two ways of using the steady state for final conditions (level or slope) are equivalent, because the steady state here is stationary and unique. In models where the steady state has non-zero slope, or the steady state has zero slope but the level is not unique, we should use fctype=fcslope.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"If the steady state is not solved, or if we prefer not to depend on it, we can use fctype=fcnatural. The final conditions will be constructed assuming that in the last two periods of the simulation the  solution grows at the same rate, i.e., it has settled into its balanced growth. For a stationary model, the simulation needs to be long enough so that variables do not change anymore. In a model where the steady state has non-zero slope, non-stationary variables have to grow at a stable pace by the end of the simulation.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We can set the default option for the simple RBC model outside the model dedicated module.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"m.options.fctype = fcnatural","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Otherwise, this option can be set within the model module but the StateSpaceEcon package must be loaded within the module in addition to ModelBaseEcon. For instance:","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"module simple_RBC\n    using ModelBaseEcon\n    using StateSpaceEcon\n    const model = Model()\n    model.flags.ssZeroSlope = true\n    setoption!(model) do o\n        o.tol = 1e-14\n        o.maxiter = 100\n        o.substitutions = false\n        o.factorization = :qr\n        o.verbose = true\n        o.fctype = fcnatural   # requires StateSpaceEcon\n    end # options\n    # Rest of the model...\nend","category":"page"},{"location":"Tutorials/2.simple_RBC/main/#A-quick-sanity-check","page":"Simple RBC Model","title":"A quick sanity check","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"If we were to run a simulation where the economy started in the steady state and there were no shocks at all, we'd expect that the economy would remain in steady state forever.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"ss = simulate(m, p, exog);\n@test ss ≈ steadystatedata(m, p)","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The simulated data, ss, should equal (up to the accuracy of the solution) the steady state data. Similar to steadystatedata, we can use zerodata to create a data set containing zeros to work in the deviation from the steady state solution.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"zz = simulate(m, p, zerodata(m, p); deviation = true);\n@test zz ≈ zerodata(m, p)","category":"page"},{"location":"Tutorials/2.simple_RBC/main/#Exogenous-data-2","page":"Simple RBC Model","title":"Exogenous data","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"All shocks are exogenous by default. All we have left to do is to set the value of the shock.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Let's say that we want to shock ea for the first four quarters by 0.1.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"exog[sim_rng[1:4], :ea] .= 0.1;\nexog[shocks(m)]","category":"page"},{"location":"Tutorials/2.simple_RBC/main/#Running-the-simulation","page":"Simple RBC Model","title":"Running the simulation","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We call simulate, providing the model, the exogenous data, and the plan. We also specify the type of final condition we want to impose if we want to diverge from the option setting saved in the model.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"irf = simulate(m, p, exog; fctype=fcslope)","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We can now take a look at how some of the variables in the model have responded to this shock. We use plot from the Plots package. We specify the variables we want to plot using vars and the names of the datasets being plotted (for the legend) in the labels option.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"plot(ss, irf,\n     vars=m.variables, # variables to plot are taken from the model\n     legend= :none,\n     linewidth=1.5,   \n     size=(900,600),            # hide\n     xrotation = -20,           # hide\n     xtickfonthalign=:right,    # hide\n     xtickfontvalign=:top,      # hide\n    );","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"savefig(\"irf.png\")","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"(Image: Impulse Response Graph)","category":"page"},{"location":"Tutorials/2.simple_RBC/main/#Part-5:-Stochastic-shocks-simulation","page":"Simple RBC Model","title":"Part 5: Stochastic shocks simulation","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Now let's run a simulation with stochastic shocks. We will have random shocks over two years and then have no shocks for several years afterwards to allow time for the economy to return to its steady state.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"sim_rng = 2000Q1:2049Q4      # simulate 50 years starting 2000\nshk_rng = 2004Q1 .+ (0:7)    # shock 8 quarters starting in 2004\np = Plan(m, sim_rng)\nexog = steadystatedata(m, p);","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The distribution of the shock is assumed normal with mean zero. We use packages Distributions and Random to draw the necessary random values.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"shk_dist = (ea = Normal(0.0, 0.10),);\nfor (shk, dist) in pairs(shk_dist)\n    exog[shk_rng, shk] .= rand(dist, length(shk_rng))\nend\nexog[shk_rng, shocks(m)]","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Now we are ready to simulate. We can set the shocks to be anticipated or unanticipated by setting the anticipate parameter in simulate.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"sim_a = simulate(m, p, exog; fctype=fcnatural, anticipate=true);\nsim_u = simulate(m, p, exog; fctype=fcnatural, anticipate=false);","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"As before, we can review the responses of variables to the shock using plot.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"observed = collect(keys(m.autoexogenize)); # the observed variable is from the autoexogenize list\nss = steadystatedata(m, p);\ngr(display_type=:inline) # hide\nplot(ss, sim_a, sim_u,\n     vars=m.variables,\n     labels=(\"SS\", \"Anticipated\", \"Unanticipated\"),\n     legend=[true (false for i = 2:length(m.variables))...],\n     linewidth=1.5,   \n     size=(900,600),            # hide\n     xrotation = -20,           # hide\n     xtickfonthalign=:right,    # hide\n     xtickfontvalign=:top,      # hide\n    );","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"savefig(\"stoch_shk.png\")","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"(Image: Stochastic Shock Response Graph)","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We see that when the shock is anticipated, the variables start to react to them right away; in the unanticipated case, there is no movement until the technology shock actually hit.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/#Part-6:-Backing-out-historical-shocks","page":"Simple RBC Model","title":"Part 6: Backing out historical shocks","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Now let's pretend that the simulated values for A are historical data and that we do not know the magnitude of the shock ea. We can treat the observed (simulated) values of the variable A as known by making them exogenous. At the same time we will make the shock endogenous, so that we can solve for its values during the simulation.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We use exogenize! and endogenize! to set up a plan in which the observed variable is exogenous and the shock is endogenous throughout the stochastic range.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"endogenize!(p, shocks(m), shk_rng);\nexogenize!(p, observed, shk_rng);\np","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Another possibility is to use the autoexogenize! command, which will use the default pairing provided in the model definition under @autoexogenize.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"autoexogenize!(p, m, shk_rng)","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"As we can see above, the plan now reflects our intentions.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Finally, we need to set up the exogenous data. This time we do not specify the shocks; instead, we assign the known data for the observed variables for the historic range. We start with initial conditions.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"exog = steadystatedata(m, p);","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"We take the observed data from the simulation above. We show the anticipated version first.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"for v in observed\n    exog[shk_rng, v] .= sim_a[v]\nend\nback_a = simulate(m, p, exog; fctype=fcnatural, anticipate=true);","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Now we show the unanticipated case.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"for v in observed\n    exog[shk_rng, v] .= sim_u[v]\nend\nback_u = simulate(m, p, exog; fctype=fcnatural, anticipate=false);","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"If we did everything correctly, the shocks we recovered must match the shocks we used when we simulated the data.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"@test sim_a[:ea] ≈ back_a[:ea]\n@test sim_u[:ea] ≈ back_u[:ea]","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Moreover, we must have the unobserved variables match as well. In fact, all the data must match over the entire simulation range.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"@test sim_a ≈ back_a\n@test sim_u ≈ back_u","category":"page"},{"location":"Tutorials/2.simple_RBC/main/#Part-7:-Model-variants-and-solvers","page":"Simple RBC Model","title":"Part 7: Model variants and solvers","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"As of version 0.4 of StateSpaceEcon, there are two keyword arguments that control how the model is handled and which solver is used. These are variant and solver. The currently available variants are :default (the model is taken as given), :linearize and :selective_linearize. Currently there are two solvers available, namely :stackedtime (which is the default) and :firstorder.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"In order to use the :linearize variant, you must first solve for the steady state, as already explained. Once the steady state solution is stored in the model instance, you all linearize!, which creates the linearization of the model about its steady state and sets the default variant to :linearize.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"You can check or change the default variant via m.variant.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Once the linearized model is available, you can use either contnue to use the stacked time solver or you can start using the first order solver. For this you must first call solve! with solver=:firstorder, after which you can pass solver=:firstorder to simulate (and other functions that use a solver).","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"m.variant\nlinearize!(m)\nm.variant\nsolve!(m, solver = :firstorder)\nm.variant","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Instead of linearizing all the equations, you can linearize only selected equations by creating the variant :selective_linearize with the command selective_linearize!. Once again, the steady state solution must e available for this call to succeed.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"selective_linearize!(m)\nm.options.variant","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The equation that will be linearized with this call must be specified in the model file by marking them with the macro @lin. For instance:","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"@lin K[t] + C[t] = A[t] * (K[t-1]/(1+g)) ^ α * (L[t]) ^ (1-α) + (1-δ) * (K[t-1]/(1+g))","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The model variant can be reset back to the original by assigning it directly.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"m.variant = :default","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"In total, there are three variants:","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":":default: the model as given through its equations\n:linearize: first-order approximation around itssteady state\n:selective_linearize: first-order approximation around its steady state for the equations preceded by the macro @lin..","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"In addition to the variant, the command simulate requires a solver. StateSpaceEcon.jl currently has two solvers:","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"The solver :stackedtime can be used with any variant. It is the only solver that can be used with default and :selective_linearize.\nThe solver :firstorder can only be used for the variant :linearize. In fact, when this solver is specified the variant is ignored.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"To get the default solver, simply omit the solver= argument of the command simulate.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"For demonstration purposes, we compare the three models for an unanticipated shock ea for the first four quarters by 0.1.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"p = Plan(m, sim_rng)\nexog = zerodata(m,p);\nexog[sim_rng[1:4], :ea] .= 0.1;\nexog1 = simulate(m, p, exog; deviation = true, anticipate = false, variant = :default, solver = :stackedtime);\nexog2 = simulate(m, p, exog; deviation = true, anticipate = false, variant = :selective_linearize, solver = :stackedtime);\nexog3 = simulate(m, p, exog; deviation = true, anticipate = false, variant = :linearize, solver = :firstorder);\n\ngr(display_type=:inline) # hide\nplot(exog1, exog2, exog3,\n     vars=m.variables,\n     labels=(\"Stacked-Time\", \"Selective linearization\", \"Linearized\"),\n     legend=[true (false for i = 2:length(m.variables))...],\n     linewidth=1.5,   \n     size=(900,600),            # hide\n     xrotation = -20,           # hide\n     xtickfonthalign=:right,    # hide\n     xtickfontvalign=:top,      # hide\n    );","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"savefig(\"irf_variants.png\")","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"(Image: Impulse Response Graph)","category":"page"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"warning: The first-order approximation\nFor anticipated shocks, the :firstorder solver is only available for empty plans. Empty plans have all the shocks as exogenous and all the variables as endogenous. For anticipated shocks with non-empty plans, use the :stackedtime solver.","category":"page"},{"location":"Tutorials/2.simple_RBC/main/#Appendix","page":"Simple RBC Model","title":"Appendix","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/#References","page":"Simple RBC Model","title":"References","text":"","category":"section"},{"location":"Tutorials/2.simple_RBC/main/","page":"Simple RBC Model","title":"Simple RBC Model","text":"Villemot, S., 2013. First order approximation of stochastic models.","category":"page"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon-Reference","page":"ModelBaseEcon","title":"ModelBaseEcon Reference","text":"","category":"section"},{"location":"Reference/ModelBaseEcon/","page":"ModelBaseEcon","title":"ModelBaseEcon","text":"Pages = [\"modelbaseecon.md\"]","category":"page"},{"location":"Reference/ModelBaseEcon/#Public-interface","page":"ModelBaseEcon","title":"Public interface","text":"","category":"section"},{"location":"Reference/ModelBaseEcon/","page":"ModelBaseEcon","title":"ModelBaseEcon","text":"Modules = [ModelBaseEcon]\nPrivate = false","category":"page"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.ModelBaseEcon","page":"ModelBaseEcon","title":"ModelBaseEcon.ModelBaseEcon","text":"ModelBaseEcon\n\nThis package is part of the StateSpaceEcon ecosystem. It provides the basic elements needed for model definition. StateSpaceEcon works with model objects defined with ModelBaseEcon.\n\n\n\n\n\n","category":"module"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Equation","page":"ModelBaseEcon","title":"ModelBaseEcon.Equation","text":"struct Equation <: AbstractEquation ⋯ end\n\nData type representing a single equation in a model.\n\nEquations are defined in @equations blocks. The actual equation instances are later created with @initialize and stored within the model object.\n\nEquation flags can be specified by annotating the equation definition with one or more @<flag>. See EqnFlags for details.\n\nEach equation has two functions associated with it, one which computes the residual and the other computes both the residual and the gradient . Usually there's no need to users to call these functions directly. They are used internally by the solvers.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.LogTransform","page":"ModelBaseEcon","title":"ModelBaseEcon.LogTransform","text":"LogTransform <: Transformation\n\nThe log transformation. The inverse is of course exp. This is the default for variables declared with @log.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Model","page":"ModelBaseEcon","title":"ModelBaseEcon.Model","text":"mutable struct Model <: AbstractModel ⋯ end\n\nData structure that represents a macroeconomic model.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.ModelParam","page":"ModelBaseEcon","title":"ModelBaseEcon.ModelParam","text":"mutable struct ModelParam ⋯ end\n\nContains a model parameter. For a simple parameter it simply stores its value. For a link or an alias, it stores the link information and also caches the current value for speed.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.ModelVariable","page":"ModelBaseEcon","title":"ModelBaseEcon.ModelVariable","text":"struct ModelVariable ⋯ end\n\nData type for model variables. ModelVariable functions like a Symbol in many respects, but also holds meta-information about the variable, such as doc string, the variable type, transformation, steady state behaviour.\n\nVariable types include\n\n:var - a regular variable is endogenous by default, but can be exogenized. \n:shock - a shock variable is exogenous by default, but can be endogenized. Steady state is 0.\n:exog - an exogenous variable is always exogenous. \n\nThese can be declared with @variables, @shocks, and  @exogenous blocks. You can also use @exog within an  @variables block to declare an exogenous variable.\n\nTransformations include\n\n:none - no transformation. This is the default. In steady state these variables exhibit linear growth.\n:log - logarithm. This is useful for variables that must be always strictly positive. Internally the solver work with the logarithm of the variable. in steady state these variables exhibit exponential growth (the log variable grows linearly).\n:neglog - same as :log but for variables that are strictly negative. \n\nThese can be declared with @logvariables, @neglogvariables, @log, @neglog.\n\nSteady state behaviours include\n\n:const - these variables have zero slope in steady state and final conditions.\n:growth - these variables have constant slope in steady state and final conditions. The meaning of \"slope\" changes depending on the transformation. For :log and :neglog variables this is the growth rate, while for :none variables it is the usual slope of linear growth. \n\nShock variables are always :const while regular variables are assumed :growth. They can be declared :const using @steady.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.NegLogTransform","page":"ModelBaseEcon","title":"ModelBaseEcon.NegLogTransform","text":"NegLogTransform <: Transformation\n\nThe log(-x), with the inverse being -exp(x). Use this when the variable is negative with exponential behaviour (toward -∞).\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.NoTransform","page":"ModelBaseEcon","title":"ModelBaseEcon.NoTransform","text":"NoTransform <: Transformation\n\nThe identity transformation.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Parameters","page":"ModelBaseEcon","title":"ModelBaseEcon.Parameters","text":"Parameters([mod::Module])\n\nWhen creating an instance of Parameters, optionally one can specify the module in which parameter expressions will be evaluated. This only matters if there are any link parameters that depend on custom functions or global variables/constants. In this case, the mod argument should be the module in which these definitions exist.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Parameters-2","page":"ModelBaseEcon","title":"ModelBaseEcon.Parameters","text":"struct Parameters <: AbstractDict{Symbol, Any} ⋯ end\n\nContainer for model parameters. It functions as a Dict where the keys are the parameter names. Simple parameter values are stored directly. Special parameters depend on other parameters are are wrapped in the appropriate data structures to keep track of such dependencies. There are two types of special parameters - aliases and links.\n\nIndividual parameters can be accessed in two different ways - dot and bracket notation.\n\nRead access by dot notation calls peval while bracket notation doesn't. This makes no difference for simple parameters. For special parameters, access by bracket notation returns its internal structure, while access by dot notation returns its current value depending on other parameters.\n\nWrite access is the same in both dot and bracket notation. The new parameter value is assigned directly in the case of simple parameter. To create an alias parameter, use the @alias macro. To create a link parameter use the @link macro.\n\nSee also: ModelParam, peval, @alias, @link, update_links!.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.SteadyStateData","page":"ModelBaseEcon","title":"ModelBaseEcon.SteadyStateData","text":"SteadyStateData\n\nData structure that holds information about the steady state solution of the Model. This includes a collection of SteadyStateVariables and two collections of SteadyStateEquations - one for the steady state equations generated from dynamic equations and another for steady state constraints created with @steadystate.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.SteadyStateEquation","page":"ModelBaseEcon","title":"ModelBaseEcon.SteadyStateEquation","text":"struct SteadyStateEquation <: AbstractEquation ⋯ end\n\nData structure representing an individual steady state equation.\n\nSteady state equations can be constructed from the dynamic equations of the model. Each steady state variable has two unknowns, level and slope, so from each dynamic equation we construct two steady state equations.\n\nSteady state equations can also be constructed with @steadystate after @initialize has been called. We call such equations steady state constraints.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Transformation","page":"ModelBaseEcon","title":"ModelBaseEcon.Transformation","text":"abstract type Transformation end\n\nThe base class for all variable transformations.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.add_equation!-Tuple{Model, Expr}","page":"ModelBaseEcon","title":"ModelBaseEcon.add_equation!","text":"add_equation!(model::Model, expr::Expr; modelmodule::Module)\n\nProcess the given expression in the context of the given module, create the Equation() instance for it, and add it to the model instance.\n\nUsually there's no need to call this function directly. It is called during @initialize.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.alleqns-Tuple{SteadyStateData}","page":"ModelBaseEcon","title":"ModelBaseEcon.alleqns","text":"alleqns(ssd::SteadyStateData)\n\nReturn a list of all steady state equations.\n\nThe list contains all explicitly added steady state constraints and all equations derived from the dynamic system.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.assign_parameters!","page":"ModelBaseEcon","title":"ModelBaseEcon.assign_parameters!","text":"assign_parameters!(model, collection; [options])\nassign_parameters!(model; [options], param=value, ...)\n\nAssign values to model parameters. New parameters can be given as key-value pairs in the function call, or in a collection, such as a Dict, for example.\n\nIndividual parameters can be assigned directly to the model using dot notation. This function should be more convenient when all parameters values are loaded from a file and available in a dictionary or some other key-value collection.\n\nThere are two options that control the behaviour.\n\npreserve_links=true - if set to true new values for link-parameters are ignored and the link is updated automatically from the new values of parameters it depends on. If set to false any link parameters are overwritten and become non-link parameters set to the given new values.\ncheck=true - if a parameter with the given name does not exist we ignore it. When check is set to true we issue a warning, when set to false we ignore it silently.\n\nSee also: export_parameters and export_parameters!\n\nExample\n\njulia> @using_example E1\njulia> assign_parameters(E1.model; α=0.3, β=0.7)\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.assign_sstate!","page":"ModelBaseEcon","title":"ModelBaseEcon.assign_sstate!","text":"assign_sstate!(model, collection)\nassign_sstate!(model; var = value, ...)\n\nAssign a steady state solution from the given collection of name=>value pairs into the given model. \n\nIn each pair, the value can be a number in which case it is assigned as the level and the slope is set to 0. The value can also be a Tuple or a Vector in which case the first two elements are assigned as the level and the slope. Finally, the value can itself be a name-value collection (like a named tuple or a dictionary) with fields :level and :slope. Variables whose steady states are found in the collection are assigned and also marked as solved.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.eval_R!","page":"ModelBaseEcon","title":"ModelBaseEcon.eval_R!","text":"eval_R!(res::AbstractArray{Float64,1}, point::AbstractArray{Float64, 2}, ::MED) where MED <: AbstractModelEvaluationData\n\nEvaluate the model residual at the given point using the given model evaluation structure. The residual is stored in the provided vector.\n\nImplementation details (for developers)\n\nWhen creating a new type of model evaluation data, you must define a method of this function specialized to it.\n\nThe point argument will be a 2d array, with the number of rows equal to maxlag+maxlead+1 and the number of columns equal to the number of variables+shocks+auxvars of the model. The res vector will have the same length as the number of equations + auxiliary equations. Your implementation must not modify point and must update res.\n\nSee also: eval_RJ\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.eval_RJ","page":"ModelBaseEcon","title":"ModelBaseEcon.eval_RJ","text":"eval_RJ(point::AbstractArray{Float64, 2}, ::MED) where MED <: AbstractModelEvaluationData\n\nEvaluate the model residual and its Jacobian at the given point using the given model evaluation structure. Return a tuple, with the first element being the residual and the second element being the Jacobian.\n\nImplementation details (for developers)\n\nWhen creating a new type of model evaluation data, you must define a method of this function specialized to it.\n\nThe point argument will be a 2d array, with the number of rows equal to maxlag+maxlead+1 and the number of columns equal to the number of variables+shocks+auxvars of the model. Your implementation must not modify point and must return the tuple of (residual, Jacobian) evaluated at the given point. The Jacobian is expected to be SparseMatrixCSC (this might change in the future).\n\nSee also: eval_R!\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.export_model","page":"ModelBaseEcon","title":"ModelBaseEcon.export_model","text":"export_model(model, name, file::IO)\nexport_model(model, name, path::String)\n\nExport the model into a module file. The name parameter is used for the name of the module as well as the module file. The module file is created in the directory specified by the optional third argument.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.export_parameters","page":"ModelBaseEcon","title":"ModelBaseEcon.export_parameters","text":"export_parameters(model; include_links=true)\nexport_parameters(parameters; include_links=true)\n\nWrite all parameters into a Dict{Symbol, Any}. For link and alias parameter, only their current value is stored, the linking information is not. Set include_links=false to suppress the writing of link and alias parameters.\n\nUse assign_parameters! to restore the parameters values from the container created here.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.export_parameters!-Tuple{Any, ModelBaseEcon.AbstractModel}","page":"ModelBaseEcon","title":"ModelBaseEcon.export_parameters!","text":"export_parameters!(container, model; include_links=true)\nexport_parameters!(container, parameters; include_links=true)\n\nWrite all parameters into the given container. The parameters are push!-ed as name => value pairs. For link and alias parameter, only their current value is stored, the linking information is not. Set include_links=false to suppress the writing of link and alias parameters.\n\nUse assign_parameters! to restore the parameters values from the container created here.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.export_sstate","page":"ModelBaseEcon","title":"ModelBaseEcon.export_sstate","text":"export_sstate(model)\n\nReturn a dictionary containing the steady state solution stored in the given model. The value for each variable will be a number, if the variable has zero slope, or a named tuple (level = NUM, slope=NUM).\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.export_sstate!","page":"ModelBaseEcon","title":"ModelBaseEcon.export_sstate!","text":"export_sstate!(container, model)\n\nFill the given container with the steady state solution stored in the  given model. The value for each variable will be a number, if the variable has zero slope, or else a named tuple of the form (level = NUM, slope=NUM).\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.fullprint","page":"ModelBaseEcon","title":"ModelBaseEcon.fullprint","text":"fullprint(model)\n\nIf a model contains more than 20 variables or more than 20 equations, its display is truncated. In this case you can call fullprint to see the whole model.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.geteqn-Tuple{Integer, SteadyStateData}","page":"ModelBaseEcon","title":"ModelBaseEcon.geteqn","text":"geteqn(i, ssd::SteadyStateData)\n\nReturn the i-th steady state equation. Index i is interpreted as in the output of alleqns(::SteadyStateData). Calling geteqn(i, sdd) has the same effect as alleqn(ssd)[i], but it's more efficient.\n\nExample\n\n# Iterate all equations like this:\nfor i = 1:neqns(ssd)\n    eqn = geteqn(i, ssd)\n    # do something awesome with `eqn` and `i`\nend\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.inverse_transform","page":"ModelBaseEcon","title":"ModelBaseEcon.inverse_transform","text":"inverse_transform(x, var::ModelVariable)\n\nApply the inverse transformation associated with model variable m to data x.\n\nSee also inverse_transformation\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.inverse_transformation","page":"ModelBaseEcon","title":"ModelBaseEcon.inverse_transformation","text":"inverse_transformation(::Type{<:Transformation})\n\nReturn a Function that will be called to transform the simulation data after solving. See also transformation.\n\nIt is expected that transformation(T) ∘ inverse_transformation(T) == identity and inverse_transformation(T) ∘ transformation(T) == identity, but these is not verified.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.isexog-Tuple{ModelVariable}","page":"ModelBaseEcon","title":"ModelBaseEcon.isexog","text":"isexog(v)\n\nReturn true if the given ModelVariable is exogenous, otherwise return false.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.islin-Tuple{ModelVariable}","page":"ModelBaseEcon","title":"ModelBaseEcon.islin","text":"islin(v)\n\nReturn true if the given ModelVariable is a no-transformation variable, otherwise return false.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.islinearized-Tuple{Model}","page":"ModelBaseEcon","title":"ModelBaseEcon.islinearized","text":"islinearized(model::Model)\n\nReturn true if the given model is linearized and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.islog-Tuple{ModelVariable}","page":"ModelBaseEcon","title":"ModelBaseEcon.islog","text":"islog(v)\n\nReturn true if the given ModelVariable is a log-transformation variable, otherwise return false.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.isneglog-Tuple{ModelVariable}","page":"ModelBaseEcon","title":"ModelBaseEcon.isneglog","text":"isneglog(v)\n\nReturn true if the given ModelVariable is a negative-log-transformation variable, otherwise return false.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.isshock-Tuple{ModelVariable}","page":"ModelBaseEcon","title":"ModelBaseEcon.isshock","text":"isshock(v)\n\nReturn true if the given ModelVariable is a shock, otherwise return false.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.issssolved-Tuple{SteadyStateData}","page":"ModelBaseEcon","title":"ModelBaseEcon.issssolved","text":"issssolved(sstate::SteadyStateData)\n\nReturn true if the steady state has been solved, or false otherwise.\n\nnote: Note\nThis function only checks that the steady state is marked as solved. It does not verify that the stored steady state values actually satisfy the steady state system of equations. Use check_sstate from StateSpaceEcon for that.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.issteady-Tuple{ModelVariable}","page":"ModelBaseEcon","title":"ModelBaseEcon.issteady","text":"issteady(v)\n\nReturn true if the given ModelVariable is zero-slope, otherwise return false.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.linearize!","page":"ModelBaseEcon","title":"ModelBaseEcon.linearize!","text":"linearize!(model::Model; <keyword arguments>)\n\nTransform model into its linear approximation about its steady state.\n\nKeyword arguments\n\nsstate - linearize about the provided steady state solution\ndeviation::Bool - whether or not the linearized model will treat data passed to it as deviation from the steady state\n\nSee also: linearized and with_linearized\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.linearized-Tuple{Model}","page":"ModelBaseEcon","title":"ModelBaseEcon.linearized","text":"linearized(model::Model; <arguments>)\n\nCreate a new model that is the linear approximation of the given model about its steady state.\n\nKeyword arguments\n\nsstate - linearize about the provided steady state solution\ndeviation::Bool - whether or not the linearized model will tread data passed \n\nto is as deviation from the steady state\n\nSee also: linearize! and with_linearized\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.logm-Tuple{Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.logm","text":"logm(x) = log(-x)\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.mexp-Tuple{Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.mexp","text":"mexp(x) = -exp(x)\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.need_transform","page":"ModelBaseEcon","title":"ModelBaseEcon.need_transform","text":"need_transform(v)\n\nReturn true if there is a transformation associated with model variable v, otherwise return false.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.neqns-Tuple{SteadyStateData}","page":"ModelBaseEcon","title":"ModelBaseEcon.neqns","text":"neqns(ssd::SteadyStateData)\n\nReturn the total number of equations in the steady state system, including the ones added explicitly as steady state constraints and the ones derived from the dynamic system.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.peval","page":"ModelBaseEcon","title":"ModelBaseEcon.peval","text":"peval(params, what)\n\nEvaluate the given expression in the context of the given parameters params.\n\nIf what is a ModelParam, its current value is returned. If it's a link and  there's a chance it might be out of date, call update_links!.\n\nIf what is a Symbol or an Expr, all mentions of parameter names are substituted by their values and the expression is evaluated.\n\nIf what is any other value, it is returned unchanged.\n\nSee also: Parameters, @alias, @link, ModelParam, update_links!.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.print_linearized","page":"ModelBaseEcon","title":"ModelBaseEcon.print_linearized","text":"print_linearized(io, model)\nprint_linearized(model)\n\nWrite the system of equations of the linearized model.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.printsstate-Tuple{IO, ModelBaseEcon.AbstractModel}","page":"ModelBaseEcon","title":"ModelBaseEcon.printsstate","text":"printsstate([io::IO,] ssd::SteadyStateData)\n\nDisplay steady state solution.\n\nSteady state solution is presented in a table, where the first column is the name of the variable, the second and third columns are the corresponding values of the level and the slope. If the value is not determined (as per its mask value) then it is displayed as \"*\".\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.refresh_med!","page":"ModelBaseEcon","title":"ModelBaseEcon.refresh_med!","text":"refresh_med!(model)\n\nRefresh the model evaluation data stored within the given model instance. Most notably, this is necessary when the steady state is used in the dynamic equations.\n\nNormally there's no need for the end-used to call this function. It should be called when necessay by the solver.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.selective_linearize!-Tuple{ModelBaseEcon.AbstractModel}","page":"ModelBaseEcon","title":"ModelBaseEcon.selective_linearize!","text":"selective_linearize!(model)\n\nInstruct the model instance to use selective linearization. Only equations annotated with @lin in the model definition will be linearized about the current steady state solution while the rest of the eq\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.to_exog-Tuple{Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.to_exog","text":"to_exog(v)\n\nMake an exogenous ModelVariable from v.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.to_lin-Tuple{Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.to_lin","text":"to_lin(v)\n\nMake a no-transformation ModelVariable from v.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.to_log-Tuple{Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.to_log","text":"to_log(v)\n\nMake a log-transformation ModelVariable from v.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.to_neglog-Tuple{Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.to_neglog","text":"to_neglog(v)\n\nMake a negative-log-transformation ModelVariable from v.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.to_shock-Tuple{Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.to_shock","text":"to_shock(v)\n\nMake a shock ModelVariable from v.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.to_steady-Tuple{Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.to_steady","text":"to_steady(v)\n\nMake a zero-slope ModelVariable from v.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.transform","page":"ModelBaseEcon","title":"ModelBaseEcon.transform","text":"transform(x, var::ModelVariable)\n\nApply the transformation associated with model variable m to data x.\n\nSee also transformation.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.transformation","page":"ModelBaseEcon","title":"ModelBaseEcon.transformation","text":"transformation(::Type{<:Transformation})\n\nReturn a Function that will be substituted into the model equations and will be called to transform the input data before solving. See also inverse_transformation.\n\nIt is expected that transformation(T) ∘ inverse_transformation(T) == identity and inverse_transformation(T) ∘ transformation(T) == identity, but these is not verified.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.update_links!-Tuple{ModelBaseEcon.AbstractModel}","page":"ModelBaseEcon","title":"ModelBaseEcon.update_links!","text":"update_links!(model)\nupdate_links!(params)\n\nRecompute the current values of all parameters.\n\nTypically when a new value of a parameter is assigned, all parameter links and aliases that depend on it are updated recursively. If a parameter is mutable, e.g. a Vector or another collection, its value can be updated in place without re-assigning the parameter, thus the automatic update does not happen. In this case, it is necessary to call update_links! manually.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.with_linearized-Tuple{Function, Model}","page":"ModelBaseEcon","title":"ModelBaseEcon.with_linearized","text":"with_linearized(F::Function, model::Model; <arguments>)\n\nApply the given function on a new model that is the linear approximation  of the given model about its steady state.  This is meant to be used with the do syntax, as in the example below.\n\nKeyword arguments\n\nsstate - linearize about the provided steady state solution\ndeviation::Bool - whether or not the linearized model will tread data passed \n\nto is as deviation from the steady state\n\nSee also: linearize! and with_linearized\n\nExample\n\nwith_linearized(m) do lm\n    # do something awesome with linearized model `lm`\nend\n# model `m` is still non-linear.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@alias-Tuple{Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.@alias","text":"@alias name\n\nCreate a parameter alias. Use @alias in the @parameters section of your model definition.\n\n@parameters model begin\n    a = 5\n    b = @alias a\nend\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@autoexogenize-Tuple{Any, Vararg{Expr}}","page":"ModelBaseEcon","title":"ModelBaseEcon.@autoexogenize","text":"@autoexogenize model begin\n    varname = shkname\n    ...\nend\n\nDefine a mapping between variables and shocks that can be used to conveniently  swap exogenous and endogenous variables.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@autoshocks","page":"ModelBaseEcon","title":"ModelBaseEcon.@autoshocks","text":"@autoshocks model [suffix]\n\nCreate a list of shocks that matches the list of variables. Each shock name is created from a variable name by appending suffix. Default suffix is \"_shk\", but it can be specified as the second argument too.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@d-Tuple","page":"ModelBaseEcon","title":"ModelBaseEcon.@d","text":"@d(expr[, n=1 [, s=0 ]])\n\nApply the difference operator to the given expression. If L represents the lag operator, then we have the following definitions.\n\n@d(x[t]) = (1-L)x = x[t]-x[t-1]\n@d(x[t], n) = (1-L)^n x\n@d(x[t], n, s) = (1-L)^n (1-L^s) x\n\nSee also @lag, @d.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@dlog-Tuple","page":"ModelBaseEcon","title":"ModelBaseEcon.@dlog","text":"@dlog(expr[, n=1 [, s=0 ]])\n\nApply the difference operator on the log() of the given expression. Equivalent to @d(log(expr), n, s).\n\nSee also @lag, @d\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@equations-Tuple{Any, Expr}","page":"ModelBaseEcon","title":"ModelBaseEcon.@equations","text":"@equations model begin\n    lhs = rhs\n    lhs = rhs\n    ...\nend\n\nDefine model equations. See Equation.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@exogenous-Tuple{Any, Expr}","page":"ModelBaseEcon","title":"ModelBaseEcon.@exogenous","text":"@exogenous\n\nLike @variables, but the names declared with @exogenous are exogenous.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@initialize-Tuple{Symbol}","page":"ModelBaseEcon","title":"ModelBaseEcon.@initialize","text":"@initialize model\n\nPrepare a model instance for analysis. Call this macro after all parameters, variable names, shock names and equations have been declared and defined.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@lag-Tuple","page":"ModelBaseEcon","title":"ModelBaseEcon.@lag","text":"@lag(expr[, n=1])\n\nApply the lag operator to the given expression.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@lead-Tuple","page":"ModelBaseEcon","title":"ModelBaseEcon.@lead","text":"@lead(expr[, n=1])\n\nApply the lead operator to the given expression. Equivalent to @lag(expr, -n).\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@link-Tuple{Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.@link","text":"@link expr\n\nCreate a parameter link. Use @link in the @parameters section of your model definition.\n\nIf your parameter depends on other parameters, then you use @link to declare that. The expression can be any valid Julia code.\n\n@parameters model begin\n    a = 5\n    b = @link a + 1\nend\n\nWhen a parameter the link depends on is assigned a new value, the link that depends on it gets updated automatically.\n\nnote: Important note\nThere are two cases in which the value of a link does not get updated automatically. If the parameter it depends on is mutable, e.g. a Vector, it is possible for it to get updated in place. The other case is when the link contains global variable or custom function.In such case, it is necessary to call update_links!.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@load_example-Tuple{Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.@load_example","text":"Deprecated. Use @using_example instead.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@logvariables-Tuple{Any, Expr}","page":"ModelBaseEcon","title":"ModelBaseEcon.@logvariables","text":"@logvariables\n\nSame as @variables, but the variables declared with @logvariables are log-transformed.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@movav-Tuple","page":"ModelBaseEcon","title":"ModelBaseEcon.@movav","text":"@movav(expr, n)\n\nApply moving average with n periods backwards on the given expression. For example: @movav(x[t], 3) = (x[t] + x[t-1] + x[t-2]) / 3.\n\nSee also @lag.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@movavew-Tuple","page":"ModelBaseEcon","title":"ModelBaseEcon.@movavew","text":"@movavew(expr, n, r)\n\nApply moving average with exponential weights with ratio r. For example: @moveavew(x[t], 3, 0.7) = (x[t] + 0.7*x[t-1] + 0.7^2x[t-2]) / (1 + 0.7 + 0.7^2)\n\nSee also @movsumew\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@movsum-Tuple","page":"ModelBaseEcon","title":"ModelBaseEcon.@movsum","text":"@movsum(expr, n)\n\nApply moving sum with n periods backwards on the given expression. For example: @movsum(x[t], 3) = x[t] + x[t-1] + x[t-2].\n\nSee also @lag.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@movsumew-Tuple","page":"ModelBaseEcon","title":"ModelBaseEcon.@movsumew","text":"@movsumew(expr, n, r)\n\nApply moving sum with exponential weights with ratio r. For example: @movsumew(x[t], 3, 0.7) = x[t] + 0.7*x[t-1] + 0.7^2x[t-2]\n\nSee also @movavew\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@neglogvariables-Tuple{Any, Expr}","page":"ModelBaseEcon","title":"ModelBaseEcon.@neglogvariables","text":"@neglogvariables\n\nSame as @variables, but the variables declared with @neglogvariables are negative-log-transformed.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@parameters-Tuple{Any, Vararg{Expr}}","page":"ModelBaseEcon","title":"ModelBaseEcon.@parameters","text":"@parameters model begin\n    name = value\n    ...\nend\n\nDeclare and define the model parameters.\n\nThe parameters must have values. Provide the information in a series of assignment statements wrapped inside a begin-end block. Use @link and @alias to define dynamic links. See Parameters.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@parameters-Tuple{}","page":"ModelBaseEcon","title":"ModelBaseEcon.@parameters","text":"params = @parameters\n\nWhen called without any arguments, return an empty Parameters container, with its evaluation module set to the module in which the macro is being called.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@peval-Tuple{Any, Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.@peval","text":"@peval params what\n\nEvaluate the expression what within the context of the  given set of parameters \n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@shocks-Tuple{Any, Expr}","page":"ModelBaseEcon","title":"ModelBaseEcon.@shocks","text":"@shocks\n\nLike @variables, but the names declared with @shocks are shocks.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@steadystate-Tuple{Any, Symbol, Expr}","page":"ModelBaseEcon","title":"ModelBaseEcon.@steadystate","text":"@steadystate model [type] lhs = rhs\n\nAdd a steady state equation to the model.\n\nThe steady state system of the model is automatically derived from the dynamic system. Use this macro to define additional equations for the steady state. This is particularly useful in the case of a non-linear model that might have multiple steady state, or the steady state might be difficult to solve for, to help the steady state solver find the one you want to use.\n\nmodel is the model instance you want to update\ntype (optional) is the type of constraint you want to add. This can be level\n\nor slope. If missing, the default is level\n\nlhs = rhs is the expression defining the steady state constraint. In the\n\nequation, use variables and shocks from the model, but without any t-references.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@steadyvariables-Tuple{Any, Expr}","page":"ModelBaseEcon","title":"ModelBaseEcon.@steadyvariables","text":"@steadyvariables\n\nSame as @variables, but the variables declared with @steadyvariables have zero slope in their steady state and final conditions.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@using_example-Tuple{Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.@using_example","text":"@using_example name\n\nLoad models from the package examples/ folder. The @load_example version is deprecated - stop using it now.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.@variables-Tuple{Any, Expr}","page":"ModelBaseEcon","title":"ModelBaseEcon.@variables","text":"@variables model name1 name2 ...\n@variables model begin\n    name1\n    name2\n    ...\nend\n\nDeclare the names of variables in the model.\n\nIn the begin-end version the variable names can be preceeded by a description (like a docstring) and flags like @log, @steady, @exog, etc. See ModelVariable for details about this.\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#Options","page":"ModelBaseEcon","title":"Options","text":"","category":"section"},{"location":"Reference/ModelBaseEcon/","page":"ModelBaseEcon","title":"ModelBaseEcon","text":"Modules = [ModelBaseEcon.OptionsMod]\nPrivate = false","category":"page"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.OptionsMod","page":"ModelBaseEcon","title":"ModelBaseEcon.OptionsMod","text":"OptionsMod\n\nSub-module of ModelBaseEcon, although it can be used independently. Implements the Options data structure.\n\nContents\n\nOptions\ngetoption - read the value of an option\ngetoption! - if not present, also create an option\nsetoption! - create or update the value of an option \n\n\n\n\n\n","category":"module"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.OptionsMod.Options","page":"ModelBaseEcon","title":"ModelBaseEcon.OptionsMod.Options","text":"Options\n\nA collection of key-value pairs representing the options controlling the behaviour or the definition of a Model object. The key is the option name and is always a Symbol, or converted to Symbol, while the value can be anything.\n\nThe options can be accessed using dot notation. Functions getoption and setoption! are also provided. They can be used for programmatic processing of options as well as when the option name is not a valid Julia identifier.\n\nSee also: Options, getoption, getoption!, setoption!\n\nExamples\n\njulia> o = Options(maxiter=20, tol=1e-7)\nOptions:\n    maxiter=20\n    tol=1.0e-7\n\njulia> o.maxiter = 25\n25\n\njulia> o\nOptions:\n    maxiter=25\n    tol=1.0e-7\n\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.OptionsMod.Options-Tuple{Options}","page":"ModelBaseEcon","title":"ModelBaseEcon.OptionsMod.Options","text":"Options(::Options)\n\nConstruct an Options instance as an exact copy of an existing instance.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.OptionsMod.Options-Tuple{}","page":"ModelBaseEcon","title":"ModelBaseEcon.OptionsMod.Options","text":"Options(key=value, ...)\nOptions(:key=>value, ...)\n\nConstruct an Options instance with key-value pairs given as keyword arguments or as a list of pairs. If the latter is used, each key must be a Symbol.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.OptionsMod.getoption","page":"ModelBaseEcon","title":"ModelBaseEcon.OptionsMod.getoption","text":"getoption(o::Options; name=default [, name=default, ...])\ngetoption(o::Options, name, default)\n\nRetrieve the value of an option or a set of options.  The provided defaults are used when the option doesn't exit.\n\nThe return value is the value of the option requested or, if the option doesn't exist, the default. In the first version of the function, if there are more than one options requested, the return value is a tuple.\n\nIn the second version, the name could be a symbol or a string, which can be helpful if the name of the option is not a valid identifier.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.OptionsMod.getoption!","page":"ModelBaseEcon","title":"ModelBaseEcon.OptionsMod.getoption!","text":"getoption!(o::Options; name=default [, name=default, ...])\ngetoption!(o::Options, name, default)\n\nRetrieve the value of an option or a set of options. If the name does not match an existing option, the Options instance is updated by inserting the given name and default value.\n\nThe return value is the value of the option requested (or the default). In the first version of the function, if there are more than one options requested, the return value is a tuple.\n\nIn the second version, the name could be a symbol or a string, which can be helpful if the name of the option is not a valid identifier.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.OptionsMod.setoption!","page":"ModelBaseEcon","title":"ModelBaseEcon.OptionsMod.setoption!","text":"setoption!(o::Options; name=default [, name=default, ...])\nsetoption!(o::Options, name, default)\n\nRetrieve the value of an option or a set of options. If the name does not match an existing option, the Options instance is updated by inserting the given name and default value.\n\nThe return value is the value of the option requested (or the default). In the first version of the function, if there are more than one options requested, the return value is a tuple.\n\nIn the second version, the name could be a symbol or a string, which can be helpful if the name of the option is not a valid identifier.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#Timer","page":"ModelBaseEcon","title":"Timer","text":"","category":"section"},{"location":"Reference/ModelBaseEcon/","page":"ModelBaseEcon","title":"ModelBaseEcon","text":"Modules = [ModelBaseEcon.Timer]\nPrivate = false","category":"page"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Timer","page":"ModelBaseEcon","title":"ModelBaseEcon.Timer","text":"Timer\n\nA sub-module of ModelBaseEcon, although it can be used independently. Provides functionality for measuring the aggregate time spent in individual lines or blocks of code.\n\ntip: Tip\nThe implementation here is quick-and-dirty and is intended for getting a rough idea of where the bottlenecks are. It is best used for timing blocks of code that are passed through relatively few times and each pass takes a relatively long time. In the opposite extreme case (fast code that is called many times), the current implementation of @timer might add extreme overhead.\n\nContents\n\ninittimer       - Enable collection of timer data.\nstoptimer       - Disable collection of timer data.\nprinttimer      - Display timer data.\n@timer          - Measure the runtime taken by the given code.\n\n\n\n\n\n","category":"module"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Timer.inittimer-Tuple{}","page":"ModelBaseEcon","title":"ModelBaseEcon.Timer.inittimer","text":"inittimer()\n\nEnable the collection of timing data. Existing timing data is lost. By default, collection of timing data is disabled.\n\nSee also: stoptimer, @timer, printtimer\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Timer.printtimer","page":"ModelBaseEcon","title":"ModelBaseEcon.Timer.printtimer","text":"printtimer(io::IO=Base.stdout)\n\nDisplay timing data.\n\nTiming data is displayed in a table with each row containing the number of calls, total time in seconds, and the source line or block tag. Rows are sorted in order of decreasing total time.\n\nSee also: @timer\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Timer.stoptimer-Tuple{}","page":"ModelBaseEcon","title":"ModelBaseEcon.Timer.stoptimer","text":"stoptimer()\n\nDisable the collection of timing data. Existing data is lost. By default, collection of timing data is disabled.\n\nSee also: inittimer, @timer, printtimer\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Timer.@timer-Tuple","page":"ModelBaseEcon","title":"ModelBaseEcon.Timer.@timer","text":"@timer(code)\n@timer(tag::String, code)\n\nMeasure the number of calls and the total time taken by the given code.\n\nIf a tag string is not provided, one is generated from the source file and line. The return value of this macro call is the return value of the code.\n\nwarning: Warning\nImportant limitation is that the code must not contain a return, break, continue, or any other jump out of it. If it does, the program would run correctly, but the timing data collected would be incorrect.\n\nSee also: inittimer, stoptimer, printtimer\n\nExample\n\njulia> inittimer()\n\njulia> @timer Base.sleep(1.0)\n\njulia> printtimer()\n[...]\n\n\n\n\n\n","category":"macro"},{"location":"Reference/ModelBaseEcon/#Internals","page":"ModelBaseEcon","title":"Internals","text":"","category":"section"},{"location":"Reference/ModelBaseEcon/","page":"ModelBaseEcon","title":"ModelBaseEcon","text":"Modules = [ModelBaseEcon]\nPublic = false","category":"page"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.AbstractEquation","page":"ModelBaseEcon","title":"ModelBaseEcon.AbstractEquation","text":"abstract type AbstractEquation end\n\nBase type for Equation.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.AbstractModel","page":"ModelBaseEcon","title":"ModelBaseEcon.AbstractModel","text":"abstract type AbstractModel end\n\nBase type for Model.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.AbstractModelEvaluationData","page":"ModelBaseEcon","title":"ModelBaseEcon.AbstractModelEvaluationData","text":"AbstractModelEvaluationData\n\nBase type for all model evaluation structures. Specific derived types would specialize in different types of models.\n\nImplementaion (for developers)\n\nDerived types must specialize two functions\n\neval_R! - evaluate the residual\neval_RJ - evaluate the residual and its Jacobian\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.AbstractParam","page":"ModelBaseEcon","title":"ModelBaseEcon.AbstractParam","text":"abstract type AbstractParam end\n\nBase type for model parameters.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.EqnFlags","page":"ModelBaseEcon","title":"ModelBaseEcon.EqnFlags","text":"mutable struct EqnFlags ⋯ end\n\nHolds information about the equation. Flags can be specified in the model definition by annotating the equation with @<flag> (insert the flag you want to raise in place of <flag>). Multiple flags may be applied to the same equation.\n\nSupported flags:\n\n@log lhs = rhs instructs the model parser to make the residual log(lhs / rhs). Normally the residual is lhs - rhs.\n@lin lhs = rhs marks the equation for selective linearization.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.EqnNotReadyError","page":"ModelBaseEcon","title":"ModelBaseEcon.EqnNotReadyError","text":"struct EqnNotReadyError <: ModelErrorBase\n\nConcrete error type used to indicate that a given equation has not been prepared for use in the model yet.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.LinearizationError","page":"ModelBaseEcon","title":"ModelBaseEcon.LinearizationError","text":"LinearizationError <: ModelErrorBase\n\nA concrete error type used when a model cannot be linearized for some reason.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.LinearizedModelEvaluationData","page":"ModelBaseEcon","title":"ModelBaseEcon.LinearizedModelEvaluationData","text":"LinearizedModelEvaluationData <: AbstractModelEvaluationData\n\nModel evaluation data for the linearized model.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.ModelErrorBase","page":"ModelBaseEcon","title":"ModelBaseEcon.ModelErrorBase","text":"abstract type ModelErrorBase <: Exception end\n\nAbstract error type, base for specific error types used in ModelBaseEcon.\n\nImplementation (note for developers)\n\nWhen implementing a derived error type, override two functions:\n\nmsg(e::SomeModelError) returning a string with the error message;\nhint(e::SomeModelError) returning a string containing a suggestion of how to fix the problem. Optional, if not implemented for a type, the fallback implementation returns an empty string.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.ModelEvaluationData","page":"ModelBaseEcon","title":"ModelBaseEcon.ModelEvaluationData","text":"ModelEvaluationData <: AbstractModelEvaluationData\n\nThe standard model evaluation data used in the general case and by default.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.ModelEvaluationData-Tuple{ModelBaseEcon.AbstractModel}","page":"ModelBaseEcon","title":"ModelBaseEcon.ModelEvaluationData","text":"ModelEvaluationData(model::AbstractModel)\n\nCreate the standard evaluation data structure for the given model.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.ModelFlags","page":"ModelBaseEcon","title":"ModelBaseEcon.ModelFlags","text":"mutable struct ModelFlags ⋯ end\n\nModel flags include\n\nssZeroSlope - Set to true to instruct the solvers that all variables have zero slope in steady state and final conditions. In other words the model is stationary.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.ModelNotInitError","page":"ModelBaseEcon","title":"ModelBaseEcon.ModelNotInitError","text":"struct ModelNotInitError <: ModelErrorBase\n\nSpecific error type used when there's an attempt to use a Model object that has not been initialized.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.NotImplementedError","page":"ModelBaseEcon","title":"ModelBaseEcon.NotImplementedError","text":"struct NotImplementedError <: ModelErrorBase\n\nSpecific error type used when a feature is planned but not yet implemented. \n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.SSEqnData","page":"ModelBaseEcon","title":"ModelBaseEcon.SSEqnData","text":"SSEqnData\n\nInternal structure used for evaluation of the residual of the steady state equation derived from a dynamic equation.\n\nwarning: Warning\nThis data type is for internal use only and not intended to be used directly by users.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.SteadyStateVariable","page":"ModelBaseEcon","title":"ModelBaseEcon.SteadyStateVariable","text":"struct SteadyStateVariable ⋯ end\n\nHolds the steady state solution for one variable, which includes the values of two steady state unknowns - level and slope.\n\n\n\n\n\n","category":"type"},{"location":"Reference/ModelBaseEcon/#Base.iterate","page":"ModelBaseEcon","title":"Base.iterate","text":"iterate(params::Parameters)\n\nIterates the given Parameters collection in the order of dependency. Specifically, each parameter comes up only after all parameters it depends on have already been visited. The order within that is alphabetical.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.at_d","page":"ModelBaseEcon","title":"ModelBaseEcon.at_d","text":"at_d(expr[, n=1 [, s=0 ]])\n\nApply the difference operator to the given expression. If L represents the lag operator, then we have the following definitions.\n\nat_d(x[t]) = (1-L)x = x[t]-x[t-1]\nat_d(x[t], n) = (1-L)^n x\nat_d(x[t], n, s) = (1-L)^n (1-L^s) x\n\nSee also at_lag, at_d.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.at_dlog-Tuple{Expr, Vararg{Any}}","page":"ModelBaseEcon","title":"ModelBaseEcon.at_dlog","text":"at_dlog(expr[, n=1 [, s=0 ]])\n\nApply the difference operator on the log() of the given expression. Equivalent to at_d(log(expr), n, s).\n\nSee also at_lag, at_d\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.at_lag-Tuple{Any, Vararg{Any}}","page":"ModelBaseEcon","title":"ModelBaseEcon.at_lag","text":"at_lag(expr[, n=1])\n\nApply the lag operator to the given expression.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.at_lead","page":"ModelBaseEcon","title":"ModelBaseEcon.at_lead","text":"at_lead(expr[, n=1])\n\nApply the lead operator to the given expression. Equivalent to at_lag(expr, -n).\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.at_movav-Tuple{Expr, Integer}","page":"ModelBaseEcon","title":"ModelBaseEcon.at_movav","text":"at_movav(expr, n)\n\nApply moving average with n periods backwards on the given expression. For example: at_movav(x[t], 3) = (x[t] + x[t-1] + x[t-2]) / 3.\n\nSee also at_lag.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.at_movavew-Tuple{Expr, Integer, Real}","page":"ModelBaseEcon","title":"ModelBaseEcon.at_movavew","text":"at_movavew(expr, n, r)\n\nApply moving average with exponential weights with ratio r. For example: at_moveavew(x[t], 3, 0.7) = (x[t] + 0.7*x[t-1] + 0.7^2x[t-2]) / (1 + 0.7 + 0.7^2)\n\nSee also at_movsumew\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.at_movsum-Tuple{Expr, Integer}","page":"ModelBaseEcon","title":"ModelBaseEcon.at_movsum","text":"at_movsum(expr, n)\n\nApply moving sum with n periods backwards on the given expression. For example: at_movsum(x[t], 3) = x[t] + x[t-1] + x[t-2].\n\nSee also at_lag.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.at_movsumew-Tuple{Expr, Integer, Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.at_movsumew","text":"at_movsumew(expr, n, r)\n\nApply moving sum with exponential weights with ratio r. For example: at_movsumew(x[t], 3, 0.7) = x[t] + 0.7*x[t-1] + 0.7^2x[t-2]\n\nSee also at_movavew\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.funcsyms","page":"ModelBaseEcon","title":"ModelBaseEcon.funcsyms","text":"funcsyms(mod::Module)\n\nCreate a pair of identifiers that does not conflict with existing identifiers in the given module.\n\nwarning: Warning\nInternal function. Do not call directly.\n\nImplementation (for developers)\n\nWe need two identifiers resid_N and RJ_N where \"N\" is some integer number. The first is going to be the name of the function that evaluates the equation and the second is going to be the name of the function that evaluates both the equation and its gradient.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.hint-Tuple{ModelBaseEcon.ModelErrorBase}","page":"ModelBaseEcon","title":"ModelBaseEcon.hint","text":"hint(::ModelErrorBase)\n\nReturn the hint message - a suggestion of how the problem might be fixed.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.initfuncs-Tuple{Module}","page":"ModelBaseEcon","title":"ModelBaseEcon.initfuncs","text":"initfuncs(mod::Module)\n\nInitialize the given module before creating functions that evaluate residuals and thier gradients.\n\nwarning: Warning\nInternal function. Do not call directly.\n\nImplementation (for developers)\n\nDeclare the necessary types in the module where the model is being defined. There are two such types. First is EquationEvaluator, which is callable and stores a collection of parameters. The call will be defined in makefuncs and will evaluate the residual. The other type is EquationGradient, which is also callable and stores the EquationEvaluator together with a DiffResult and a GradientConfig used by ForwardDiff. Its call is defined here and computes the residual and the gradient.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.initialize!-Tuple{Model, Module}","page":"ModelBaseEcon","title":"ModelBaseEcon.initialize!","text":"initialize!(model, modelmodule)\n\nIn the model file, after all declarations of flags, parameters, variables, and equations are done, it is necessary to initialize the model instance. Usually it is easier to call @initialize, which automatically sets the modelmodule value. When it is necessary to set the modelmodule argument to some other module, then this can be done by calling this function instead of the macro.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.initssdata!-Tuple{ModelBaseEcon.AbstractModel}","page":"ModelBaseEcon","title":"ModelBaseEcon.initssdata!","text":"initssdata!(m::AbstractModel)\n\nCreate and initialize the SteadyStateData structure of the given model.\n\nwarning: Warning\nThis function is for internal use only and not intended to be called directly by users. It is called during @initialize.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.make_sseqn","page":"ModelBaseEcon","title":"ModelBaseEcon.make_sseqn","text":"make_sseqn(model::AbstractModel, eqn::Equation, shift::Bool, var_to_idx)\n\nCreate a steady state equation from the given dynamic equation for the given model.\n\nwarning: Warning\nThis function is for internal use only and not intended to be called directly by users.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.makefuncs-NTuple{5, Any}","page":"ModelBaseEcon","title":"ModelBaseEcon.makefuncs","text":"makefuncs(expr, tssyms, sssyms, psyms, mod)\n\nCreate two functions that evaluate the residual and its gradient for the given expression.\n\nwarning: Warning\nInternal function. Do not call directly.\n\nArguments\n\nexpr: the expression\ntssyms: list of time series variable symbols\nsssyms: list of steady state symbols\npsyms: list of parameter symbols\n\nReturn value\n\nReturn a quote block to be evaluated in the module where the model is being defined. The quote block contains definitions of the residual function (as a callable EquationEvaluator instance) and a second function that evaluates both the residual and its gradient (as a callable EquationGradient instance).\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.modelerror","page":"ModelBaseEcon","title":"ModelBaseEcon.modelerror","text":"modelerror(ME::Type{<:ModelErrorBase}, args...; kwargs...)\n\nRaise an exception derived from ModelErrorBase.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.moduleof","page":"ModelBaseEcon","title":"ModelBaseEcon.moduleof","text":"moduleof(equation)\nmoduleof(model)\n\nReturn the module in which the given equation or model was initialized.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.msg","page":"ModelBaseEcon","title":"ModelBaseEcon.msg","text":"msg(::ModelErrorBase)\n\nReturn the error message - a description of what went wrong.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.precompile_dual_funcs-Tuple{Int64}","page":"ModelBaseEcon","title":"ModelBaseEcon.precompile_dual_funcs","text":"precompilefuncs(N::Int)\n\nPre-compiles functions used by models for a ForwardDiff.Dual numbers with chunk size N.\n\nwarning: Warning\nInternal function. Do not call directly\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.precompilefuncs-Tuple{Any, Any, Any, Int64}","page":"ModelBaseEcon","title":"ModelBaseEcon.precompilefuncs","text":"precompilefuncs(resid, RJ, resid_param, N::Int)\n\nPre-compiles the given resid and RJ functions together with the dual-number arithmetic required by ForwardDiff.\n\nwarning: Warning\nInternal function. Do not call directly\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.process_equation","page":"ModelBaseEcon","title":"ModelBaseEcon.process_equation","text":"process_equation(model::Model, expr; <keyword arguments>)\n\nProcess the given expression in the context of the given model and create an Equation() instance for it.\n\nwarning: Warning\nThis function is for internal use only and should not be called directly.\n\n\n\n\n\n","category":"function"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.setss!-Tuple{ModelBaseEcon.AbstractModel, Expr}","page":"ModelBaseEcon","title":"ModelBaseEcon.setss!","text":"setss!(model::AbstractModel, expr::Expr; type::Symbol, modelmodule::Module)\n\nAdd a steady state equation to the model. Equations added by setss! are in addition to the equations generated automatically from the dynamic system.\n\nwarning: Warning\nThis function is for internal use only and not intended to be called directly by users. Use @steadystate instead of calling this function.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.sseqn_resid_RJ-Tuple{ModelBaseEcon.SSEqnData}","page":"ModelBaseEcon","title":"ModelBaseEcon.sseqn_resid_RJ","text":"sseqn_resid_RJ(sed::SSEqnData)\n\nCreate the eval_resid and eval_RJ for a steady state equation derived from a dynamic equation using information from the given SSEqnData.\n\nwarning: Warning\nThis function is for internal use only and not intended to be called directly by users.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.update_auxvars-Tuple{AbstractMatrix{Float64}, Model}","page":"ModelBaseEcon","title":"ModelBaseEcon.update_auxvars","text":"update_auxvars(point, model; tol=model.tol, default=0.0)\n\nCalculate the values of auxiliary variables from the given values of regular variables and shocks.\n\nAuxiliary variables were introduced as substitutions, e.g. log(expression) was replaced by aux1 and equation was added exp(aux1) = expression, where expression contains regular variables and shocks.\n\nThis function uses the auxiliary equation to compute the value of the auxiliary variable for the given values of other variables. Note that the given values of other variables might be inadmissible, in the sense that expression is negative. If that happens, the auxiliary variable is set to the given default value.\n\nIf the point array does not contain space for the auxiliary variables, it is extended appropriately.\n\nIf there are no auxiliary variables/equations in the model, return a copy of point.\n\nnote: Note\nThe current implementation is specialized only to log substitutions. TODO: implement a general approach that would work for any substitution.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#Options-2","page":"ModelBaseEcon","title":"Options","text":"","category":"section"},{"location":"Reference/ModelBaseEcon/","page":"ModelBaseEcon","title":"ModelBaseEcon","text":"Modules = [ModelBaseEcon.OptionsMod]\nPublic = false","category":"page"},{"location":"Reference/ModelBaseEcon/#Base.merge!-Tuple{Options, Vararg{Options}}","page":"ModelBaseEcon","title":"Base.merge!","text":"merge!(o1::Options, o2::Options...)\n\nUpdate the first argument, adding all options from the remaining arguments. If the same option exists in multiple places, use the last one.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#Base.merge-Tuple{Options, Vararg{Options}}","page":"ModelBaseEcon","title":"Base.merge","text":"merge(o1::Options, o2::Options, ...)\n\nMerge the given Options instances into a new Options instance. If the same option key exists in more than one instance, keep the value from the last one.\n\n\n\n\n\n","category":"method"},{"location":"Reference/ModelBaseEcon/#Timer-2","page":"ModelBaseEcon","title":"Timer","text":"","category":"section"},{"location":"Reference/ModelBaseEcon/","page":"ModelBaseEcon","title":"ModelBaseEcon","text":"Modules = [ModelBaseEcon.Timer]\nPublic = false","category":"page"},{"location":"Reference/ModelBaseEcon/#ModelBaseEcon.Timer.timerData","page":"ModelBaseEcon","title":"ModelBaseEcon.Timer.timerData","text":"timerData\n\nStores timing data.\n\nnote: Note\nFor internal use. Do not modify directly.\n\nIf equal to nothing, timing is disabled. Otherwise, contains a \"database\" of timing data in the  form of a Dict.\n\n\n\n\n\n","category":"constant"},{"location":"Tutorials/4.FRB-US/main/#FRB/US-with-VAR-based-Expectations","page":"FRB/US","title":"FRB/US with VAR-based Expectations","text":"","category":"section"},{"location":"Tutorials/4.FRB-US/main/#Getting-started","page":"FRB/US","title":"Getting started","text":"","category":"section"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"If you wish to run the code of this tutorial, or to experiment for yourself, make sure to follow the instructions in Introduction/Getting_started.","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"using StateSpaceEcon\nusing ModelBaseEcon\nusing TimeSeriesEcon\n\nusing Test\nusing Plots\nusing Random\n\n# Fix the random seed for reproducibility.\nRandom.seed!(1234);\n\n# We need the model file FRBUS_VAR.jl to be on the search path for modules.\nunique!(push!(LOAD_PATH, realpath(\"./models\"))) # hide\n","category":"page"},{"location":"Tutorials/4.FRB-US/main/#The-Model-File","page":"FRB/US","title":"The Model File","text":"","category":"section"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"We recommend placing the model definition in its own Julia module in a separate source file. Although this is not strictly necessary, it helps to keep the code well organized and it also allows us to take advantage of pre-compilation. The first time we load the model file it takes some time to compile, and after that loading is much faster.","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"The FRB/US model we will be working with is located in models/FRBUS_VAR.jl.  This file was automatically generated from the model.xml file contained within frbus_package.zip.","category":"page"},{"location":"Tutorials/4.FRB-US/main/#Some-Notes-About-the-Julia-Model-File","page":"FRB/US","title":"Some Notes About the Julia Model File","text":"","category":"section"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Some variables are declared as log variables using the @log declaration within a @variables block. For example\n@variables model begin\n    # ... #\n    \"Investment in equipment, current \\$\" @log ebfin\n    \"Personal consumption expenditures, current \\$ (NIPA definition)\" @log ecnian\n    # ... #\nend\nA full discussion of log variables is beyond the scope of this tutorial.  However a very simplified explanation is that this improves the stability of  the numerical solver for variables which are always positive.\nVariables which do not have an associated equation, and for which data is always given, are declared exogenous using an @exogenous block. For example\n@exogenous model begin\n    # Exogenous variables:\n    \"Potential government employment ratio (relative to business)\" adjlegrt\n    \"Dummy, post-1979 indicator\" d79a\n    \"Dummy, 1980-1995 indicator\" d8095\n    # ... #\nend\nThe EViews syntax is translated to Julia syntax. EViews functions d() and dlog() are replaced with their equivalent StateSpaceEcon meta functions @d() and @dlog(). EViews @movav() is left alone, because a meta function by the same name already exists in StateSpaceEcon, and does the same thing. Finally, the EViews @recode() is replaced with the equivalent Julia function ifelse(), or where appropriate with a min() or a max().\nSeveral equations contain expressions matching the pattern 1 / (1 + exp(-cx)), where c is a large constant (usually 25) and x is some expression. This sigmoid function is a smooth approximation of the Heaviside step function for large values of c. While mathematically the derivative of this function is well defined and converges to approximately zero everywhere outside a very small interval containing 0, numerically it causes problems because it results in either 0/0 or ∞/∞. To remedy this situation, we replace such patterns with equivalent calls to heaviside(cx), where the function heaviside() is defined in the model file.\nexport heaviside\n\"Heaviside step function\" @inline heaviside(x) = convert(typeof(x), x>zero(x))","category":"page"},{"location":"Tutorials/4.FRB-US/main/#Regenerating-the-Model-File","page":"FRB/US","title":"Regenerating the Model File","text":"","category":"section"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"We have included the script update_models.jl. It is not necessary for running the code below, but it may be helpful for further experimentation.","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"If the model file is missing, for some reason or another, this script will automatically download frbus_package.zip and process the model.xml within it to re-generate model/FRBUS_VAR.jl. This could also be useful if you make modifications to model.xml (including not only the equations, but also the parameter values), or if you want to use a different FRBUS package from the one posted on the FRBUS website. In this case, simply place your frbus_package.zip in the models/ directory and run update_models.jl. Of course such modifications can also be done directly into the existing models/FRBUS_VAR.jl file.","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Note that after updating models/FRBUS_VAR.jl, it'd be best to restart the REPL. The first time you load the new model module it'll take a bit longer due to pre-compilation.","category":"page"},{"location":"Tutorials/4.FRB-US/main/#Load-the-Model","page":"FRB/US","title":"Load the Model","text":"","category":"section"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Assuming that the models/ directory is already in the LOAD_PATH list, we can load the model by using its module. Once loaded, the module contains a variable model which represents the model object.","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"using FRBUS_VAR\nm = FRBUS_VAR.model","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"We see that the model has a number of variables, shocks, equations, and parameters. The total number of variables include exogenous variables.","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"m.variables","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"We also see that the model object includes a number of auxiliary equations. These equations (and variables) are automatically added as substitutions for expressions that must be positive.","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"m.auxeqns","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"For example, we see that variable aux1 was added with the first equation in the above list. At the same time, in equation for dpgap, the expression log(phr[t] * pxp[t]) has been replaced by aux1[t].","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"m.equations[2]","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"A detailed discussion of auxiliary variables and equations is beyond the scope of this tutorial. It suffices to say that we can safely ignore their presence for now.","category":"page"},{"location":"Tutorials/4.FRB-US/main/#Load-the-Longbase-Data","page":"FRB/US","title":"Load the Longbase Data","text":"","category":"section"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Unfortunately the longbase data is loaded from the LONGBASE.TXT file provided in the FRB/US data package. The file is read and parsed via the function defined in load_longbase.jl. Note that this is not a module,  so we load it by calling include(), not using. We have saved a copy of this file as of 2022-11-29, named longbase_2022-11-29.csv","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"include(\"load_longbase.jl\")\nlongbase = load_longbase(\"longbase_2022-11-29.csv\")\n@test size(longbase) == (843, 651) # check size","category":"page"},{"location":"Tutorials/4.FRB-US/main/#Load-set_policy.jl","page":"FRB/US","title":"Load set_policy.jl","text":"","category":"section"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"The model contains a number of switch variables to control which monetary policy function is used and which fiscal policy function is used at each period of the simulation. For convenience, we have included functions set_mp!() and set_fp!(), which are defined in set_policy.jl.","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"include(\"set_policy.jl\")\n@doc set_mp!\n\n# these are the mp switches\ndmp_switches\n\n#  these are their descriptions\nfor s in dmp_switches\n    v = filter(x -> x.name == s, m.variables)[1]\n    println(\"$s : \\t$(v.doc)\")\nend\n\n@doc set_fp!\n\n# these are the fp switches\ndfp_switches\n\n# these are their descriptions\nfor s in dfp_switches\n    v = filter(x -> x.name == s, m.variables)[1]\n    println(\"$s : \\t$(v.doc)\")\nend","category":"page"},{"location":"Tutorials/4.FRB-US/main/#Prepare-the-Simulation-Plan","page":"FRB/US","title":"Prepare the Simulation Plan","text":"","category":"section"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"The simulation is controlled by a Plan object. The plan is defined by a model object and a simulation range. The full range handled by the plan contains additional periods before and after the simulation range, which account for initial and final conditions. By default, the simulation plan is setup such that all shocks are exogenous and all variables are endogenous, except for the variables that are declared either in an @exogenous block or with the @exog declaration within an @variables block in the model file.","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"sim = 2022Q1:2027Q4     # simulation range\np = Plan(m, sim)        # the plan object\n\nini = firstdate(p):first(sim) - 1      # range of initial conditions\nfin = last(sim) + 1:lastdate(p)        # range of final conditions","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Note that the fin range is actually empty. This is because this model doesn't have any leads.","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"isempty(fin)","category":"page"},{"location":"Tutorials/4.FRB-US/main/#Prepare-the-Exogenous-Data","page":"FRB/US","title":"Prepare the Exogenous Data","text":"","category":"section"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"We start by pre-allocating simulation data that is set to 0 everywhere.  Then we assign within it the data from longbase using Julia's .= operator.","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"ed = zerodata(m, p);\ned .= longbase[p.range];","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Next we set the monetary policy, the fiscal policy and a few other switches.","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"# set monetary policy (Inertial Taylor Rule)\nset_mp!(ed, :dmpintay);\n\n# turn off zero bound and policy thresholds;\n# hold policy maker's perceived equilibrium real interest rate\ned.dmptrsh .= 0.0;\ned.rffmin .= -9999;\ned.drstar .= 0.0;\n\n# set fiscal policy (Surplus Ratio Stabilization)\nset_fp!(ed, :dfpsrp);\n\n@test all(sum(abs, ed[dmp_switches], dims=2) .== 1) # hide\n@test all(sum(abs, ed[dfp_switches], dims=2) .== 1) # hide\n","category":"page"},{"location":"Tutorials/4.FRB-US/main/#Back-out-the-Shocks","page":"FRB/US","title":"Back out the Shocks","text":"","category":"section"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"The first simulation test is to compute the shocks given the variable paths from longbase. To do this, we swap the variables and shocks, making variables exogenous and shocks endogenous. The mapping between variables and their corresponding shocks is declared in the model file, so we can simply call autoexogenize!. We make a copy of the plan p, so that the original plan would not be modified. We also make a copy of the exogenous data, ed, so that the original would remain unchanged.","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"p_0 = autoexogenize!(copy(p), m, sim)\ned_0 = copy(ed)","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Now we run the simulate command. Note that the first time we run a function in Julia it takes a bit longer due to compilation time. In this case, it takes much longer because the model is very large and each and every equation gets compiled together with its automatic derivative.","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"sol_0 = @time simulate(m, p_0, ed_0; verbose=true, tol=1e-12);\n@test sol_0[m.variables] ≈ ed[m.variables]","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"The compilation is done once and the compiled code is used in every call after that. So the second call to simulate is much, much faster.","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"sol_0 = @time simulate(m, p_0, ed_0; verbose=true, tol=1e-12);","category":"page"},{"location":"Tutorials/4.FRB-US/main/#Recover-the-Baseline-Case","page":"FRB/US","title":"Recover the Baseline Case","text":"","category":"section"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Next simulation is a sanity check test. If we run a simulation with the shocks set to the values we just backed out, the resulting variable paths must match the ones we started with.","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Once again we start with an exogenous data set everywhere to 0. Then we assign only the initial conditions and the shocks we just backed out.","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"p_r = Plan(m, sim);\ned_r = zerodata(m, p_r);\n\n# initial conditions for the variables are taken from longbase\ned_r[ini, m.variables] .= longbase[ini, m.variables];\n\n# shocks are taken from from sol_0\ned_r[p_r.range, m.shocks] .= sol_0[p_r.range, m.shocks];\n\n# exogenous variables are also taken  from sol_0\nexogenous = [v for v in m.variables if isexog(v)];\ned_r[p_r.range, exogenous] .= sol_0[p_r.range, exogenous];","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Now, the only thing left is to set the initial guess for the endogenous variables. If we leave it at 0, that would be an initial guess too far from the solution and the Newton-Raphson will likely diverge. If we set it to the known solution, that would diminish this exercise to merely verifying that it is indeed a solution (we already know that). So, to make things a bit more interesting, we add a bit of noise to the true solution.","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"endogenous = [v for v in m.variables if !isexog(v)];\ned_r[sim, endogenous] .= longbase[sim, endogenous] .+ 0.03.*randn(length(sim), length(endogenous));","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Once again we have to set the monetary policy and the fiscal policy rules, as well as the values of some of the other switches.","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"set_mp!(ed_r, :dmpintay);\ned_r.dmptrsh .= 0.0;\ned_r.rffmin .= -9999;\ned_r.drstar .= 0.0;\nset_fp!(ed_r, :dfpsrp);","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"And finally we can run the simulation and check to make sure that indeed the recovered simulation matches the base case.","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"sol_r = @time simulate(m, p_r, ed_r; verbose=true, tol=1e-9);\n@test sol_r ≈ sol_0","category":"page"},{"location":"Tutorials/4.FRB-US/main/#Simulate-a-shock","page":"FRB/US","title":"Simulate a shock","text":"","category":"section"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"The last exercise is to simulate the impulse response to a unit shock in rffintay.","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"m.rffintay","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"We start with the base case and add 1 to the rffintay_a shock at the first period of the simulation.","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"p_1 = Plan(m, sim);\ned_1 = copy(sol_0);\n\ned_1.rffintay_a[first(sim)] += 1;\nsol_1 = @time simulate(m, p_1, ed_1; verbose=true, tol=1e-9);\n","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"Finally, we can plot the impulse response function to see what we've done.","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"# compute the differences between the base case and the shocked simulation.\ndd = MVTSeries(p.range; \n    d_rff=sol_1.rff - sol_0.rff,\n    d_rg10=sol_1.rg10 - sol_0.rg10,\n    d_lur=sol_1.lur - sol_0.lur,\n    d_pic4=sol_1.pic4 - sol_0.pic4,\n);\n\n# produce the plot\nplt = plot(dd, trange=sim, vars=(:d_rff, :d_rg10, :d_lur, :d_pic4), \n    legend=false, size=(900, 600),  linewidth=1.5,\n    titlefontsize=8\n);\nplot!(plt[1,1], title=\"d_rff: $(m.rff.doc) (s-c)\");\nplot!(plt[1,2], title=\"d_rg10: $(m.rg10.doc) (s-c)\");\nplot!(plt[2,1], title=\"d_lur: $(m.lur.doc) (s-c)\");\nplot!(plt[2,2], title=\"d_pic4: $(m.pic4.doc) (s-c)\");\nplt","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"savefig(\"irf.png\")","category":"page"},{"location":"Tutorials/4.FRB-US/main/","page":"FRB/US","title":"FRB/US","text":"(Image: Impulse Response Graph)","category":"page"},{"location":"Tutorials/3.US_SW07/main/#Smets-and-Wouters-2007","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"","category":"section"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"You can follow the tutorial by reading this page and copying and pasting code into your Julia REPL session. In this case, you will need the model file, SW07.jl.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"All the code contained here is also available in this file: main.jl.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Pages = [\"main.md\"]\nDepth = 3","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"using StateSpaceEcon\nusing ModelBaseEcon\nusing TimeSeriesEcon\n\nusing Test\nusing Plots\nusing Random\nusing Distributions\n\n# Fix the random seed for reproducibility.\nRandom.seed!(1234);\n\n# We need the model file SW07.jl to be on the search path for modules.\nunique!(push!(LOAD_PATH, realpath(\".\"))) # hide\n","category":"page"},{"location":"Tutorials/3.US_SW07/main/#Part-1:-The-model","page":"Smets and Wouters 2007","title":"Part 1: The model","text":"","category":"section"},{"location":"Tutorials/3.US_SW07/main/#Loading-the-model","page":"Smets and Wouters 2007","title":"Loading the model","text":"","category":"section"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The model is described in its own dedicated module, which is contained in its own file, SW07.jl. We can load the module with using SW07; the model itself is a global variable called model within that module.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"using SW07\nm = SW07.model","category":"page"},{"location":"Tutorials/3.US_SW07/main/#Examining-the-model","page":"Smets and Wouters 2007","title":"Examining the model","text":"","category":"section"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"This model is too big to fit all of its details in the REPL window, so only summary information is displayed. We can see the entire model with fullprint.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"fullprint(m)","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We can also examine individual components using the commands parameters, variables, shocks, equations.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"parameters(m)","category":"page"},{"location":"Tutorials/3.US_SW07/main/#Setting-the-model-parameters","page":"Smets and Wouters 2007","title":"Setting the model parameters","text":"","category":"section"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We must not change any part of the model in the active Julia session except for the model parameters and steady state constraints. If we want to add variables, shocks, or equations, we must do so in the model module file and restart Julia to load the new model.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"When it comes to the model parameters, we can access them by their names from the model object using dot notation.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"m.crr # read a parameter value\nm.cgy = 0.5187 # modify a parameter value","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"note: Note\nIn this model the values of the parameters have been set according to the replication data.","category":"page"},{"location":"Tutorials/3.US_SW07/main/#Model-flags-and-options","page":"Smets and Wouters 2007","title":"Model flags and options","text":"","category":"section"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"In addition to model parameters, which are values that appear in the model equations, the model object also holds two other sets of parameters, namely flags and options.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Flags are (usually boolean) values which characterize the type of model we have. For example, a linear model should have its linear flag set to true. Typically, this is done in the model file before calling @initialize.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"m.flags","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Options are values that adjust the operations of the algorithms. For example, we have tol and maxiter, which set the desired accuracy and maximum number of iterations for the iterative solvers. These can be adjusted as needed at any time. Another useful option is verbose, which controls the level of verbosity of the different commands.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Many functions in StateSpaceEcon have optional arguments of the same name as a model option. When the argument is not explicitly given in the function call, these functions will use the value from the model option of the same name.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"m.verbose = true\nm.options","category":"page"},{"location":"Tutorials/3.US_SW07/main/#Part-2:-The-steady-state-solution","page":"Smets and Wouters 2007","title":"Part 2: The steady state solution","text":"","category":"section"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The steady state is a special solution of the dynamic system that remains constant over time. It is important on its own, but also it can be useful in several ways. For example, linearizing the model requires a particular solution about which to linearize, and the steady state is typically used for this purpose.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"In addition to the steady state, we also consider another kind of special solution which grows linearly in time. If we know that the steady state solution is constant (i.e., its slope is zero), we can set the model flag ssZeroSlope to true. This is not required; however in a large model it might help the steady state solver converge faster to the solution.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The model object m stores information about the steady state. This includes the steady state solution itself, as well as a (possibly empty) set of additional constraints that apply only to the steady state. This information can be accessed via m.sstate.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"m.sstate","category":"page"},{"location":"Tutorials/3.US_SW07/main/#steady_state_constraints","page":"Smets and Wouters 2007","title":"Steady state constraints","text":"","category":"section"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Sometimes the steady state is not unique, and we can use steady state constraints to specify the particular steady state we want. Also, if the model is non-linear, these constraints can be used to help the steady state solver converge. Steady state constraints can be added with the @steadystate macro. The constraint can be as simple as giving a specific value; we can also write an equation with multiple variables. We're allowed to use model parameters in these equations as well.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"@steadystate m a = 5\nm.sstate","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We can clean up the constraints by emptying the constraints container.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"empty!(m.sstate.constraints)\nm.sstate","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"note: Important note\nSteady state constraints that are always valid can be pre-defined in the model file. In that case, all calls to the @steadystate macro must be made after calling @initialize.","category":"page"},{"location":"Tutorials/3.US_SW07/main/#Solving-for-the-steady-state","page":"Smets and Wouters 2007","title":"Solving for the steady state","text":"","category":"section"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The steady state solution is stored within the model object. Before solving, we have to specify an initial condition. If the model is linear, this makes no difference, but in a non-linear model a good or a bad initial guess might be the difference between success and failure of the steady state solver.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We specify the initial guess by calling clear_sstate!. This call removes any previously stored solution, sets the initial guess, and runs the pre-solve pass of the steady state solver. The initial guess can be given with the lvl and slp arguments; if not provided, an initial guess is chosen automatically.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Once that's done, we call sssolve! to find the steady state. This function returns a Vector{Float64} containing the steady state solution, and it also writes that solution into the model object. The vector is of length 2*nvariables(m) and contains the level and the slope for each variable.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"clear_sstate!(m)\nsssolve!(m);","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"If in doubt, we can use check_sstate to make sure the steady state solution stored in the model object indeed satisfies the steady state system of equations. This function returns the number of equations that are not satisfied. A value of 0 is what we want to see. In verbose mode, it also lists the problematic equations and their residuals.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"check_sstate(m)","category":"page"},{"location":"Tutorials/3.US_SW07/main/#Examining-the-steady-state","page":"Smets and Wouters 2007","title":"Examining the steady state","text":"","category":"section"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We can access the steady state solution via m.sstate using the dot notation.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"m.sstate.dc","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We can also assign new values to the steady state solution, but we should be careful to make sure it remains a valid steady state solution.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"m.sstate.dc.level = 0.43121\n@test check_sstate(m) > 0","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"As the code above shows, a wrong steady state solution (based on the specified precision in the tol option) will result in one or more equation not being satisfied. Let's put back the correct value.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"m.sstate.dc.level = 0.4312\n@test check_sstate(m) == 0","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We can examine the entire steady state solution with printsstate.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"printsstate(m)","category":"page"},{"location":"Tutorials/3.US_SW07/main/#Part-3:-Impulse-response","page":"Smets and Wouters 2007","title":"Part 3: Impulse response","text":"","category":"section"},{"location":"Tutorials/3.US_SW07/main/#Simulation-plan","page":"Smets and Wouters 2007","title":"Simulation plan","text":"","category":"section"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Before we can simulate the model, we have to decide on the length of the simulation and what data is available for each period, i.e., what values are known (exogenous). This is done with an object of type Plan.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"To create a plan, all we need is the model object and a range for the simulation.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"sim_rng = 2000Q1:2039Q4\np = Plan(m, sim_rng)","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The plan shows us the list of exogenous values (variable or shocks) for each period or sub-range of the simulation. By default, all shocks are exogenous and all variables are endogenous.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We also see that the range of the plan has been extended before and after the simulation range. This is necessary because we need to set initial and final conditions. The number of periods for initial conditions is equal to the largest lag in the model. Similarly, final conditions have to be imposed over as many periods as the largest lead.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"p.range          # the full range of the plan\ninit_rng = first(p.range):first(sim_rng)-1   # the range for initial conditions\nfinal_rng = last(sim_rng)+1:last(p.range)     # the range for final conditions\n@test length(init_rng) == m.maxlag\n@test length(final_rng) == m.maxlead","category":"page"},{"location":"Tutorials/3.US_SW07/main/#Exogenous-data","page":"Smets and Wouters 2007","title":"Exogenous data","text":"","category":"section"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We have to provide the data for the simulation. We start with all zeros and fill in the external data, which must include initial conditions for all variable and shocks, exogenous values (according to the plan), and possibly final conditions.","category":"page"},{"location":"Tutorials/3.US_SW07/main/#Initial-conditions","page":"Smets and Wouters 2007","title":"Initial conditions","text":"","category":"section"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"In this example, we want to simulate an impulse response, so it makes sense to start from the steady state, so that is what we set as the initial condition. We leave the initial conditions for the shocks at 0.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"exog = zerodata(m, p);\nfor var in variables(m)\n    exog[init_rng, var] .= m.sstate[var].level\nend\nexog","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"tip: Pro tip\nThe above works because the steady state is stationary, i.e., all slopes are zero. If we had a model with linear growth steady state, we could do something like the following (see @rec):for var in variables(m)\n    ss = m.sstate[var]\n    exog[init_rng, var] = ss.level\n    if ss.slope != 0\n        # recursively update by adding the slope each period\n        @rec init_rng[2:end] exog[t, var] = exog[t - 1, var] + ss.slope\n    end\nend","category":"page"},{"location":"Tutorials/3.US_SW07/main/#Final-conditions","page":"Smets and Wouters 2007","title":"Final conditions","text":"","category":"section"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"For the final conditions we can use the steady state again, because we expect that the economy will eventually return to it if the simulation is sufficiently long past the last shock. We can do this by assigning the values of the steady state to the final periods after the simulation, similarly to what we did with the initial conditions.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Alternatively, we can specify that we want to use the steady state in the call to simulate by passing fctype=fclevel. Yet another possibility is to set the final condition so that the solution slope matches the slope of the steady state by setting fctype=fcslope. In both cases, we do not need to set anything in the exogenous data array because those values would be ignored.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"tip: Pro tip\nIn the Smets and Wouters 2007 model the two ways of using the steady state for final conditions (level or slope) are equivalent, because the steady state here is stationary and unique. In models where the steady state has non-zero slope, or the steady state has zero slope but the level is not unique, we should use fctype=fcslope.","category":"page"},{"location":"Tutorials/3.US_SW07/main/#A-quick-sanity-check","page":"Smets and Wouters 2007","title":"A quick sanity check","text":"","category":"section"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"If we were to run a simulation where the economy started in the steady state and there were no shocks at all, we'd expect that the economy would remain in steady state forever.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"ss = simulate(m, p, exog; fctype=fcslope);","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The simulated data, ss, should equal (up to the accuracy of the solution) the steady state data. Similar to zerodata, we can use steadystatedata to create a data set containing the steady state solution.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"@test ss ≈ steadystatedata(m, p)","category":"page"},{"location":"Tutorials/3.US_SW07/main/#Exogenous-data-2","page":"Smets and Wouters 2007","title":"Exogenous data","text":"","category":"section"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"All shocks are exogenous by default. All we have left to do is to set the value of the shock.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Let's say that we want to shock epinf for the first four quarters by 0.1.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"exog[sim_rng[1:4], :epinf] .= 0.1;\nexog[shocks(m)]","category":"page"},{"location":"Tutorials/3.US_SW07/main/#Running-the-simulation","page":"Smets and Wouters 2007","title":"Running the simulation","text":"","category":"section"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We call simulate, providing the model, the exogenous data, and the plan. We also specify the type of final condition we want to impose.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"irf = simulate(m, p, exog; fctype=fcslope);","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We can now take a look at how some of the observable variables in the model have responded to this shock. We use plot from the Plots package to for that. We specify the variables we want to plot using vars and the names of the datasets being plotted (for the legend) in the names option.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"plot(ss, irf,\n     trange=sim_rng,\n     vars=(:pinfobs, :dy, :labobs, :robs),\n     label=[\"SS\" \"IRF\"],\n     legend=[true false false false],\n     size=(900, 600).*0.8,           # hide\n    );","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"savefig(\"irf.png\")","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"(Image: Impulse Response Graph)","category":"page"},{"location":"Tutorials/3.US_SW07/main/#Part-4:-Stochastic-shocks-simulation","page":"Smets and Wouters 2007","title":"Part 4: Stochastic shocks simulation","text":"","category":"section"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Now let's run a simulation with stochastic shocks. We will have random shocks over two years and then have no shocks for several years afterwards to allow time for the economy to return to its steady state.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"sim_rng = 2000Q1:2049Q4      # simulate 50 years starting 2000\nshk_rng = 2004Q1 .+ (0:7)    # shock 8 quarters starting in 2004\np = Plan(m, sim_rng)\ninit_rng = first(p.range):first(sim_rng) - 1\nfinal_rng = last(sim_rng) + 1:last(p.range)\nexog = zerodata(m, p);\nfor v in variables(m)\n    exog[init_rng, v] .= m.sstate[v].level\nend","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The distributions of the shocks are assumed normal with mean zero and standard deviations that have been estimated in the replication data. We use packages Distributions and Random to draw the necessary random values.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"shk_dist = (ea = Normal(0.0, 0.4618),\n            eb = Normal(0.0, 1.8513),\n            eg = Normal(0.0, 0.6090),\n            eqs = Normal(0.0, 0.6017),\n            em = Normal(0.0, 0.2397),\n            epinf = Normal(0.0, 0.1455),\n            ew = Normal(0.0, 0.2089));\nfor (shk, dist) in pairs(shk_dist)\n    exog[shk_rng, shk] .= rand(dist, length(shk_rng))\nend\nexog[shk_rng, shocks(m)]","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Now we are ready to simulate. We can set the shocks to be anticipated or unanticipated by setting the anticipate parameter in simulate.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"sim_a = simulate(m, p, exog; fctype=fcslope, anticipate=true);\nsim_u = simulate(m, p, exog; fctype=fcslope, anticipate=false);","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"As before, we can review the responses of the observed variables to these shocks using plot.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"observed = (:dy, :dc, :dinve, :labobs, :pinfobs, :dw, :robs);\nss = steadystatedata(m, p);\nplot(ss, sim_a, sim_u,\n     trange=sim_rng,\n     vars=observed,\n     label=[\"SS\", \"Anticipated\", \"Unanticipated\"],\n     legend=[true (false for i = 1:6)...],\n     linewidth=1.5,\n     size=(900,600),            # hide\n     xrotation = -20,           # hide\n     xtickfonthalign=:right,    # hide\n     xtickfontvalign=:top,      # hide\n    );","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"savefig(\"stoch_shk.png\")","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"(Image: Stochastic Shock Response Graph)","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We see that when the shocks are anticipated, the variables start to react to them right away; in the unanticipated case, there is no movement until the shocks actually hit.","category":"page"},{"location":"Tutorials/3.US_SW07/main/#Part-5:-Backing-out-historical-shocks","page":"Smets and Wouters 2007","title":"Part 5: Backing out historical shocks","text":"","category":"section"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Now let's pretend that the simulated values are historical data and that we do not know the magnitude of the shocks. We can treat the observed (simulated) values of the variables as known by making them exogenous. At the same time we will make the shocks endogenous, so that we can solve for their values during the simulation.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The \"historic\" (simulated, assumed observed) range is from the first period of the simulation until the last shock in the previous exercise.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"hist_rng = first(sim_rng):last(shk_rng)","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We use exogenize! and endogenize! to set up a plan in which observed variables are exogenous and shocks are endogenous throughout the historic range.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"endogenize!(p, shocks(m), hist_rng);\nexogenize!(p, observed, hist_rng);\np","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"As we can see above, the plan now reflects our intentions.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Finally, we need to set up the exogenous data. This time we do not specify the shocks; instead, we assign the known data for the observed variables for the historic range. We start with initial conditions.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"exog = zerodata(m, p);\nfor v in variables(m)\n    exog[init_rng, v] .= m.sstate[v].level\nend","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"We take the observed data from the simulation above. We show the anticipated version first.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"for v in observed\n    exog[hist_rng, v] .= sim_a[v]\nend\nback_a = simulate(m, p, exog; fctype=fcslope, anticipate=true);","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Now we show the unanticipated case.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"for v in observed\n    exog[hist_rng, v] .= sim_u[v]\nend\nback_u = simulate(m, p, exog; fctype=fcslope, anticipate=false);","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"If we did everything correctly, the shocks we recovered must match exactly the shocks we used when we simulated the \"historical\" data.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"@test sim_a[shocks(m)] ≈ back_a[shocks(m)]\n@test sim_u[shocks(m)] ≈ back_u[shocks(m)]","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Moreover, we must have the unobserved variables match as well. In fact, all the data must match over the entire simulation range.","category":"page"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"@test sim_a ≈ back_a\n@test sim_u ≈ back_u","category":"page"},{"location":"Tutorials/3.US_SW07/main/#Appendix","page":"Smets and Wouters 2007","title":"Appendix","text":"","category":"section"},{"location":"Tutorials/3.US_SW07/main/#replication_data","page":"Smets and Wouters 2007","title":"Replication Data","text":"","category":"section"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"The replication data can be downloaded from http://doi.org/10.3886/E116269V1","category":"page"},{"location":"Tutorials/3.US_SW07/main/#References","page":"Smets and Wouters 2007","title":"References","text":"","category":"section"},{"location":"Tutorials/3.US_SW07/main/","page":"Smets and Wouters 2007","title":"Smets and Wouters 2007","text":"Smets, F., Wouters, R., 2007. Shocks and frictions in US business cycles: A bayesian DSGE approach. The American Economic Review 97(3), 586–606.","category":"page"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon-Reference","page":"StateSpaceEcon","title":"StateSpaceEcon Reference","text":"","category":"section"},{"location":"Reference/StateSpaceEcon/","page":"StateSpaceEcon","title":"StateSpaceEcon","text":"Pages = [\"statespaceecon.md\"]","category":"page"},{"location":"Reference/StateSpaceEcon/#Public-Interface","page":"StateSpaceEcon","title":"Public Interface","text":"","category":"section"},{"location":"Reference/StateSpaceEcon/#Steady-state-solver","page":"StateSpaceEcon","title":"Steady state solver","text":"","category":"section"},{"location":"Reference/StateSpaceEcon/","page":"StateSpaceEcon","title":"StateSpaceEcon","text":"Modules = [StateSpaceEcon.SteadyStateSolver]\nPrivate = false","category":"page"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver","text":"SteadyStateSolver\n\nA module that is part of StateSpaceEcon package. Contains methods for finding a steady state solution of a model.\n\n\n\n\n\n","category":"module"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.check_sstate-Tuple{Model}","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.check_sstate","text":"check_sstate(model; <options>)\n\nRun a diagnostic test to determine if the steady state solution stored within the given model object is indeed a solution of the steady state system of equations.\n\nReturn the number of steady state equations that are violated by the current steady state solution. If verbose=true, also display diagnostic information in the form of listing all bad equations and their residuals.\n\nOptions\n\nStandard options (default values from model.options)\n\nverbose \ntol - an equation is considered satisfied if its residual, in absolute value, is smaller than this number.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.clear_sstate!-Tuple{Model}","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.clear_sstate!","text":"clear_sstate!(model; lvl=0.1, slp=0.0, <options>)\n\nSet the steady state values to the provided defaults and presolve.\n\nArguments\n\nmodel - the model instance\nlvl, slp - the initial guess for the level and the slope. Each could be a number or a vector of length equal to the number of variable in the model. Variables include regular and exogenous variables, but not shocks (shocks are assumed to be 0 in steady state).\n\nOptions\n\nStandard options (default values are taken from model.options)\n\nverbose\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.diagnose_sstate-Tuple{Model}","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.diagnose_sstate","text":"diagnose_sstate([point,] model)\n\nRun diagnostics on the steady state of the given model. If point is not given, then we check the steady state solution stored inside the given model.\n\nReturn a tuple of \"bad\" equations and \"bad\" variables. \n\nThe set of \"bad\" equations is one that is inconsistent, i.e. there is no solution. This might happen if the system is overdetermined.\n\nThe set of \"bad\" variables contains variables that cannot be solved uniquely. This might happen if the system is underdetermined. In this case, try adding steady state constraints until you get a unique solution. See @steadystate in ModelBaseEcon.\n\nwarning: Internal function\nThe output from this function may be difficult to read.<br> Call check_sstate instead.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.initial_sstate!-Tuple{Model, AbstractVector{Float64}}","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.initial_sstate!","text":"initial_sstate!(model, init; <options>)\n\nSet the steady state values from the given vector and presolve.\n\nCall this function to specify initial guesses for the iterative steady state solver. If the value of a steady state variable is known, it is better to use @steadystate to add that as a steady state constraint.\n\nArguments\n\nmodel - the model.\ninit - a vector of length equal to twice the number of variables in the model. The level and slope values are staggered, i.e., the level and slope of variable j are in init[2j-1] and init[2j].\n\nOptions\n\nStandard options (default values are taken from model.options)\n\nverbose\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.sssolve!-Tuple{Model}","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.sssolve!","text":"sssolve!(model; <options>)\n\nSolve the steady state problem for the given model.\n\nOptions\n\nStandard options (default values are taken from model.options)\n\nverbose\ntol, maxiter - control the stopping criteria of the solver\n\nSpecific options\n\npresolve::Bool - whether or not to use a presolve pass. Default is true.\nmethod::Symbol - choose the solution algorithm. Valid options are :nr for Newton-Raphson, :lm for Levenberg-Marquardt, and :auto. The :auto method starts with the LM algorithm and automatically switches to NR when it starts to converge. Default is :nr.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#Stacked-Time-Solver","page":"StateSpaceEcon","title":"Stacked-Time Solver","text":"","category":"section"},{"location":"Reference/StateSpaceEcon/","page":"StateSpaceEcon","title":"StateSpaceEcon","text":"Modules = [StateSpaceEcon.StackedTimeSolver]\nPrivate = false","category":"page"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver","text":"StackedTimeSolver\n\nA module that is part of StateSpaceEcon package. Contains methods for solving the dynamic system of equations for the model and running simulations.\n\n\n\n\n\n","category":"module"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.fcgiven","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.fcgiven","text":"const fcgiven = FCGiven()\n\nUsed when the final conditions are given in the exogenous data.\n\n\n\n\n\n","category":"constant"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.fclevel","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.fclevel","text":"const fclevel = FCMatchSSLevel()\n\nUsed when the final condition is to match the level of the steady state solution.\n\n\n\n\n\n","category":"constant"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.fcnatural","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.fcnatural","text":"const fcnatural = FCConstRate()\n\nUsed when the final condition is a constant slope, but the slope value is unknown.\n\n\n\n\n\n","category":"constant"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.fcnone","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.fcnone","text":"const fcnone = FCNone()\n\nUsed internally for variables without final conditions, such as shocks and exogenous.\n\n\n\n\n\n","category":"constant"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.fcrate","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.fcrate","text":"const fcrate = FCMatchSSRate()\n\nUsed when the final condition is to match the slope of the steady state solution.\n\n\n\n\n\n","category":"constant"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.fcslope","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.fcslope","text":"const fcslope = FCMatchSSRate()\n\nUsed when the final condition is to match the slope of the steady state solution.\n\n\n\n\n\n","category":"constant"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.FCConstRate","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.FCConstRate","text":"struct FCConstRate <: FinalCondition end\n\nFinal condition is such that the variable grows at a\n\n\n\n\n\n","category":"type"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.FCGiven","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.FCGiven","text":"struct FCGiven <: FinalCondition end\n\nFinal conditions are given in the exogenous data.\n\n\n\n\n\n","category":"type"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.FCMatchSSLevel","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.FCMatchSSLevel","text":"struct FCMatchSSLevel <: FinalCondition end\n\nFinal conditions match the level of the steady state.\n\n\n\n\n\n","category":"type"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.FCMatchSSRate","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.FCMatchSSRate","text":"struct FCMatchSSRate <: FinalCondition end\n\nFinal conditions are such that the solution has the same slope (growth rate or rate of change) as the steady state solution.\n\n\n\n\n\n","category":"type"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.FCNone","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.FCNone","text":"struct FCNone <: FinalCondition end\n\nVariables that don't have lags in the model don't need final conditions.\n\n\n\n\n\n","category":"type"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.FinalCondition","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.FinalCondition","text":"abstract type FinalCondition end\n\nAbstract base type for all final conditions\n\n\n\n\n\n","category":"type"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.dictoverlay","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.dictoverlay","text":"dictoverlay(d1, d2)\n\nMerge two dictionaries. Common key where the values are TSeries of the same frequency are overlayed. Otherwise, a common key takes the value of the last Dict containing it.\n\nnote: Deprecation Note\nThis function will be removed. Use TimeSeriesEcon.overlay instead. An important difference is that TimeSeriesEcon.overlay keeps the values from the first argument where the key appears, while dictoverlay keeps it from the last.\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.seriesoverlay","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.seriesoverlay","text":"seriesoverlay(ts1, ts2)\n\nReturn a new TSeries over the full range of both arguments. The overlapping part contains values from the last argument.\n\nnote: Deprecation Note\nThis function will be removed in the future. Use TimeSeriesEcon.overlay instead. Note the important difference that in TimeSeriesEcon.overlay the values in the overlay come from the first series where the value exists, as opposed to seriesoverlay where it was from the last one.\n\nSee also: dictoverlay\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.setfc","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.setfc","text":"setfc(model, fc)\n\nReturn a vector of final conditions for all variables in the model. The final conditions of all variables are set to fc, except shocks and exogenous, which are always fcnone. Use setfc! to update the final condition of individual variable.\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.setfc!","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.setfc!","text":"setfc!(fc_vector, model, variable, new_fc)\n\nUpdate the final condition for the given variable in the given fc_vector to new_fc. The fc_vector is the output of setfc.    \n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#Plans","page":"StateSpaceEcon","title":"Plans","text":"","category":"section"},{"location":"Reference/StateSpaceEcon/","page":"StateSpaceEcon","title":"StateSpaceEcon","text":"Modules = [StateSpaceEcon.Plans]\nPrivate = false","category":"page"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans","text":"Plans\n\nModule part of StateSpaceEcon. This module implements the Plan data structure, which is used in simulations. The plan object contains information about the range of the simulation and which variables and shocks are exogenous or endogenous at each period of the range.\n\nConstructors\n\nPlan(model, range)\n\nModify the plan\n\nexogenize!, endogenize! - make variables exogenous or endogenous\nexog_endo!, endo_exog! - swap exogenous and endogenous variables\nautoexogenize! - exogenize and endogenize variables according to the list in the model\n\n\n\n\n\n","category":"module"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.Plan","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.Plan","text":"Plan{T <: MIT}\n\nA data structure representing the simulation plan. It holds information about the time range of the simulation and which variables/shocks are exogenous at each period.\n\n\n\n\n\n","category":"type"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.Plan-Tuple{Model, AbstractUnitRange}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.Plan","text":"Plan(model, range)\n\nCreate a default simulation plan for the given model over the given range. The range of the plan is augmented to include periods before and after the given range, over which initial and final conditions will be applied.\n\nInstead of a range, one could also pass in a single moment in time (MIT) instance, in which case it is interpreted as a range of length 1.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.autoexogenize!-Tuple{Plan, Model, Any}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.autoexogenize!","text":"autoexogenize!(plan, model, date)\n\nModify the given plan according to the \"autoexogenize\" protocol defined in the given model. All variables in the autoexogenization list become endogenous and their corresponding shocks become exogenous over the given date or range. date can be a moment in time (same frequency as the given plan), a range, an iterable, or a container.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.compare_plans","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.compare_plans","text":"compare_plans(left, right; options)\ncompare_plans(file, left, right; options)\n\nDisplay a comparison of two plans, or save it in a text file.\n\nOptions\n\nalphabetical=false - set to true to sort the variables. By default variables will be listed in the same order as in the left plan.\nexog_mark=\"X\" - a short string (ideally 1 character) to mark exogenous values.\nendo_mark=\"~\" - a short string (ideally 1 character) to mark endogenous values.\nmissing_mark=\".\" - a short string (ideally 1 character) to display when a variable is missing from one of the plans.\ndelim=\" \" - delimiter. Use \",\"` to make it a CSV file.\npagelines=0 - Set to a positive integer to enable pagination. Number is interpreted as the number of lines to repeat the header line (the one with the ranges).\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.count_endo_points","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.count_endo_points","text":"count_endo_points(p::Plan, rng, vars)\n\nCount the number of endogenous points for the given plan over the given range.\n\nExample:\n\ncount_endo_points(p, :, m.shocks)\n\nSee also count_exog_points\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.count_exog_points","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.count_exog_points","text":"count_exog_points(p::Plan, rng, vars)\n\nCount the number of exogenous points for the given plan over the given range.\n\nExample:\n\ncount_exog_points(p, :, m.exogenous)\n\nSee also count_endo_points\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.endo_exog!-Tuple{Plan, Any, Any, Any}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.endo_exog!","text":"endo_exog!(plan, endo_vars, exog_vars, date)\n\nModify the given plan so that the given variables listed in exog_vars will be exogenous and the variables listed in endo_vars will be endogenous on the given dates. exog_vars and endo_vars can each be a Symbol or a String or a Vector of such. date can be a moment in time (same type as the plan), or a range or an iterable or a container.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.endogenize!-Tuple{Plan, Any, Any}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.endogenize!","text":"endogenize!(plan, vars, date)\n\nModify the given plan so that the given variables will be endogenous on the given dates. vars can be a Symbol or a String or a Vector of such. date can be a moment in time (same type as the plan), or a range or an iterable or a container.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.exog_endo!-Tuple{Plan, Any, Any, Any}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.exog_endo!","text":"exog_endo!(plan, exog_vars, endo_vars, date)\n\nModify the given plan so that the given variables listed in exog_vars will be exogenous and the variables listed in endo_vars will be endogenous on the given dates. exog_vars and endo_vars can each be a Symbol or a String or a Vector of such. date can be a moment in time (same type as the plan), or a range or an iterable or a container.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.exogenize!-Tuple{Plan, Any, Any}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.exogenize!","text":"exogenize!(plan, vars, date)\n\nModify the given plan so that the given variables will be exogenous on the given dates. vars can be a Symbol or a String or a Vector of such. date can be a moment in time (same type as the plan), or a range or an iterable or a container.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.exportplan","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.exportplan","text":"exportplan(plan; options)\nexportplan(file, plan; options)\n\nDisplay the plan or save it in a text file.\n\nOptions\n\nalphabetical=false - set to true to sort the variables. By default variables will be listed in the same order as in the model.\nexog_mark=\"X\" - a short string (ideally 1 character) to mark exogenous values.\nendo_mark=\"-\" - a short string (ideally 1 character) to mark endogenous values.\ndelim=\" \" - delimiter. Use \",\"` to make it a CSV file.\n\nSee also importplan\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.importplan","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.importplan","text":"importplan(file)\n\nRead the plan from a text file.\n\nSee also exportplan\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.plansum-Tuple{Model, Plan}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.plansum","text":"plansum(model, plan)\n\nReturn the total number of exogenous variables in the simulation plan. Periods over which initial and final conditions are imposed are not counted in this sum.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.setexog!-Tuple{Plan, Int64, Any}","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.setexog!","text":"setexog!(plan, t, vinds)\n\nModify the plan at time t such that vinds are exogenous and the rest are endogenous.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#Various","page":"StateSpaceEcon","title":"Various","text":"","category":"section"},{"location":"Reference/StateSpaceEcon/","page":"StateSpaceEcon","title":"StateSpaceEcon","text":"Modules = [StateSpaceEcon]\nPrivate = false","category":"page"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StateSpaceEcon","page":"StateSpaceEcon","title":"StateSpaceEcon.StateSpaceEcon","text":"StateSpaceEcon\n\nA package for Macroeconomic modelling.\n\n\n\n\n\n","category":"module"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SimData","page":"StateSpaceEcon","title":"StateSpaceEcon.SimData","text":"SimData\n\nData structure containing the time series data for a simulation.\n\nIt is a collection of TSeries of the same frequency and containing data for the same range. When used for simulation, the range must include the initial conditions, the simulation range and the final conditions, although it could extend beyond that. It must contain time series for all variables and shocks in the model, in the same order as in the model object.\n\n\n\n\n\n","category":"type"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.array2data","page":"StateSpaceEcon","title":"StateSpaceEcon.array2data","text":"array2data(matrix, model, plan; copy=false)\narray2data(matrix, vars, range; copy=false)\n\nConvert a plain matrix with simulation data to a SimData.\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.array2dict","page":"StateSpaceEcon","title":"StateSpaceEcon.array2dict","text":"dict2array, array2dict\ndict2data, data2dict\n\nDeprecated. Use the workspace instead of dict.\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.array2workspace","page":"StateSpaceEcon","title":"StateSpaceEcon.array2workspace","text":"array2workspace(matrix, model, plan; copy=false)\narray2workspace(matrix, vars, range; copy=false)\n\nConvert a plain matrix with simulation data to a Workspace.\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.data2array","page":"StateSpaceEcon","title":"StateSpaceEcon.data2array","text":"data2array(data; copy=false)\ndata2array(data, model, plan; copy=false)\ndata2array(data, vars, range; copy=false)\n\nConvert a SimData to a matrix.\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.data2dict","page":"StateSpaceEcon","title":"StateSpaceEcon.data2dict","text":"dict2array, array2dict\ndict2data, data2dict\n\nDeprecated. Use the workspace instead of dict.\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.data2workspace","page":"StateSpaceEcon","title":"StateSpaceEcon.data2workspace","text":"data2workspace(data; copy=false)\ndata2workspace(data, model, plan; copy=false)\ndata2workspace(data, vars, range; copy=false)\n\nConvert a SimData to a Workspace.\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.dict2array","page":"StateSpaceEcon","title":"StateSpaceEcon.dict2array","text":"dict2array, array2dict\ndict2data, data2dict\n\nDeprecated. Use the workspace instead of dict.\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.dict2data","page":"StateSpaceEcon","title":"StateSpaceEcon.dict2data","text":"dict2array, array2dict\ndict2data, data2dict\n\nDeprecated. Use the workspace instead of dict.\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.printmatrix-Tuple{AbstractMatrix, Vararg{Any}}","page":"StateSpaceEcon","title":"StateSpaceEcon.printmatrix","text":"printmatrix(mat [, Val(F), colnames])\n\nDisplay a matrix in full while controlling the formatting of each value and optionally showing the column names.\n\nVal(F) - display each number in the given format F. The format is in the form of a decimal point number where the whole part indicates the total width and the fractional part indicates the number of digits printed after the decimal point. Default is Val(12.7)\ncolnames - a list of names to display in the first row. The names are displayed as given, possibly with padding to match the width given in the Val argument. If any names are longer than that, they will not be truncated and so the display will not be aligned properly. Sorry about that!\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.shockdecomp","page":"StateSpaceEcon","title":"StateSpaceEcon.shockdecomp","text":"shockdecomp(model, plan, exog_data; control, solver, [options])\n\nCompute the shock decomposition for the given model, plan, exogenous (shocks) data and control solution.\n\nIf the control option is not specified we use the steady state solution stored in the model instance. The algorithm assumes that control is a solution to the dynamic model for the given plan range and final condition. We verify the residual and issue a warning, but do not enforce this. See steadystatedata.\n\nAs part of the algorithm we run a simulation with the given plan, data and solver.  See simulate for additional options that control the simulation.\n\nNote that unlike simulate, here we require exogdata and control to be MVTSeries, i.e. plain Array or Workspace are not allowed. \n\nThe returned value is a Workspace with three things in it: c contains a copy of control, s contains the simulated solution for the given plan and exogdata and sd contains the shock decomposition data. The data in sd is organized as a Workspace containing an MVTSeries for each variable,\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.simulate","page":"StateSpaceEcon","title":"StateSpaceEcon.simulate","text":"simulate(model, plan, data; <options>)\n\nRun a simulation for the given model, simulation plan and exogenous data.\n\nArguments\n\n* `model` - the [`Model`](@ref ModelBaseEcon.Model) instance to simulate.\n* `plan` - the [`Plan`](@ref) for the simulation.\n* `data` - a 2D `Array` containing the exogenous data. This includes the\n    initial and final conditions.\n\nOptions as keyword arguments\n\n* `fctype::`[`FinalCondition`](@ref) - set the desired final condition type\n    for the simulation. The default value is [`fcgiven`](@ref). Other possible\n    values include [`fclevel`](@ref), [`fcslope`](@ref) and\n    [`fcnatural`](@ref).\n* `initial_guess::AbstractMatrix{Float64}` - a 2D `Array` containing the\n    initial guess for the solution. This is used to start the Newton-Raphson\n    algorithm. The default value is an empty array (`zeros(0,0)`), in which case\n    we use the exogenous data for the initial condition. You can use the steady\n    state solution using [`steadystatearray`](@ref).\n* `deviation::Bool` - set to `true` if the `data` is given in deviations from\n    the steady state. In this case the simulation result is also returned as a\n    deviation from the steady state. Default value is `false`.\n* `anticipate::Bool` - set to `false` to instruct the solver that all shocks\n    are unanticipated by the agents. Default value is `true`.\n* `verbose::Bool` - control whether or not to print progress information.\n    Default value is taken from `model.options`.\n* `tol::Float64` - set the desired accuracy. Default value is taken from\n    `model.options`.\n* `maxiter::Int` - algorithm fails if the desired accuracy is not reached\n    within this maximum number of iterations. Default value is taken from\n    `model.options`.\n* `linesearch::Bool` - When `true` the Newton-Raphson is modified to include a\n    search along the descent direction for a sufficient decrease in f. It will\n    do this at each iteration. Default is `false`.\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.solve!","page":"StateSpaceEcon","title":"StateSpaceEcon.solve!","text":"solve!(m::Model; [solver::Symbol])\n\nSolve the given model and update its m.solverdata according to the specified solver.  The solver is specified as a Symbol.  The default is solve=:stackedtime.\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.steadystatearray","page":"StateSpaceEcon","title":"StateSpaceEcon.steadystatearray","text":"steadystatearray(model, plan; [ref=firstdate(plan) + m.maxlag])\n\nCreate a Matrix{Float64} of the proper dimension for a simulation with the given model with the given plan. It is initialized to the steady state.\n\nIn the case of steady state solution that is not stationary (i.e., non-zero slope) use the ref option to specify the period in which the steady state level is given. The default for ref is the first simulation period.\n\nThis function returns a Matrix. We recommend using zerodata, which returns SimData. See also zeroworkspace\n\nnote: Deprecation Note\nzeroarray(model, range) will be removed in future versions. Always create a simulation Plan explicitly.\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.steadystatedata","page":"StateSpaceEcon","title":"StateSpaceEcon.steadystatedata","text":"steadystatedata(model, plan; [ref=firstdate(plan) + m.maxlag))\n\nCreate a SimData for a simulation with the given model and plan. Columns correspond to the model variables and shocks in the correct order. Data is initialized with the steady state.\n\nIn the case of steady state solution that is not stationary (i.e., non-zero slope) use the ref option to specify the period in which the steady state level is given. The default for ref is the first simulation period.\n\nSee also zeroarray and zeroworkspace\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.steadystatedict","page":"StateSpaceEcon","title":"StateSpaceEcon.steadystatedict","text":"steadystatedict(model, plan; [ref=firstdate(plan) + m.maxlag))\n\nnote: Deprecation Note\nThis function will be removed in a future version. Use steadystateworkspace.\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.steadystateworkspace-Tuple{Model, Plan}","page":"StateSpaceEcon","title":"StateSpaceEcon.steadystateworkspace","text":"steadystateworkspace(model, plan; [ref=firstdate(plan) + m.maxlag))\n\nCreate a Workspace containing a TSeries for each variable/shock in the given model. They are initialized to the steady state solution.\n\nIn the case of steady state solution that is not stationary (i.e., non-zero slope) use the ref option to specify the period in which the steady state level is given. The default for ref is the first simulation period.\n\nWe recommend using steadystatedata. See also steadystatearray.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.stoch_simulate","page":"StateSpaceEcon","title":"StateSpaceEcon.stoch_simulate","text":"stoch_simulate(model, plan, baseline, shocks; control, ...)\n\nRun multiple simulations with the given shocks centered about the given control (steady state by default).\n\nThe baseline should span the plan range and must be given in levels ( i.e., option deviation=true is not implemented)\n\nThe shocks can be given as a collection of random realizations, where each realization could be an MVTSeries or a Workspace. Only the shocks should be provided.\n\nAll shock names must be exogenous in the given plan over the range of the given data. The data in control is taken as anticipated and the stochastic realizations are taken as unanticipated and the same plan is used for both components.\n\nCurrently only the case of solver=stackedtime is implemented.\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.workspace2array","page":"StateSpaceEcon","title":"StateSpaceEcon.workspace2array","text":"workspace2array(w, model, plan; copy=false)\nworkspace2array(w, vars, range; copy=false)\n\nConvert a Workspace to a matrix.\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.workspace2data","page":"StateSpaceEcon","title":"StateSpaceEcon.workspace2data","text":"workspace2data(w, model, plan; copy=false)\nworkspace2data(w, vars, plan; copy=false)\n\nConvert a SimData to a Workspace\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.zeroarray","page":"StateSpaceEcon","title":"StateSpaceEcon.zeroarray","text":"zeroarray(model, plan)\n\nCreate a Matrix{Float64} of the proper dimension for a simulation with the given model with the given plan. It is initialized to 0.\n\nThis function returns a Matrix. We recommend using zerodata, which returns SimData. See also zeroworkspace\n\nnote: Deprecation Note\nzeroarray(model, range) will be removed in future versions. Always create a simulation Plan explicitly.\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.zerodata","page":"StateSpaceEcon","title":"StateSpaceEcon.zerodata","text":"zerodata(model, plan)\n\nCreate a SimData for a simulation with the given model and plan. Columns correspond to the model variables and shocks in the correct order. Data is initialized with 0.\n\nSee also zeroarray and zeroworkspace\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.zerodict","page":"StateSpaceEcon","title":"StateSpaceEcon.zerodict","text":"zerodict(model, plan)\n\nnote: Deprecation Note\nThis function will be removed in a future version. Use zeroworkspace.\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.zeroworkspace-Tuple{Model, Plan}","page":"StateSpaceEcon","title":"StateSpaceEcon.zeroworkspace","text":"zeroworkspace(model, plan)\n\nCreate a Workspace containing a TSeries for each variable/shock in the given model. They are initialized to 0.\n\nWe recommend using zerodata for simulations. See also zeroarray.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#Internals","page":"StateSpaceEcon","title":"Internals","text":"","category":"section"},{"location":"Reference/StateSpaceEcon/#Steady-state-solver-2","page":"StateSpaceEcon","title":"Steady state solver","text":"","category":"section"},{"location":"Reference/StateSpaceEcon/","page":"StateSpaceEcon","title":"StateSpaceEcon","text":"Modules = [StateSpaceEcon.SteadyStateSolver]\nPublic = false","category":"page"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.LMData","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.LMData","text":"LMData\n\nA data structure that holds the necessary buffers and internal data for performing a step of the Levenberg–Marquardt algorithm\n\nwarning: Warning\nInternal use. Do not call directly\n\n\n\n\n\n","category":"type"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.LMData-Tuple{Model}","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.LMData","text":"LMData(model)\nLMData(model, sd::SolverData)\n\nMake an instance of the LMData for the given model. If solver data is not also given, then it is used, instead of creating a default SolverData for the model.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.NRData","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.NRData","text":"NRData\n\nA data structure that holds the necessary buffers and internal data for performing a step of the Newton-Raphson algorithm\n\nInternal use. Do not call directly.\n\n\n\n\n\n","category":"type"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.SolverData","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.SolverData","text":"SolverData\n\nA data structure used during the solution of the steady state problem. It contains some current state information and some buffers.\n\nwarning: Warning\nThis is an internal data structure. Do not use directly.\n\nWhy is this necessary?\n\nThe solution of the steady state problem is done in steps:\n\nThe user sets the initial guess. This can be done with either initial_sstate! or clear_sstate!\nPre-solve step. In this step we look for equations that have only one unknown and attempt to solve it. If successful, the unknown is marked as \"solved\" and is not an unknown anymore, also the equation is marked as \"solved\" and is not considered anymore. The process repeats for as long as it keeps solving.\nSolve step. This is where we solve the non-linear system composed of the remaining equations for the remaining variables.\n\nThis data structure keeps track of which unknowns and equations are solved and which remain to be solved. It also holds an indexing map that translates the indexes of the variables and equations we solve for to their original indexes in the full steady state system.\n\nFields\n\npoint - a buffer for the current solution values. Some of these may be presolved, which are kept fixed while solving the system, while the rest are updated during solver iterations. The length equals the total number of steady state variables.\nresid - a buffer for the current residual vector. The entries corresponding to presolved equations would normally be all zeros, while the ones corresponding to \"active\" equations would be updated during solver iterations. Lentgh equals the total number of steady state equations.\nsolve_var - a Boolean vector, same size as point. Value of true means that the unknown is \"active\", while false indicates that it has been pre-solved.\nsolve_eqn - a Boolean vector, same size as resid. Value of true means that the equation is \"active\", while false indicates that it has been pre-solved.\nvars_index - an Integer vector, same length as point. Entries corresponding to pre-solved variables hold zeros. Entries for active vars are numbered sequentially from 1 to nvars\neqns_index - an Integer vector, same length as resid. Presolved equations have a zero here, while active equations are numbered sequentially from 1 to neqns.\n\n\n\n\n\n","category":"type"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.SolverData-Tuple{Model}","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.SolverData","text":"SolverData(model, presolve=Val(false); <options>)\n\nConstruct a SolverData instance from all variables and equations in the model, ignoring anything pre-solved.\n\nOptions\n\nverbose::Bool - if not specified it's taken from the model options.\ntol::Float64 - desired tolerance when checking the residual of presolved equation.\npresolve::Bool - if false, any pre-solved information is ignored and the solver data is set up to solve all equations for all variables.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.bisect!-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, Int64, T}} where T<:AbstractFloat","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.bisect!","text":"bisect!(F, x, i, dF; <options>)\n\nSolve the equation F(x) = 0 for x[i] keeping the other values of x fixed. The input value of x[i] is used as the initial guess and it is updated in place. Other entries of x are not accessed at all. Return true upon success, or false otherwise.\n\nArguments\n\nF - A function that must accept a single argument x, which is an array, and must return the value of F (numeric scalar).\nx - An array.\ni - The index identifying the dimension in which we're solving the problem.\ndF - A numeric value. This must equal the partial derivative of F with respect to x[i] at the input value of x[i]. This value is used to construct the initial interval in which the bisection method will be applied.\n\nOptions\n\nmaxiter = 500 - maximum number of iterations. The default is large (500) because this method sometimes converges slowly.\ntol = 1e-8 - desired tolerance of the solution.\n\nwarning: Warning\nThis is an internal function used by the steady state solver. In the future it might be removed or modified.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.first_step_lm!-Tuple{AbstractVector{Float64}, AbstractVector{Float64}, AbstractVector{Float64}, AbstractMatrix{Float64}, StateSpaceEcon.SteadyStateSolver.LMData}","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.first_step_lm!","text":"first_step_nr!(x, dx, resid, J, lm::LMData; verbose=false)\n\nMake the first step of a Levenberg–Marquardt algorithm. Involves determining the initial trust region. The lm structure and the dx vector would be updated. Vectors x, resid and the matrix J are read-only inputs.\n\nwarning: Warning\nInternal function, do not call directly.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.global_SS_R!-Tuple{AbstractVector{Float64}, AbstractVector{Float64}, Model}","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.global_SS_R!","text":"global_SS_R!(R, point, model::Model)\n\nWhen a model is given, we compute the residual of the entire steady state system.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.global_SS_R!-Tuple{AbstractVector{Float64}, AbstractVector{Float64}, StateSpaceEcon.SteadyStateSolver.SolverData}","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.global_SS_R!","text":"R, J = global_SS_RJ(point, sd::SolverData)\n\nWhen a solver data is given, we compute the residual of the active equations only.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.global_SS_R!-Union{Tuple{EqnIter}, Tuple{AbstractVector{Float64}, AbstractVector{Float64}, EqnIter}} where EqnIter","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.global_SS_R!","text":"global_SS_R!(R, point, equations)\n\nCompute the residual vector of the given set of equations at the given point. The equations argument can be a container whose eltype is SteadyStateEquations. The residual R is updated in place.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.global_SS_RJ-Tuple{AbstractVector{Float64}, StateSpaceEcon.SteadyStateSolver.SolverData}","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.global_SS_RJ","text":"R, J = global_SS_RJ(point, sd::SolverData)\n\nWhen applied to a solver data, computes the residual and Jacobian of the active set of equations with respect to the active set of variables.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.global_SS_RJ-Tuple{Vector{Float64}, Model}","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.global_SS_RJ","text":"R, J = global_SS_RJ(point, model::Model)\n\nWhen a model is given, we compute the residual of the entire steady state system.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.global_SS_RJ-Union{Tuple{EqnIter}, Tuple{AbstractVector{Float64}, EqnIter}} where EqnIter","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.global_SS_RJ","text":"R, J = global_SS_RJ(point, equations)\n\nCompute the residual vector R and the Jacobian matrix of the given set of equations at the given point. The equations argument can be a container whose eltype is SteadyStateEquations.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.newton1!-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, Integer}} where T<:AbstractFloat","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.newton1!","text":"newton1!(F, x, i; <options>)\n\nSolve the equation F(x) = 0 for x[i] keeping the other values of x fixed. The input value of x[i] is used as the initial guess and it is updated in place. Other entries of x are not accessed at all. Return true upon success, or false otherwise.\n\nFunction F\n\nThe function F must accept a single argument x, which is an array, and must return a tuple of two things: the value of F (numeric scalar) and the gradient of F (an array of the same shape as x). Only the i-th index of the gradient array is used.\n\nOptions\n\nmaxiter = 5 - maximum number of iterations. The default is small (5) because the Newton method either converges very fast or doesn't converge at all.\ntol = 1e-8 - desired tolerance of the solution.\n\nNotes\n\nThe tol value is used for a stopping criterion and also for diagnosing problems.\n\nwarning: Warning\nThis is an internal function used by the steady state solver. In the future it might be removed or modified.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.presolve_sstate!","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.presolve_sstate!","text":"presolve_sstate!(model; <options>)\npresolve_sstate!(model, mask, values; <options>)\n\nSolve for the steady state variables that are decoupled from the system, or can be solved by forward substitution.\n\nThis is called automatically by the steady state solver before running its main loop.\n\nArguments\n\nmodel - the Model instance\nmask - a vector of Bool. Defaults to model.sstate.mask\nvalues - a vector of numbers. Defaults to model.sstate.values Caller must specify either both mask and values or neither of them. mask[i] equals true if and only if the i-th steady state value has alredy been solved for.\n\nmask and values are both input and output data to the algorithm. Any values that are successfully presolved are updated in place, and their mask enties are set to true.\n\nOptions\n\nverbose - true or false, whether or not to print diagnostic messages.\ntol - accuracy of the 1d solver.\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.step_lm!-Tuple{AbstractVector{Float64}, AbstractVector{Float64}, AbstractVector{Float64}, AbstractMatrix{Float64}, StateSpaceEcon.SteadyStateSolver.LMData}","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.step_lm!","text":"step_nr!(x, dx, resid, J, lm::LMData; verbose=false)\n\nAttempt a Levenberg–Marquardt step. The lm structure and the dx vector would be updated. Vectors x, resid and the matrix J are read-only inputs.\n\nwarning: Warning\nInternal function, do not call directly.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.step_nr!-Tuple{AbstractVector{Float64}, AbstractVector{Float64}, AbstractVector{Float64}, AbstractMatrix{Float64}, StateSpaceEcon.SteadyStateSolver.NRData}","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.step_nr!","text":"step_nr!(x, dx, resid, J, nr::NRData; verbose=false)\n\nAttempt a Newton-Raphson step. The nr structure and the dx vector would be updated accordingly. Vectors x, resid and the matrix J are read-only inputs.\n\nwarning: Warning\nInternal function, do not call directly.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.SteadyStateSolver.update_auxvars_ss-Tuple{Vector{Float64}, Model}","page":"StateSpaceEcon","title":"StateSpaceEcon.SteadyStateSolver.update_auxvars_ss","text":"update_auxvars_ss(point, model)\n\nThis function is for internal use. Do not call directly.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#Stacked-Time-Solver-2","page":"StateSpaceEcon","title":"Stacked-Time Solver","text":"","category":"section"},{"location":"Reference/StateSpaceEcon/","page":"StateSpaceEcon","title":"StateSpaceEcon","text":"Modules = [StateSpaceEcon.StackedTimeSolver]\nPublic = false","category":"page"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.StackedTimeSolverData","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.StackedTimeSolverData","text":"StackedTimeSolverData\n\nThe data structure used in the stacked time algorithm.\n\n\n\n\n\n","category":"type"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.assign_exog_data!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, StateSpaceEcon.StackedTimeSolver.StackedTimeSolverData}","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.assign_exog_data!","text":"assign_exog_data!(x::Matrix, exog::Matrix, sd::StackedTimeSolverData)\n\nAssign the exogenous points into x according to the plan with which sd was created using  exogenous data from exog.  Also call assign_final_condition!.\n\nwarning: Warning\nInternal function not part of the public interface.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.assign_fc!","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.assign_fc!","text":"assign_fc!(x::Vector, exog::Vector, vind::Int, sd::StackedTimeSolverData, fc::FinalCondition)\n\nApplying the final condition fc for variable with index vind. Exogenous data is provided in exog and stacked time solver data in sd. This function updates the solution vector x in place and returns x.\n\nwarning: Warning\nInternal function not part of the public interface.\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.assign_final_condition!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, StateSpaceEcon.StackedTimeSolver.StackedTimeSolverData}","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.assign_final_condition!","text":"assign_final_condition!(x::Matrix, exog::Matrix, sd::StackedTimeSolver)\n\nAssign the final conditions into x. The final condition types for the different variables of the model  are stored in the the solver data sd. exog is used for fcgiven.\n\nwarning: Warning\nInternal function not part of the public interface.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.assign_update_step!-Tuple{AbstractArray{Float64}, Float64, AbstractArray{Float64}, StateSpaceEcon.StackedTimeSolver.StackedTimeSolverData}","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.assign_update_step!","text":"assign_update_step!(x::Array, lambda, dx, sd::StackedTimeSolverData)\n\nPerform something similar to x = x + lambda * dx, but with the necessary corrections related to final conditions.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.make_BI-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}, AbstractVector{<:AbstractVector{Int64}}}","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.make_BI","text":"make_BI(J, II)\n\nPrepares the BI array for the solver data. Called from the constructor of StackedTimeSolverData.\n\nwarning: Warning\nInternal function not part of the public interface.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.shockdecomp-Tuple{Model, Plan, MVTSeries{F, Float64, C} where {F<:Frequency, C<:AbstractMatrix{Float64}}}","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.shockdecomp","text":"shockdecomp(model, plan, exog_data; control, fctype, [options])\n\nCompute the shock decomposition for the given model, plan, exogenous (shocks) data and control solution.\n\nIf control option is not specified we use the steady state solution stored in the model instance. The algorithm assumes that control is a solution to the dynamic model for the given plan range and final condition. We verify the residual and issue a warning, but do not enforce this. See steadystatedata.\n\nAs part of the algorithm we run a simulation with the given plan,  exog_data and fctype.  See simulate for other options.\n\nnote: Note\nFor now only the case of anticipate=true works. Shock decomp with unanticipated shocks is coming soon.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.sim_nr!","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.sim_nr!","text":"sim_nr!(x, sd, maxiter, tol, verbose [, sparse_solver [, linesearch]])\n\nSolve the simulation problem.\n\nx - the array of data for the simulation. All initial, final and exogenous conditions are already in place.\nsd::AbstractSolverData - the solver data constructed for the simulation problem.\nmaxiter - maximum number of iterations.\ntol - desired accuracy.\nverbose - whether or not to print progress information.\nsparse_solver (optional) - a function called to solve the linear system A x = b for x. Defaults to A\\b\nlinesearch::Bool - When true the Newton-Raphson is modified to include a  search along the descent direction for a sufficient decrease in f. It will  do this at each iteration. Default is false.\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.stackedtime_R!-Tuple{AbstractVector{Float64}, AbstractArray{Float64}, AbstractArray{Float64}, StateSpaceEcon.StackedTimeSolver.StackedTimeSolverData}","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.stackedtime_R!","text":"stackedtime_R!(R::Vector, point::Array, exog::Array, sd::StackedTimeSolverData)\n\nCompute the residual of the stacked time system at the given point. R is updated in place and returned.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.stackedtime_RJ-Tuple{AbstractArray{Float64}, AbstractArray{Float64}, StateSpaceEcon.StackedTimeSolver.StackedTimeSolverData}","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.stackedtime_RJ","text":"R, J = stackedtime_RJ(point::Array, exog::Array, sd::StackedTimeSolverData)\n\nCompute the residual and Jacobian of the stacked time system at the given point.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.update_plan!-Tuple{StateSpaceEcon.StackedTimeSolver.StackedTimeSolverData, Model, Plan}","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.update_plan!","text":"update_plan!(sd::StackedTimeSolverData, model, plan; changed=false)\n\nUpdate the stacked time solver data to reflect the new plan. The new plan must have the same range as the original plan, otherwise the solver data cannot be updated in place.\n\nBy default the data structure is updated only if an actual change in the plan is detected. Setting the changed flag to true forces the update even if the plan seems unchanged. This is necessary only in rare circumstances.\n\nwarning: Warning\nInternal function not part of the public interface.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.StackedTimeSolver.var_CiSc","page":"StateSpaceEcon","title":"StateSpaceEcon.StackedTimeSolver.var_CiSc","text":"var_CiSc(sd::StackedTimeSolverData, var::ModelVariable, fc::FinalCondition)\n\nReturn data related to the correction of the Jacobian matrix needed for the given final condition for the given variable.\n\nwarning: Warning\nInternal function not part of the public interface.\n\n\n\n\n\n","category":"function"},{"location":"Reference/StateSpaceEcon/#Plans-2","page":"StateSpaceEcon","title":"Plans","text":"","category":"section"},{"location":"Reference/StateSpaceEcon/","page":"StateSpaceEcon","title":"StateSpaceEcon","text":"Modules = [StateSpaceEcon.Plans]\nPublic = false","category":"page"},{"location":"Reference/StateSpaceEcon/#StateSpaceEcon.Plans.setplanvalue!-Union{Tuple{T}, Tuple{Plan{T}, Bool, Vector{Symbol}, AbstractUnitRange{T}}} where T<:MIT","page":"StateSpaceEcon","title":"StateSpaceEcon.Plans.setplanvalue!","text":"setplanvalue!(plan, value, vars, range)\nsetplanvalue!(plan, value, vars, date)\nsetplanvalue!(plan, value, vars, dates)\n\nModify the status of the given variable(s) on the given date(s). If value is true then variables become exogenous, otherwise they become endogenous.\n\n\n\n\n\n","category":"method"},{"location":"Reference/StateSpaceEcon/#Various-2","page":"StateSpaceEcon","title":"Various","text":"","category":"section"},{"location":"Reference/StateSpaceEcon/","page":"StateSpaceEcon","title":"StateSpaceEcon","text":"Modules = [StateSpaceEcon]\nPublic = false","category":"page"},{"location":"DesignPapers/#Design-Papers","page":"Design Papers","title":"Design Papers","text":"","category":"section"},{"location":"DesignPapers/","page":"Design Papers","title":"Design Papers","text":"This section contains articles that describe the numerical methods and details about their implementations.","category":"page"},{"location":"#Welcome","page":"Welcome","title":"Welcome","text":"","category":"section"},{"location":"","page":"Welcome","title":"Welcome","text":"This is the official documentation for the StateSpaceEcon collection of Julia packages.","category":"page"},{"location":"","page":"Welcome","title":"Welcome","text":"warning: Under construction\nThis site is incomplete. Many articles that are planned to appear are not yet available. Some articles are still in a draft version. Please check back regularly.","category":"page"},{"location":"Tutorials/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"This section contains a list of tutorials demonstrating the use of StateSpaceEcon group of Julia packages.","category":"page"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"You could read the tutorials on the web - just browse the pages. If you wish to run the tutorial examples and further experiment for yourself, follow the instructions below to install a copy of the Tutorials on your computer.","category":"page"},{"location":"Tutorials/#Getting-started","page":"Introduction","title":"Getting started","text":"","category":"section"},{"location":"Tutorials/#Prerequisites","page":"Introduction","title":"Prerequisites","text":"","category":"section"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"You need a recent version of Julia (v1.0 or later). We also recommend using VSCode and so below we provide the instructions assuming that's the case. To install Julia and VSCode follow the instructions at https://github.com/julia-vscode/julia-vscode#installing-juliavs-codevs-code-julia-extensio","category":"page"},{"location":"Tutorials/#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"Clone either DocsEcon.jl or TutorialsEcon.jl.","category":"page"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"TutorialsEcon.jl is a sub-module of DocsEcon.jl, mounted in scr/Tutorial. If you decide to clone DocsEcon.jl, then you should make sure that you clone it recursively.","category":"page"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"$ git clone --recursive https://github.com/bankofcanada/DocsEcon.jl.git","category":"page"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"If you use VSCode to clone the project, that doesn't happen automatically and you'll see that src/Tutorial directory remains empty. In this case, open a terminal in your DocsEcon.jl directory and run","category":"page"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"$ git submodule init\n$ git submodule update","category":"page"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"After this, you should see the files of TutorialsEcon.jl appear under src/Tutorials.","category":"page"},{"location":"Tutorials/#Initialize-the-environment","page":"Introduction","title":"Initialize the environment","text":"","category":"section"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"Open a Julia REPL in the root directory of your project. Activate the environment in  the current directory and instantiate it.","category":"page"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"julia> ]\npkg> activate .\npkg> instantiate","category":"page"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"Note that if you're working with DocsEcon.jl, there's no need to do this in src/Tutorials, even though that directory contains its own Julia environment. All tutorials would run under the DocsEcon.jl environment just fine. If you find that not to be the case, please open a bug report issue in DocsEcon.jl.","category":"page"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"If you're using VSCode, make sure to set the default Julia environment for the workspace to the one you just instantiated.","category":"page"},{"location":"Tutorials/#Running-a-tutorial","page":"Introduction","title":"Running a tutorial","text":"","category":"section"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"Each tutorial is in its own subdirectory, which is self-contained, meaning that running a tutorial does not depend on files of another tutorial. ","category":"page"},{"location":"Tutorials/","page":"Introduction","title":"Introduction","text":"Each tutorial has a main.jl file, which contains the tutorial code. The code is meant to run in a REPL started in the root directory of the project, which is the default in VSCode. In any case, make sure the currently active environment is the one in the root directory of the project you cloned.","category":"page"}]
}
