<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>StateSpaceEcon · StateSpaceEcon</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="StateSpaceEcon logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">StateSpaceEcon</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../Tutorials/">Introduction</a></li><li><a class="tocitem" href="../../Tutorials/README/">README</a></li><li><a class="tocitem" href="../../Tutorials/1.TimeSeriesEcon/main/">Time Series</a></li><li><a class="tocitem" href="../../Tutorials/2.simple_RBC/main/">Simple RBC Model</a></li><li><a class="tocitem" href="../../Tutorials/3.US_SW07/main/">Smets and Wouters 2007</a></li><li><a class="tocitem" href="../../Tutorials/4.FRB-US/main/">FRB/US</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../TimeSeriesEcon/">TimeSeriesEcon</a></li><li><a class="tocitem" href="../ModelBaseEcon/">ModelBaseEcon</a></li><li class="is-active"><a class="tocitem" href>StateSpaceEcon</a></li><li><a class="tocitem" href="../FAME/">FAME</a></li></ul></li><li><span class="tocitem">Design Papers</span><ul><li><a class="tocitem" href="../../DesignPapers/">Design Papers</a></li><li><a class="tocitem" href="../../DesignPapers/final_conditions/">Final Conditions</a></li><li><a class="tocitem" href="../../DesignPapers/log_variables/">Log-variables</a></li><li><a class="tocitem" href="../../DesignPapers/equation_changes/">Equation Changing Syntax</a></li><li><a class="tocitem" href="../../DesignPapers/frequency_conversions/">Frequency Conversion</a></li></ul></li><li><a class="tocitem" href="../../indexpage/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>StateSpaceEcon</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>StateSpaceEcon</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/bankofcanada/DocsEcon.jl/blob/master/src/Reference/StateSpaceEcon.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="StateSpaceEcon-Reference"><a class="docs-heading-anchor" href="#StateSpaceEcon-Reference">StateSpaceEcon Reference</a><a id="StateSpaceEcon-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#StateSpaceEcon-Reference" title="Permalink"></a></h1><ul></ul><h3 id="Public-Interface"><a class="docs-heading-anchor" href="#Public-Interface">Public Interface</a><a id="Public-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Public-Interface" title="Permalink"></a></h3><h4 id="Steady-state-solver"><a class="docs-heading-anchor" href="#Steady-state-solver">Steady state solver</a><a id="Steady-state-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Steady-state-solver" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver" href="#StateSpaceEcon.SteadyStateSolver"><code>StateSpaceEcon.SteadyStateSolver</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">SteadyStateSolver</code></pre><p>A module that is part of StateSpaceEcon package. Contains methods for finding a steady state solution of a model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.check_sstate-Tuple{Model}" href="#StateSpaceEcon.SteadyStateSolver.check_sstate-Tuple{Model}"><code>StateSpaceEcon.SteadyStateSolver.check_sstate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_sstate(model; &lt;options&gt;)</code></pre><p>Run a diagnostic test to determine if the steady state solution stored within the given model object is indeed a solution of the steady state system of equations.</p><p>Return the number of steady state equations that are violated by the current steady state solution. If <code>verbose=true</code>, also display diagnostic information in the form of listing all bad equations and their residuals.</p><p><strong>Options</strong></p><p>Standard options (default values from <code>model.options</code>)</p><ul><li><code>verbose</code> </li><li><code>tol</code> - an equation is considered satisfied if its residual, in absolute value, is smaller than this number.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.clear_sstate!-Tuple{Model}" href="#StateSpaceEcon.SteadyStateSolver.clear_sstate!-Tuple{Model}"><code>StateSpaceEcon.SteadyStateSolver.clear_sstate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clear_sstate!(model; lvl=0.1, slp=0.0, &lt;options&gt;)</code></pre><p>Set the steady state values to the provided defaults and presolve.</p><p><strong>Arguments</strong></p><ul><li><code>model</code> - the model instance</li><li><code>lvl</code>, <code>slp</code> - the initial guess for the level and the slope. Each could be a number or a vector of length equal to the number of variable in the model. Variables include regular and exogenous variables, but not shocks (shocks are assumed to be 0 in steady state).</li></ul><p><strong>Options</strong></p><p>Standard options (default values are taken from <code>model.options</code>)</p><ul><li><code>verbose</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.diagnose_sstate-Tuple{Model}" href="#StateSpaceEcon.SteadyStateSolver.diagnose_sstate-Tuple{Model}"><code>StateSpaceEcon.SteadyStateSolver.diagnose_sstate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">diagnose_sstate([point,] model)</code></pre><p>Run diagnostics on the steady state of the given model. If <code>point</code> is not given, then we check the steady state solution stored inside the given model.</p><p>Return a tuple of &quot;bad&quot; equations and &quot;bad&quot; variables. </p><p>The set of &quot;bad&quot; equations is one that is inconsistent, i.e. there is no solution. This might happen if the system is overdetermined.</p><p>The set of &quot;bad&quot; variables contains variables that cannot be solved uniquely. This might happen if the system is underdetermined. In this case, try adding steady state constraints until you get a unique solution. See <a href="../ModelBaseEcon/#ModelBaseEcon.@steadystate-Tuple{Any, Symbol, Expr}"><code>@steadystate</code></a> in ModelBaseEcon.</p><div class="admonition is-warning"><header class="admonition-header">Internal function</header><div class="admonition-body"><p>The output from this function may be difficult to read.&lt;br&gt; Call <a href="#StateSpaceEcon.SteadyStateSolver.check_sstate-Tuple{Model}"><code>check_sstate</code></a> instead.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.initial_sstate!-Tuple{Model, AbstractVector{Float64}}" href="#StateSpaceEcon.SteadyStateSolver.initial_sstate!-Tuple{Model, AbstractVector{Float64}}"><code>StateSpaceEcon.SteadyStateSolver.initial_sstate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initial_sstate!(model, init; &lt;options&gt;)</code></pre><p>Set the steady state values from the given vector and presolve.</p><p>Call this function to specify initial guesses for the iterative steady state solver. If the value of a steady state variable is known, it is better to use <a href="../ModelBaseEcon/#ModelBaseEcon.@steadystate-Tuple{Any, Symbol, Expr}"><code>@steadystate</code></a> to add that as a steady state constraint.</p><p><strong>Arguments</strong></p><ul><li><code>model</code> - the model.</li><li><code>init</code> - a vector of length equal to twice the number of variables in the model. The level and slope values are staggered, i.e., the level and slope of variable j are in init[2j-1] and init[2j].</li></ul><p><strong>Options</strong></p><p>Standard options (default values are taken from <code>model.options</code>)</p><ul><li><code>verbose</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.sssolve!-Tuple{Model}" href="#StateSpaceEcon.SteadyStateSolver.sssolve!-Tuple{Model}"><code>StateSpaceEcon.SteadyStateSolver.sssolve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sssolve!(model; &lt;options&gt;)</code></pre><p>Solve the steady state problem for the given model.</p><p><strong>Options</strong></p><p>Standard options (default values are taken from <code>model.options</code>)</p><ul><li><code>verbose</code></li><li><code>tol</code>, <code>maxiter</code> - control the stopping criteria of the solver</li></ul><p>Specific options</p><ul><li><code>presolve::Bool</code> - whether or not to use a presolve pass. Default is <code>true</code>.</li><li><code>method::Symbol</code> - choose the solution algorithm. Valid options are <code>:nr</code> for Newton-Raphson, <code>:lm</code> for Levenberg-Marquardt, and <code>:auto</code>. The <code>:auto</code> method starts with the LM algorithm and automatically switches to NR when it starts to converge. Default is <code>:nr</code>.</li></ul></div></section></article><h4 id="Stacked-Time-Solver"><a class="docs-heading-anchor" href="#Stacked-Time-Solver">Stacked-Time Solver</a><a id="Stacked-Time-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Stacked-Time-Solver" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver" href="#StateSpaceEcon.StackedTimeSolver"><code>StateSpaceEcon.StackedTimeSolver</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">StackedTimeSolver</code></pre><p>A module that is part of StateSpaceEcon package. Contains methods for solving the dynamic system of equations for the model and running simulations.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.fcgiven" href="#StateSpaceEcon.StackedTimeSolver.fcgiven"><code>StateSpaceEcon.StackedTimeSolver.fcgiven</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const fcgiven = FCGiven()</code></pre><p>Used when the final conditions are given in the exogenous data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.fclevel" href="#StateSpaceEcon.StackedTimeSolver.fclevel"><code>StateSpaceEcon.StackedTimeSolver.fclevel</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const fclevel = FCMatchSSLevel()</code></pre><p>Used when the final condition is to match the level of the steady state solution.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.fcnatural" href="#StateSpaceEcon.StackedTimeSolver.fcnatural"><code>StateSpaceEcon.StackedTimeSolver.fcnatural</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const fcnatural = FCConstRate()</code></pre><p>Used when the final condition is a constant slope, but the slope value is unknown.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.fcnone" href="#StateSpaceEcon.StackedTimeSolver.fcnone"><code>StateSpaceEcon.StackedTimeSolver.fcnone</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const fcnone = FCNone()</code></pre><p>Used internally for variables without final conditions, such as shocks and exogenous.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.fcrate" href="#StateSpaceEcon.StackedTimeSolver.fcrate"><code>StateSpaceEcon.StackedTimeSolver.fcrate</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const fcrate = FCMatchSSRate()</code></pre><p>Used when the final condition is to match the slope of the steady state solution.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.fcslope" href="#StateSpaceEcon.StackedTimeSolver.fcslope"><code>StateSpaceEcon.StackedTimeSolver.fcslope</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const fcslope = FCMatchSSRate()</code></pre><p>Used when the final condition is to match the slope of the steady state solution.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.FCConstRate" href="#StateSpaceEcon.StackedTimeSolver.FCConstRate"><code>StateSpaceEcon.StackedTimeSolver.FCConstRate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FCConstRate &lt;: FinalCondition end</code></pre><p>Final condition is such that the variable grows at a</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.FCGiven" href="#StateSpaceEcon.StackedTimeSolver.FCGiven"><code>StateSpaceEcon.StackedTimeSolver.FCGiven</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FCGiven &lt;: FinalCondition end</code></pre><p>Final conditions are given in the exogenous data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.FCMatchSSLevel" href="#StateSpaceEcon.StackedTimeSolver.FCMatchSSLevel"><code>StateSpaceEcon.StackedTimeSolver.FCMatchSSLevel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FCMatchSSLevel &lt;: FinalCondition end</code></pre><p>Final conditions match the level of the steady state.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.FCMatchSSRate" href="#StateSpaceEcon.StackedTimeSolver.FCMatchSSRate"><code>StateSpaceEcon.StackedTimeSolver.FCMatchSSRate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FCMatchSSRate &lt;: FinalCondition end</code></pre><p>Final conditions are such that the solution has the same slope (growth rate or rate of change) as the steady state solution.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.FCNone" href="#StateSpaceEcon.StackedTimeSolver.FCNone"><code>StateSpaceEcon.StackedTimeSolver.FCNone</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct FCNone &lt;: FinalCondition end</code></pre><p>Variables that don&#39;t have lags in the model don&#39;t need final conditions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.FinalCondition" href="#StateSpaceEcon.StackedTimeSolver.FinalCondition"><code>StateSpaceEcon.StackedTimeSolver.FinalCondition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type FinalCondition end</code></pre><p>Abstract base type for all final conditions</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.dictoverlay" href="#StateSpaceEcon.StackedTimeSolver.dictoverlay"><code>StateSpaceEcon.StackedTimeSolver.dictoverlay</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dictoverlay(d1, d2)</code></pre><p>Merge two dictionaries. Common key where the values are <a href="../TimeSeriesEcon/#TimeSeriesEcon.TSeries"><code>TSeries</code></a> of the same frequency are overlayed. Otherwise, a common key takes the value of the last Dict containing it.</p><div class="admonition is-info"><header class="admonition-header">Deprecation Note</header><div class="admonition-body"><p>This function will be removed. Use <a href="../TimeSeriesEcon/#TimeSeriesEcon.overlay"><code>TimeSeriesEcon.overlay</code></a> instead. An important difference is that <a href="../TimeSeriesEcon/#TimeSeriesEcon.overlay"><code>TimeSeriesEcon.overlay</code></a> keeps the values from the first argument where the key appears, while <code>dictoverlay</code> keeps it from the last.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.seriesoverlay" href="#StateSpaceEcon.StackedTimeSolver.seriesoverlay"><code>StateSpaceEcon.StackedTimeSolver.seriesoverlay</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">seriesoverlay(ts1, ts2)</code></pre><p>Return a new <a href="../TimeSeriesEcon/#TimeSeriesEcon.TSeries"><code>TSeries</code></a> over the full range of both arguments. The overlapping part contains values from the last argument.</p><div class="admonition is-info"><header class="admonition-header">Deprecation Note</header><div class="admonition-body"><p>This function will be removed in the future. Use <a href="../TimeSeriesEcon/#TimeSeriesEcon.overlay"><code>TimeSeriesEcon.overlay</code></a> instead. Note the important difference that in <a href="../TimeSeriesEcon/#TimeSeriesEcon.overlay"><code>TimeSeriesEcon.overlay</code></a> the values in the overlay come from the <em>first</em> series where the value exists, as opposed to <code>seriesoverlay</code> where it was from the last one.</p></div></div><p>See also: <a href="#StateSpaceEcon.StackedTimeSolver.dictoverlay"><code>dictoverlay</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.setfc" href="#StateSpaceEcon.StackedTimeSolver.setfc"><code>StateSpaceEcon.StackedTimeSolver.setfc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setfc(model, fc)</code></pre><p>Return a vector of final conditions for all variables in the <code>model</code>. The final conditions of all variables are set to <code>fc</code>, except shocks and exogenous, which are always <code>fcnone</code>. Use <a href="#StateSpaceEcon.StackedTimeSolver.setfc!"><code>setfc!</code></a> to update the final condition of individual variable.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.setfc!" href="#StateSpaceEcon.StackedTimeSolver.setfc!"><code>StateSpaceEcon.StackedTimeSolver.setfc!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setfc!(fc_vector, model, variable, new_fc)</code></pre><p>Update the final condition for the given <code>variable</code> in the given <code>fc_vector</code> to <code>new_fc</code>. The <code>fc_vector</code> is the output of <a href="#StateSpaceEcon.StackedTimeSolver.setfc"><code>setfc</code></a>.    </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.use_pardiso!-Tuple{Model}" href="#StateSpaceEcon.StackedTimeSolver.use_pardiso!-Tuple{Model}"><code>StateSpaceEcon.StackedTimeSolver.use_pardiso!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">use_pardiso!(model)</code></pre><p>Instruct the stacked-time solver to use Pardiso with this model. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.use_pardiso-Tuple{}" href="#StateSpaceEcon.StackedTimeSolver.use_pardiso-Tuple{}"><code>StateSpaceEcon.StackedTimeSolver.use_pardiso</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">use_pardiso()</code></pre><p>Set the default sparse factorization library to Pardiso. See also <a href="#StateSpaceEcon.StackedTimeSolver.use_umfpack-Tuple{}"><code>use_umfpack</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.use_umfpack!-Tuple{Model}" href="#StateSpaceEcon.StackedTimeSolver.use_umfpack!-Tuple{Model}"><code>StateSpaceEcon.StackedTimeSolver.use_umfpack!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">use_umfpack!(model)</code></pre><p>Instruct the stacked-time solver to use Pardiso with this model. See also <a href="#StateSpaceEcon.StackedTimeSolver.use_pardiso!-Tuple{Model}"><code>use_pardiso!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.use_umfpack-Tuple{}" href="#StateSpaceEcon.StackedTimeSolver.use_umfpack-Tuple{}"><code>StateSpaceEcon.StackedTimeSolver.use_umfpack</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">use_umfpack()</code></pre><p>Set the default sparse factorization library to UMFPACK (the one used in Julia&#39;s standard library). See also <a href="#StateSpaceEcon.StackedTimeSolver.use_pardiso-Tuple{}"><code>use_pardiso</code></a>.</p></div></section></article><h4 id="Plans"><a class="docs-heading-anchor" href="#Plans">Plans</a><a id="Plans-1"></a><a class="docs-heading-anchor-permalink" href="#Plans" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans" href="#StateSpaceEcon.Plans"><code>StateSpaceEcon.Plans</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">Plans</code></pre><p>Module part of StateSpaceEcon. This module implements the <code>Plan</code> data structure, which is used in simulations. The plan object contains information about the range of the simulation and which variables and shocks are exogenous or endogenous at each period of the range.</p><p><strong>Constructors</strong></p><ul><li><a href="#StateSpaceEcon.Plans.Plan"><code>Plan(model, range)</code></a></li></ul><p><strong>Modify the plan</strong></p><ul><li><a href="#StateSpaceEcon.Plans.exogenize!-Tuple{Plan, Any, Any}"><code>exogenize!</code></a>, <a href="#StateSpaceEcon.Plans.endogenize!-Tuple{Plan, Any, Any}"><code>endogenize!</code></a> - make variables exogenous or endogenous</li><li><a href="#StateSpaceEcon.Plans.exog_endo!-Tuple{Plan, Any, Any, Any}"><code>exog_endo!</code></a>, <a href="#StateSpaceEcon.Plans.endo_exog!-Tuple{Plan, Any, Any, Any}"><code>endo_exog!</code></a> - swap exogenous and endogenous variables</li><li><a href="#StateSpaceEcon.Plans.autoexogenize!-Tuple{Plan, Model, Any}"><code>autoexogenize!</code></a> - exogenize and endogenize variables according to the list in the model</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.Plan" href="#StateSpaceEcon.Plans.Plan"><code>StateSpaceEcon.Plans.Plan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Plan{T &lt;: MIT}</code></pre><p>A data structure representing the simulation plan. It holds information about the time range of the simulation and which variables/shocks are exogenous at each period.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.Plan-Tuple{Model, AbstractUnitRange}" href="#StateSpaceEcon.Plans.Plan-Tuple{Model, AbstractUnitRange}"><code>StateSpaceEcon.Plans.Plan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Plan(model, range)</code></pre><p>Create a default simulation plan for the given model over the given range. The range of the plan is augmented to include periods before and after the given range, over which initial and final conditions will be applied.</p><p>Instead of a range, one could also pass in a single moment in time (<a href="../TimeSeriesEcon/#TimeSeriesEcon.MIT"><code>MIT</code></a>) instance, in which case it is interpreted as a range of length 1.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.autoexogenize!-Tuple{Plan, Model, Any}" href="#StateSpaceEcon.Plans.autoexogenize!-Tuple{Plan, Model, Any}"><code>StateSpaceEcon.Plans.autoexogenize!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>autoexogenize!(plan, model, date)</p><p>Modify the given plan according to the &quot;autoexogenize&quot; protocol defined in the given model. All variables in the autoexogenization list become endogenous and their corresponding shocks become exogenous over the given date or range. <code>date</code> can be a moment in time (same frequency as the given plan), a range, an iterable, or a container.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.compare_plans" href="#StateSpaceEcon.Plans.compare_plans"><code>StateSpaceEcon.Plans.compare_plans</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compare_plans(left, right; options)
compare_plans(file, left, right; options)</code></pre><p>Display a comparison of two plans, or save it in a text file.</p><p><strong>Options</strong></p><ul><li><code>alphabetical=false</code> - set to <code>true</code> to sort the variables. By default variables will be listed in the same order as in the left plan.</li><li><code>exog_mark=&quot;X&quot;</code> - a short string (ideally 1 character) to mark exogenous values.</li><li><code>endo_mark=&quot;~&quot;</code> - a short string (ideally 1 character) to mark endogenous values.</li><li><code>missing_mark=&quot;.&quot;</code> - a short string (ideally 1 character) to display when a variable is missing from one of the plans.</li><li><code>delim=&quot; &quot;</code> - delimiter. Use <code>&quot;,&quot;</code>` to make it a CSV file.</li><li><code>pagelines=0</code> - Set to a positive integer to enable pagination. Number is interpreted as the number of lines to repeat the header line (the one with the ranges).</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.count_endo_points" href="#StateSpaceEcon.Plans.count_endo_points"><code>StateSpaceEcon.Plans.count_endo_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">count_endo_points(p::Plan, rng, vars)</code></pre><p>Count the number of endogenous points for the given plan over the given range.</p><p>Example:</p><pre><code class="nohighlight hljs">count_endo_points(p, :, m.shocks)</code></pre><p>See also <a href="#StateSpaceEcon.Plans.count_exog_points"><code>count_exog_points</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.count_exog_points" href="#StateSpaceEcon.Plans.count_exog_points"><code>StateSpaceEcon.Plans.count_exog_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">count_exog_points(p::Plan, rng, vars)</code></pre><p>Count the number of exogenous points for the given plan over the given range.</p><p>Example:</p><pre><code class="nohighlight hljs">count_exog_points(p, :, m.exogenous)</code></pre><p>See also <a href="#StateSpaceEcon.Plans.count_endo_points"><code>count_endo_points</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.endo_exog!-Tuple{Plan, Any, Any, Any}" href="#StateSpaceEcon.Plans.endo_exog!-Tuple{Plan, Any, Any, Any}"><code>StateSpaceEcon.Plans.endo_exog!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">endo_exog!(plan, endo_vars, exog_vars, date)</code></pre><p>Modify the given plan so that the given variables listed in <code>exog_vars</code> will be exogenous and the variables listed in <code>endo_vars</code> will be endogenous on the given dates. <code>exog_vars</code> and <code>endo_vars</code> can each be a <code>Symbol</code> or a <code>String</code> or a <code>Vector</code> of such. <code>date</code> can be a moment in time (same type as the plan), or a range or an iterable or a container.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.endogenize!-Tuple{Plan, Any, Any}" href="#StateSpaceEcon.Plans.endogenize!-Tuple{Plan, Any, Any}"><code>StateSpaceEcon.Plans.endogenize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">endogenize!(plan, vars, date)</code></pre><p>Modify the given plan so that the given variables will be endogenous on the given dates. <code>vars</code> can be a <code>Symbol</code> or a <code>String</code> or a <code>Vector</code> of such. <code>date</code> can be a moment in time (same type as the plan), or a range or an iterable or a container.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.exog_endo!-Tuple{Plan, Any, Any, Any}" href="#StateSpaceEcon.Plans.exog_endo!-Tuple{Plan, Any, Any, Any}"><code>StateSpaceEcon.Plans.exog_endo!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exog_endo!(plan, exog_vars, endo_vars, date)</code></pre><p>Modify the given plan so that the given variables listed in <code>exog_vars</code> will be exogenous and the variables listed in <code>endo_vars</code> will be endogenous on the given dates. <code>exog_vars</code> and <code>endo_vars</code> can each be a <code>Symbol</code> or a <code>String</code> or a <code>Vector</code> of such. <code>date</code> can be a moment in time (same type as the plan), or a range or an iterable or a container.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.exogenize!-Tuple{Plan, Any, Any}" href="#StateSpaceEcon.Plans.exogenize!-Tuple{Plan, Any, Any}"><code>StateSpaceEcon.Plans.exogenize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exogenize!(plan, vars, date)</code></pre><p>Modify the given plan so that the given variables will be exogenous on the given dates. <code>vars</code> can be a <code>Symbol</code> or a <code>String</code> or a <code>Vector</code> of such. <code>date</code> can be a moment in time (same type as the plan), or a range or an iterable or a container.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.exportplan" href="#StateSpaceEcon.Plans.exportplan"><code>StateSpaceEcon.Plans.exportplan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">exportplan(plan; options)
exportplan(file, plan; options)</code></pre><p>Display the plan or save it in a text file.</p><p><strong>Options</strong></p><ul><li><code>alphabetical=false</code> - set to <code>true</code> to sort the variables. By default variables will be listed in the same order as in the model.</li><li><code>exog_mark=&quot;X&quot;</code> - a short string (ideally 1 character) to mark exogenous values.</li><li><code>endo_mark=&quot;-&quot;</code> - a short string (ideally 1 character) to mark endogenous values.</li><li><code>delim=&quot; &quot;</code> - delimiter. Use <code>&quot;,&quot;</code>` to make it a CSV file.</li></ul><p>See also <a href="#StateSpaceEcon.Plans.importplan"><code>importplan</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.importplan" href="#StateSpaceEcon.Plans.importplan"><code>StateSpaceEcon.Plans.importplan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">importplan(file)</code></pre><p>Read the plan from a text file.</p><p>See also <a href="#StateSpaceEcon.Plans.exportplan"><code>exportplan</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.plansum-Tuple{Model, Plan}" href="#StateSpaceEcon.Plans.plansum-Tuple{Model, Plan}"><code>StateSpaceEcon.Plans.plansum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plansum(model, plan)</code></pre><p>Return the total number of exogenous variables in the simulation plan. Periods over which initial and final conditions are imposed are not counted in this sum.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.setexog!-Tuple{Plan, Int64, Any}" href="#StateSpaceEcon.Plans.setexog!-Tuple{Plan, Int64, Any}"><code>StateSpaceEcon.Plans.setexog!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setexog!(plan, t, vinds)</code></pre><p>Modify the plan at time t such that <code>vinds</code> are exogenous and the rest are endogenous.</p></div></section></article><h4 id="Various"><a class="docs-heading-anchor" href="#Various">Various</a><a id="Various-1"></a><a class="docs-heading-anchor-permalink" href="#Various" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StateSpaceEcon" href="#StateSpaceEcon.StateSpaceEcon"><code>StateSpaceEcon.StateSpaceEcon</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">StateSpaceEcon</code></pre><p>A package for Macroeconomic modelling.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SimData" href="#StateSpaceEcon.SimData"><code>StateSpaceEcon.SimData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimData</code></pre><p>Data structure containing the time series data for a simulation.</p><p>It is a collection of <a href="../TimeSeriesEcon/#TimeSeriesEcon.TSeries"><code>TSeries</code></a> of the same frequency and containing data for the same range. When used for simulation, the range must include the initial conditions, the simulation range and the final conditions, although it could extend beyond that. It must contain time series for all variables and shocks in the model, in the same order as in the model object.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.array2data" href="#StateSpaceEcon.array2data"><code>StateSpaceEcon.array2data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">array2data(matrix, model, plan; copy=false)
array2data(matrix, vars, range; copy=false)</code></pre><p>Convert a plain matrix with simulation data to a <a href="#StateSpaceEcon.SimData"><code>SimData</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.array2dict" href="#StateSpaceEcon.array2dict"><code>StateSpaceEcon.array2dict</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dict2array, array2dict
dict2data, data2dict</code></pre><p>Deprecated. Use the workspace instead of dict.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.array2workspace" href="#StateSpaceEcon.array2workspace"><code>StateSpaceEcon.array2workspace</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">array2workspace(matrix, model, plan; copy=false)
array2workspace(matrix, vars, range; copy=false)</code></pre><p>Convert a plain matrix with simulation data to a <a href="../TimeSeriesEcon/#TimeSeriesEcon.Workspace"><code>Workspace</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.data2array" href="#StateSpaceEcon.data2array"><code>StateSpaceEcon.data2array</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">data2array(data; copy=false)
data2array(data, model, plan; copy=false)
data2array(data, vars, range; copy=false)</code></pre><p>Convert a <a href="#StateSpaceEcon.SimData"><code>SimData</code></a> to a matrix.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.data2dict" href="#StateSpaceEcon.data2dict"><code>StateSpaceEcon.data2dict</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dict2array, array2dict
dict2data, data2dict</code></pre><p>Deprecated. Use the workspace instead of dict.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.data2workspace" href="#StateSpaceEcon.data2workspace"><code>StateSpaceEcon.data2workspace</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">data2workspace(data; copy=false)
data2workspace(data, model, plan; copy=false)
data2workspace(data, vars, range; copy=false)</code></pre><p>Convert a <a href="#StateSpaceEcon.SimData"><code>SimData</code></a> to a <a href="../TimeSeriesEcon/#TimeSeriesEcon.Workspace"><code>Workspace</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.dict2array" href="#StateSpaceEcon.dict2array"><code>StateSpaceEcon.dict2array</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dict2array, array2dict
dict2data, data2dict</code></pre><p>Deprecated. Use the workspace instead of dict.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.dict2data" href="#StateSpaceEcon.dict2data"><code>StateSpaceEcon.dict2data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dict2array, array2dict
dict2data, data2dict</code></pre><p>Deprecated. Use the workspace instead of dict.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.printmatrix-Tuple{AbstractMatrix, Vararg{Any}}" href="#StateSpaceEcon.printmatrix-Tuple{AbstractMatrix, Vararg{Any}}"><code>StateSpaceEcon.printmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">printmatrix(mat [, Val(F), colnames])</code></pre><p>Display a matrix in full while controlling the formatting of each value and optionally showing the column names.</p><ul><li><code>Val(F)</code> - display each number in the given format <code>F</code>. The format is in the form of a decimal point number where the whole part indicates the total width and the fractional part indicates the number of digits printed after the decimal point. Default is <code>Val(12.7)</code></li><li><code>colnames</code> - a list of names to display in the first row. The names are displayed as given, possibly with padding to match the width given in the <code>Val</code> argument. If any names are longer than that, they will not be truncated and so the display will not be aligned properly. Sorry about that!</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.shockdecomp" href="#StateSpaceEcon.shockdecomp"><code>StateSpaceEcon.shockdecomp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">shockdecomp(model, plan, exog_data; control, solver, [options])</code></pre><p>Compute the shock decomposition for the given model, plan, exogenous (shocks) data and control solution.</p><p>If the <code>control</code> option is not specified we use the steady state solution stored in the model instance. The algorithm assumes that <code>control</code> is a solution to the dynamic model for the given plan range and final condition. We verify the residual and issue a warning, but do not enforce this. See <a href="#StateSpaceEcon.steadystatedata"><code>steadystatedata</code></a>.</p><p>As part of the algorithm we run a simulation with the given plan, data and solver.  See <a href="#StateSpaceEcon.simulate"><code>simulate</code></a> for additional options that control the simulation.</p><p>Note that unlike <a href="#StateSpaceEcon.simulate"><code>simulate</code></a>, here we require <code>exogdata</code> and <code>control</code> to be <code>MVTSeries</code>, i.e. plain <code>Array</code> or <code>Workspace</code> are not allowed. </p><p>The returned value is a <code>Workspace</code> with three things in it: <code>c</code> contains a copy of <code>control</code>, <code>s</code> contains the simulated solution for the given <code>plan</code> and <code>exogdata</code> and <code>sd</code> contains the shock decomposition data. The data in <code>sd</code> is organized as a <code>Workspace</code> containing an <code>MVTSeries</code> for each variable,</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.simulate" href="#StateSpaceEcon.simulate"><code>StateSpaceEcon.simulate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simulate(model, plan, data; &lt;options&gt;)</code></pre><p>Run a simulation for the given model, simulation plan and exogenous data.</p><p><strong>Arguments</strong></p><pre><code class="nohighlight hljs">* `model` - the [`Model`](@ref ModelBaseEcon.Model) instance to simulate.
* `plan` - the [`Plan`](@ref) for the simulation.
* `data` - a 2D `Array` containing the exogenous data. This includes the
    initial and final conditions.</code></pre><p><strong>Options as keyword arguments</strong></p><pre><code class="nohighlight hljs">* `fctype::`[`FinalCondition`](@ref) - set the desired final condition type
    for the simulation. The default value is [`fcgiven`](@ref). Other possible
    values include [`fclevel`](@ref), [`fcslope`](@ref) and
    [`fcnatural`](@ref).
* `initial_guess::AbstractMatrix{Float64}` - a 2D `Array` containing the
    initial guess for the solution. This is used to start the Newton-Raphson
    algorithm. The default value is an empty array (`zeros(0,0)`), in which case
    we use the exogenous data for the initial condition. You can use the steady
    state solution using [`steadystatearray`](@ref).
* `deviation::Bool` - set to `true` if the `data` is given in deviations from
    the steady state. In this case the simulation result is also returned as a
    deviation from the steady state. Default value is `false`.
* `anticipate::Bool` - set to `false` to instruct the solver that all shocks
    are unanticipated by the agents. Default value is `true`.
* `verbose::Bool` - control whether or not to print progress information.
    Default value is taken from `model.options`.
* `tol::Float64` - set the desired accuracy. Default value is taken from
    `model.options`.
* `maxiter::Int` - algorithm fails if the desired accuracy is not reached
    within this maximum number of iterations. Default value is taken from
    `model.options`.
* `linesearch::Bool` - When `true` the Newton-Raphson is modified to include a
    search along the descent direction for a sufficient decrease in f. It will
    do this at each iteration. Default is `false`.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.solve!" href="#StateSpaceEcon.solve!"><code>StateSpaceEcon.solve!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solve!(m::Model; [solver::Symbol])</code></pre><p>Solve the given model and update its <code>m.solverdata</code> according to the specified solver.  The solver is specified as a <code>Symbol</code>.  The default is <code>solve=:stackedtime</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.steadystatearray" href="#StateSpaceEcon.steadystatearray"><code>StateSpaceEcon.steadystatearray</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steadystatearray(model, plan; [ref=firstdate(plan) + m.maxlag])</code></pre><p>Create a <code>Matrix{Float64}</code> of the proper dimension for a simulation with the given model with the given plan. It is initialized to the steady state.</p><p>In the case of steady state solution that is not stationary (i.e., non-zero slope) use the <code>ref</code> option to specify the period in which the steady state level is given. The default for <code>ref</code> is the first simulation period.</p><p>This function returns a <code>Matrix</code>. We recommend using <a href="#StateSpaceEcon.zerodata"><code>zerodata</code></a>, which returns <a href="#StateSpaceEcon.SimData"><code>SimData</code></a>. See also <a href="#StateSpaceEcon.zeroworkspace-Tuple{Model, Plan}"><code>zeroworkspace</code></a></p><div class="admonition is-info"><header class="admonition-header">Deprecation Note</header><div class="admonition-body"><p><code>zeroarray(model, range)</code> will be removed in future versions. Always create a simulation <code>Plan</code> explicitly.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.steadystatedata" href="#StateSpaceEcon.steadystatedata"><code>StateSpaceEcon.steadystatedata</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steadystatedata(model, plan; [ref=firstdate(plan) + m.maxlag))</code></pre><p>Create a <a href="#StateSpaceEcon.SimData"><code>SimData</code></a> for a simulation with the given <code>model</code> and <code>plan</code>. Columns correspond to the model variables and shocks in the correct order. Data is initialized with the steady state.</p><p>In the case of steady state solution that is not stationary (i.e., non-zero slope) use the <code>ref</code> option to specify the period in which the steady state level is given. The default for <code>ref</code> is the first simulation period.</p><p>See also <a href="#StateSpaceEcon.zeroarray"><code>zeroarray</code></a> and <a href="#StateSpaceEcon.zeroworkspace-Tuple{Model, Plan}"><code>zeroworkspace</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.steadystatedict" href="#StateSpaceEcon.steadystatedict"><code>StateSpaceEcon.steadystatedict</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">steadystatedict(model, plan; [ref=firstdate(plan) + m.maxlag))</code></pre><div class="admonition is-info"><header class="admonition-header">Deprecation Note</header><div class="admonition-body"><p>This function will be removed in a future version. Use <a href="#StateSpaceEcon.steadystateworkspace-Tuple{Model, Plan}"><code>steadystateworkspace</code></a>.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.steadystateworkspace-Tuple{Model, Plan}" href="#StateSpaceEcon.steadystateworkspace-Tuple{Model, Plan}"><code>StateSpaceEcon.steadystateworkspace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">steadystateworkspace(model, plan; [ref=firstdate(plan) + m.maxlag))</code></pre><p>Create a <a href="../TimeSeriesEcon/#TimeSeriesEcon.Workspace"><code>Workspace</code></a> containing a <a href="../TimeSeriesEcon/#TimeSeriesEcon.TSeries"><code>TSeries</code></a> for each variable/shock in the given <code>model</code>. They are initialized to the steady state solution.</p><p>In the case of steady state solution that is not stationary (i.e., non-zero slope) use the <code>ref</code> option to specify the period in which the steady state level is given. The default for <code>ref</code> is the first simulation period.</p><p>We recommend using <a href="#StateSpaceEcon.steadystatedata"><code>steadystatedata</code></a>. See also <a href="#StateSpaceEcon.steadystatearray"><code>steadystatearray</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.stoch_simulate" href="#StateSpaceEcon.stoch_simulate"><code>StateSpaceEcon.stoch_simulate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stoch_simulate(model, plan, baseline, shocks; control, ...)</code></pre><p>Run multiple simulations with the given shocks centered about the given control (steady state by default).</p><p>The baseline should span the plan range and must be given in levels ( i.e., option deviation=true is not implemented)</p><p>The shocks can be given as a collection of random realizations, where each realization could be an MVTSeries or a Workspace. Only the shocks should be provided.</p><p>All shock names must be exogenous in the given plan over the range of the given data. The data in <code>control</code> is taken as anticipated and the stochastic realizations are taken as unanticipated and the same plan is used for both components.</p><p>Currently only the case of <code>solver=stackedtime</code> is implemented.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.workspace2array" href="#StateSpaceEcon.workspace2array"><code>StateSpaceEcon.workspace2array</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">workspace2array(w, model, plan; copy=false)
workspace2array(w, vars, range; copy=false)</code></pre><p>Convert a <a href="../TimeSeriesEcon/#TimeSeriesEcon.Workspace"><code>Workspace</code></a> to a matrix.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.workspace2data" href="#StateSpaceEcon.workspace2data"><code>StateSpaceEcon.workspace2data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">workspace2data(w, model, plan; copy=false)
workspace2data(w, vars, plan; copy=false)</code></pre><p>Convert a <a href="#StateSpaceEcon.SimData"><code>SimData</code></a> to a <a href="../TimeSeriesEcon/#TimeSeriesEcon.Workspace"><code>Workspace</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.zeroarray" href="#StateSpaceEcon.zeroarray"><code>StateSpaceEcon.zeroarray</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">zeroarray(model, plan)</code></pre><p>Create a <code>Matrix{Float64}</code> of the proper dimension for a simulation with the given model with the given plan. It is initialized to 0.</p><p>This function returns a <code>Matrix</code>. We recommend using <a href="#StateSpaceEcon.zerodata"><code>zerodata</code></a>, which returns <a href="#StateSpaceEcon.SimData"><code>SimData</code></a>. See also <a href="#StateSpaceEcon.zeroworkspace-Tuple{Model, Plan}"><code>zeroworkspace</code></a></p><div class="admonition is-info"><header class="admonition-header">Deprecation Note</header><div class="admonition-body"><p><code>zeroarray(model, range)</code> will be removed in future versions. Always create a simulation <code>Plan</code> explicitly.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.zerodata" href="#StateSpaceEcon.zerodata"><code>StateSpaceEcon.zerodata</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">zerodata(model, plan)</code></pre><p>Create a <a href="#StateSpaceEcon.SimData"><code>SimData</code></a> for a simulation with the given <code>model</code> and <code>plan</code>. Columns correspond to the model variables and shocks in the correct order. Data is initialized with 0.</p><p>See also <a href="#StateSpaceEcon.zeroarray"><code>zeroarray</code></a> and <a href="#StateSpaceEcon.zeroworkspace-Tuple{Model, Plan}"><code>zeroworkspace</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.zerodict" href="#StateSpaceEcon.zerodict"><code>StateSpaceEcon.zerodict</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">zerodict(model, plan)</code></pre><div class="admonition is-info"><header class="admonition-header">Deprecation Note</header><div class="admonition-body"><p>This function will be removed in a future version. Use <a href="#StateSpaceEcon.zeroworkspace-Tuple{Model, Plan}"><code>zeroworkspace</code></a>.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.zeroworkspace-Tuple{Model, Plan}" href="#StateSpaceEcon.zeroworkspace-Tuple{Model, Plan}"><code>StateSpaceEcon.zeroworkspace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zeroworkspace(model, plan)</code></pre><p>Create a <a href="../TimeSeriesEcon/#TimeSeriesEcon.Workspace"><code>Workspace</code></a> containing a <a href="../TimeSeriesEcon/#TimeSeriesEcon.TSeries"><code>TSeries</code></a> for each variable/shock in the given <code>model</code>. They are initialized to 0.</p><p>We recommend using <a href="#StateSpaceEcon.zerodata"><code>zerodata</code></a> for simulations. See also <a href="#StateSpaceEcon.zeroarray"><code>zeroarray</code></a>.</p></div></section></article><h3 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h3><h4 id="Steady-state-solver-2"><a class="docs-heading-anchor" href="#Steady-state-solver-2">Steady state solver</a><a class="docs-heading-anchor-permalink" href="#Steady-state-solver-2" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.LMData" href="#StateSpaceEcon.SteadyStateSolver.LMData"><code>StateSpaceEcon.SteadyStateSolver.LMData</code></a> — <span class="docstring-category">Type</span></header><section><div><p>LMData</p><p>A data structure that holds the necessary buffers and internal data for performing a step of the Levenberg–Marquardt algorithm</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Internal use. Do not call directly</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.LMData-Tuple{Model}" href="#StateSpaceEcon.SteadyStateSolver.LMData-Tuple{Model}"><code>StateSpaceEcon.SteadyStateSolver.LMData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LMData(model)
LMData(model, sd::SolverData)</code></pre><p>Make an instance of the LMData for the given model. If solver data is not also given, then it is used, instead of creating a default SolverData for the model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.NRData" href="#StateSpaceEcon.SteadyStateSolver.NRData"><code>StateSpaceEcon.SteadyStateSolver.NRData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NRData</code></pre><p>A data structure that holds the necessary buffers and internal data for performing a step of the Newton-Raphson algorithm</p><p>Internal use. Do not call directly.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.SolverData" href="#StateSpaceEcon.SteadyStateSolver.SolverData"><code>StateSpaceEcon.SteadyStateSolver.SolverData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SolverData</code></pre><p>A data structure used during the solution of the steady state problem. It contains some current state information and some buffers.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This is an internal data structure. Do not use directly.</p></div></div><p><strong>Why is this necessary?</strong></p><p>The solution of the steady state problem is done in steps:</p><ol><li>The user sets the initial guess. This can be done with either <code>initial_sstate!</code> or <code>clear_sstate!</code></li><li>Pre-solve step. In this step we look for equations that have only one unknown and attempt to solve it. If successful, the unknown is marked as &quot;solved&quot; and is not an unknown anymore, also the equation is marked as &quot;solved&quot; and is not considered anymore. The process repeats for as long as it keeps solving.</li><li>Solve step. This is where we solve the non-linear system composed of the remaining equations for the remaining variables.</li></ol><p>This data structure keeps track of which unknowns and equations are solved and which remain to be solved. It also holds an indexing map that translates the indexes of the variables and equations we solve for to their original indexes in the full steady state system.</p><p><strong>Fields</strong></p><ul><li><code>point</code> - a buffer for the current solution values. Some of these may be presolved, which are kept fixed while solving the system, while the rest are updated during solver iterations. The length equals the total number of steady state variables.</li><li><code>resid</code> - a buffer for the current residual vector. The entries corresponding to presolved equations would normally be all zeros, while the ones corresponding to &quot;active&quot; equations would be updated during solver iterations. Lentgh equals the total number of steady state equations.</li><li><code>solve_var</code> - a Boolean vector, same size as <code>point</code>. Value of <code>true</code> means that the unknown is &quot;active&quot;, while <code>false</code> indicates that it has been pre-solved.</li><li><code>solve_eqn</code> - a Boolean vector, same size as <code>resid</code>. Value of <code>true</code> means that the equation is &quot;active&quot;, while <code>false</code> indicates that it has been pre-solved.</li><li><code>vars_index</code> - an Integer vector, same length as <code>point</code>. Entries corresponding to pre-solved variables hold zeros. Entries for active vars are numbered sequentially from 1 to <code>nvars</code></li><li><code>eqns_index</code> - an Integer vector, same length as <code>resid</code>. Presolved equations have a zero here, while active equations are numbered sequentially from 1 to <code>neqns</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.SolverData-Tuple{Model}" href="#StateSpaceEcon.SteadyStateSolver.SolverData-Tuple{Model}"><code>StateSpaceEcon.SteadyStateSolver.SolverData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SolverData(model, presolve=Val(false); &lt;options&gt;)</code></pre><p>Construct a SolverData instance from all variables and equations in the model, ignoring anything pre-solved.</p><p><strong>Options</strong></p><ul><li><code>verbose::Bool</code> - if not specified it&#39;s taken from the model options.</li><li><code>tol::Float64</code> - desired tolerance when checking the residual of presolved equation.</li><li><code>presolve::Bool</code> - if <code>false</code>, any pre-solved information is ignored and the solver data is set up to solve all equations for all variables.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.bisect!-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, Int64, T}} where T&lt;:AbstractFloat" href="#StateSpaceEcon.SteadyStateSolver.bisect!-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, Int64, T}} where T&lt;:AbstractFloat"><code>StateSpaceEcon.SteadyStateSolver.bisect!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bisect!(F, x, i, dF; &lt;options&gt;)</code></pre><p>Solve the equation <code>F(x) = 0</code> for <code>x[i]</code> keeping the other values of <code>x</code> fixed. The input value of <code>x[i]</code> is used as the initial guess and it is updated in place. Other entries of <code>x</code> are not accessed at all. Return <code>true</code> upon success, or <code>false</code> otherwise.</p><p><strong>Arguments</strong></p><ul><li><code>F</code> - A function that must accept a single argument <code>x</code>, which is an array, and must return the value of <code>F</code> (numeric scalar).</li><li><code>x</code> - An array.</li><li><code>i</code> - The index identifying the dimension in which we&#39;re solving the problem.</li><li><code>dF</code> - A numeric value. This must equal the partial derivative of F with respect to <code>x[i]</code> at the input value of <code>x[i]</code>. This value is used to construct the initial interval in which the bisection method will be applied.</li></ul><p><strong>Options</strong></p><ul><li><code>maxiter = 500</code> - maximum number of iterations. The default is large (500) because this method sometimes converges slowly.</li><li><code>tol = 1e-8</code> - desired tolerance of the solution.</li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This is an internal function used by the steady state solver. In the future it might be removed or modified.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.first_step_lm!-Tuple{AbstractVector{Float64}, AbstractVector{Float64}, AbstractVector{Float64}, AbstractMatrix{Float64}, StateSpaceEcon.SteadyStateSolver.LMData}" href="#StateSpaceEcon.SteadyStateSolver.first_step_lm!-Tuple{AbstractVector{Float64}, AbstractVector{Float64}, AbstractVector{Float64}, AbstractMatrix{Float64}, StateSpaceEcon.SteadyStateSolver.LMData}"><code>StateSpaceEcon.SteadyStateSolver.first_step_lm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">first_step_nr!(x, dx, resid, J, lm::LMData; verbose=false)</code></pre><p>Make the first step of a Levenberg–Marquardt algorithm. Involves determining the initial trust region. The <code>lm</code> structure and the <code>dx</code> vector would be updated. Vectors <code>x</code>, <code>resid</code> and the matrix <code>J</code> are read-only inputs.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Internal function, do not call directly.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.global_SS_R!-Tuple{AbstractVector{Float64}, AbstractVector{Float64}, Model}" href="#StateSpaceEcon.SteadyStateSolver.global_SS_R!-Tuple{AbstractVector{Float64}, AbstractVector{Float64}, Model}"><code>StateSpaceEcon.SteadyStateSolver.global_SS_R!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">global_SS_R!(R, point, model::Model)</code></pre><p>When a model is given, we compute the residual of the entire steady state system.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.global_SS_R!-Tuple{AbstractVector{Float64}, AbstractVector{Float64}, StateSpaceEcon.SteadyStateSolver.SolverData}" href="#StateSpaceEcon.SteadyStateSolver.global_SS_R!-Tuple{AbstractVector{Float64}, AbstractVector{Float64}, StateSpaceEcon.SteadyStateSolver.SolverData}"><code>StateSpaceEcon.SteadyStateSolver.global_SS_R!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">R, J = global_SS_RJ(point, sd::SolverData)</code></pre><p>When a solver data is given, we compute the residual of the active equations only.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.global_SS_R!-Union{Tuple{EqnIter}, Tuple{AbstractVector{Float64}, AbstractVector{Float64}, EqnIter}} where EqnIter" href="#StateSpaceEcon.SteadyStateSolver.global_SS_R!-Union{Tuple{EqnIter}, Tuple{AbstractVector{Float64}, AbstractVector{Float64}, EqnIter}} where EqnIter"><code>StateSpaceEcon.SteadyStateSolver.global_SS_R!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">global_SS_R!(R, point, equations)</code></pre><p>Compute the residual vector of the given set of equations at the given point. The <code>equations</code> argument can be a container whose <code>eltype</code> is <code>SteadyStateEquations</code>. The residual <code>R</code> is updated in place.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.global_SS_RJ-Tuple{AbstractVector{Float64}, StateSpaceEcon.SteadyStateSolver.SolverData}" href="#StateSpaceEcon.SteadyStateSolver.global_SS_RJ-Tuple{AbstractVector{Float64}, StateSpaceEcon.SteadyStateSolver.SolverData}"><code>StateSpaceEcon.SteadyStateSolver.global_SS_RJ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">R, J = global_SS_RJ(point, sd::SolverData)</code></pre><p>When applied to a solver data, computes the residual and Jacobian of the active set of equations with respect to the active set of variables.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.global_SS_RJ-Tuple{Vector{Float64}, Model}" href="#StateSpaceEcon.SteadyStateSolver.global_SS_RJ-Tuple{Vector{Float64}, Model}"><code>StateSpaceEcon.SteadyStateSolver.global_SS_RJ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">R, J = global_SS_RJ(point, model::Model)</code></pre><p>When a model is given, we compute the residual of the entire steady state system.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.global_SS_RJ-Union{Tuple{EqnIter}, Tuple{AbstractVector{Float64}, EqnIter}} where EqnIter" href="#StateSpaceEcon.SteadyStateSolver.global_SS_RJ-Union{Tuple{EqnIter}, Tuple{AbstractVector{Float64}, EqnIter}} where EqnIter"><code>StateSpaceEcon.SteadyStateSolver.global_SS_RJ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">R, J = global_SS_RJ(point, equations)</code></pre><p>Compute the residual vector <code>R</code> and the Jacobian matrix of the given set of equations at the given point. The <code>equations</code> argument can be a container whose <code>eltype</code> is <code>SteadyStateEquations</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.newton1!-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, Integer}} where T&lt;:AbstractFloat" href="#StateSpaceEcon.SteadyStateSolver.newton1!-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, Integer}} where T&lt;:AbstractFloat"><code>StateSpaceEcon.SteadyStateSolver.newton1!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">newton1!(F, x, i; &lt;options&gt;)</code></pre><p>Solve the equation <code>F(x) = 0</code> for <code>x[i]</code> keeping the other values of <code>x</code> fixed. The input value of <code>x[i]</code> is used as the initial guess and it is updated in place. Other entries of <code>x</code> are not accessed at all. Return <code>true</code> upon success, or <code>false</code> otherwise.</p><p><strong>Function <code>F</code></strong></p><p>The function <code>F</code> must accept a single argument <code>x</code>, which is an array, and must return a tuple of two things: the value of <code>F</code> (numeric scalar) and the gradient of <code>F</code> (an array of the same shape as x). Only the i-th index of the gradient array is used.</p><p><strong>Options</strong></p><ul><li><code>maxiter = 5</code> - maximum number of iterations. The default is small (5) because the Newton method either converges very fast or doesn&#39;t converge at all.</li><li><code>tol = 1e-8</code> - desired tolerance of the solution.</li></ul><p><strong>Notes</strong></p><p>The <code>tol</code> value is used for a stopping criterion and also for diagnosing problems.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This is an internal function used by the steady state solver. In the future it might be removed or modified.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.presolve_sstate!" href="#StateSpaceEcon.SteadyStateSolver.presolve_sstate!"><code>StateSpaceEcon.SteadyStateSolver.presolve_sstate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">presolve_sstate!(model; &lt;options&gt;)
presolve_sstate!(model, mask, values; &lt;options&gt;)</code></pre><p>Solve for the steady state variables that are decoupled from the system, or can be solved by forward substitution.</p><p>This is called automatically by the steady state solver before running its main loop.</p><p><strong>Arguments</strong></p><ul><li><code>model</code> - the Model instance</li><li><code>mask</code> - a vector of Bool. Defaults to <code>model.sstate.mask</code></li><li><code>values</code> - a vector of numbers. Defaults to <code>model.sstate.values</code> Caller must specify either both <code>mask</code> and <code>values</code> or neither of them. <code>mask[i]</code> equals <code>true</code> if and only if the i-th steady state value has alredy been solved for.</li></ul><p><code>mask</code> and <code>values</code> are both input and output data to the algorithm. Any values that are successfully pre-solved are updated in place, and their <code>mask</code> entries are set to <code>true</code>.</p><p><strong>Options</strong></p><ul><li><code>verbose</code> - <code>true</code> or <code>false</code>, whether or not to print diagnostic messages.</li><li><code>tol</code> - accuracy of the 1d solver.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.step_lm!-Tuple{AbstractVector{Float64}, AbstractVector{Float64}, AbstractVector{Float64}, AbstractMatrix{Float64}, StateSpaceEcon.SteadyStateSolver.LMData}" href="#StateSpaceEcon.SteadyStateSolver.step_lm!-Tuple{AbstractVector{Float64}, AbstractVector{Float64}, AbstractVector{Float64}, AbstractMatrix{Float64}, StateSpaceEcon.SteadyStateSolver.LMData}"><code>StateSpaceEcon.SteadyStateSolver.step_lm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">step_nr!(x, dx, resid, J, lm::LMData; verbose=false)</code></pre><p>Attempt a Levenberg–Marquardt step. The <code>lm</code> structure and the <code>dx</code> vector would be updated. Vectors <code>x</code>, <code>resid</code> and the matrix <code>J</code> are read-only inputs.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Internal function, do not call directly.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.step_nr!-Tuple{AbstractVector{Float64}, AbstractVector{Float64}, AbstractVector{Float64}, AbstractMatrix{Float64}, StateSpaceEcon.SteadyStateSolver.NRData}" href="#StateSpaceEcon.SteadyStateSolver.step_nr!-Tuple{AbstractVector{Float64}, AbstractVector{Float64}, AbstractVector{Float64}, AbstractMatrix{Float64}, StateSpaceEcon.SteadyStateSolver.NRData}"><code>StateSpaceEcon.SteadyStateSolver.step_nr!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">step_nr!(x, dx, resid, J, nr::NRData; verbose=false)</code></pre><p>Attempt a Newton-Raphson step. The <code>nr</code> structure and the <code>dx</code> vector would be updated accordingly. Vectors <code>x</code>, <code>resid</code> and the matrix <code>J</code> are read-only inputs.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Internal function, do not call directly.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.update_auxvars_ss-Tuple{Vector{Float64}, Model}" href="#StateSpaceEcon.SteadyStateSolver.update_auxvars_ss-Tuple{Vector{Float64}, Model}"><code>StateSpaceEcon.SteadyStateSolver.update_auxvars_ss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_auxvars_ss(point, model)</code></pre><p>This function is for internal use. Do not call directly.</p></div></section></article><h4 id="Stacked-Time-Solver-2"><a class="docs-heading-anchor" href="#Stacked-Time-Solver-2">Stacked-Time Solver</a><a class="docs-heading-anchor-permalink" href="#Stacked-Time-Solver-2" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.StackedTimeSolverData" href="#StateSpaceEcon.StackedTimeSolver.StackedTimeSolverData"><code>StateSpaceEcon.StackedTimeSolver.StackedTimeSolverData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StackedTimeSolverData</code></pre><p>The data structure used in the stacked time algorithm.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.assign_exog_data!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, StateSpaceEcon.StackedTimeSolver.StackedTimeSolverData}" href="#StateSpaceEcon.StackedTimeSolver.assign_exog_data!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, StateSpaceEcon.StackedTimeSolver.StackedTimeSolverData}"><code>StateSpaceEcon.StackedTimeSolver.assign_exog_data!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">assign_exog_data!(x::Matrix, exog::Matrix, sd::StackedTimeSolverData)</code></pre><p>Assign the exogenous points into <code>x</code> according to the plan with which <code>sd</code> was created using exogenous data from <code>exog</code>.  Also call <a href="#StateSpaceEcon.StackedTimeSolver.assign_final_condition!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, StateSpaceEcon.StackedTimeSolver.StackedTimeSolverData}"><code>assign_final_condition!</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Internal function not part of the public interface.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.assign_fc!" href="#StateSpaceEcon.StackedTimeSolver.assign_fc!"><code>StateSpaceEcon.StackedTimeSolver.assign_fc!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assign_fc!(x::Vector, exog::Vector, vind::Int, sd::StackedTimeSolverData, fc::FinalCondition)</code></pre><p>Applying the final condition <code>fc</code> for variable with index <code>vind</code>. Exogenous data is provided in <code>exog</code> and stacked time solver data in <code>sd</code>. This function updates the solution vector <code>x</code> in place and returns <code>x</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Internal function not part of the public interface.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.assign_final_condition!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, StateSpaceEcon.StackedTimeSolver.StackedTimeSolverData}" href="#StateSpaceEcon.StackedTimeSolver.assign_final_condition!-Tuple{AbstractMatrix{Float64}, AbstractMatrix{Float64}, StateSpaceEcon.StackedTimeSolver.StackedTimeSolverData}"><code>StateSpaceEcon.StackedTimeSolver.assign_final_condition!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">assign_final_condition!(x::Matrix, exog::Matrix, sd::StackedTimeSolver)</code></pre><p>Assign the final conditions into <code>x</code>. The final condition types for the different variables of the model are stored in the the solver data <code>sd</code>. <code>exog</code> is used for <a href="#StateSpaceEcon.StackedTimeSolver.fcgiven"><code>fcgiven</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Internal function not part of the public interface.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.assign_update_step!-Tuple{AbstractArray{Float64}, Float64, AbstractArray{Float64}, StateSpaceEcon.StackedTimeSolver.StackedTimeSolverData}" href="#StateSpaceEcon.StackedTimeSolver.assign_update_step!-Tuple{AbstractArray{Float64}, Float64, AbstractArray{Float64}, StateSpaceEcon.StackedTimeSolver.StackedTimeSolverData}"><code>StateSpaceEcon.StackedTimeSolver.assign_update_step!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">assign_update_step!(x::Array, lambda, dx, sd::StackedTimeSolverData)</code></pre><p>Perform something similar to <code>x = x + lambda * dx</code>, but with the necessary corrections related to final conditions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.make_BI-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}, AbstractVector{&lt;:AbstractVector{Int64}}}" href="#StateSpaceEcon.StackedTimeSolver.make_BI-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int64}, AbstractVector{&lt;:AbstractVector{Int64}}}"><code>StateSpaceEcon.StackedTimeSolver.make_BI</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">make_BI(J, II)</code></pre><p>Prepares the <code>BI</code> array for the solver data. Called from the constructor of <code>StackedTimeSolverData</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Internal function not part of the public interface.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.shockdecomp-Tuple{Model, Plan, MVTSeries{F, Float64, C} where {F&lt;:Frequency, C&lt;:AbstractMatrix{Float64}}}" href="#StateSpaceEcon.StackedTimeSolver.shockdecomp-Tuple{Model, Plan, MVTSeries{F, Float64, C} where {F&lt;:Frequency, C&lt;:AbstractMatrix{Float64}}}"><code>StateSpaceEcon.StackedTimeSolver.shockdecomp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shockdecomp(model, plan, exog_data; control, fctype, [options])</code></pre><p>Compute the shock decomposition for the given model, plan, exogenous (shocks) data and control solution.</p><p>If <code>control</code> option is not specified we use the steady state solution stored in the model instance. The algorithm assumes that <code>control</code> is a solution to the dynamic model for the given plan range and final condition. We verify the residual and issue a warning, but do not enforce this. See <a href="#StateSpaceEcon.steadystatedata"><code>steadystatedata</code></a>.</p><p>As part of the algorithm we run a simulation with the given <code>plan</code>, <code>exog_data</code> and <code>fctype</code>.  See <a href="Reference/@ref"><code>simulate</code></a> for other options.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For now only the case of <code>anticipate=true</code> works. Shock decomp with unanticipated shocks is coming soon.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.sim_nr!" href="#StateSpaceEcon.StackedTimeSolver.sim_nr!"><code>StateSpaceEcon.StackedTimeSolver.sim_nr!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sim_nr!(x, sd, maxiter, tol, verbose [, linesearch])</code></pre><p>Solve the simulation problem.</p><ul><li><code>x</code> - the array of data for the simulation. All initial, final and exogenous conditions are already in place.</li><li><code>sd::AbstractSolverData</code> - the solver data constructed for the simulation problem.</li><li><code>maxiter</code> - maximum number of iterations.</li><li><code>tol</code> - desired accuracy.</li><li><code>verbose</code> - whether or not to print progress information.</li><li><code>linesearch::Bool</code> - When <code>true</code> the Newton-Raphson is modified to include a  search along the descent direction for a sufficient decrease in f. It will  do this at each iteration. Default is <code>false</code>.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.stackedtime_R!-Tuple{AbstractVector{Float64}, AbstractArray{Float64}, AbstractArray{Float64}, StateSpaceEcon.StackedTimeSolver.StackedTimeSolverData}" href="#StateSpaceEcon.StackedTimeSolver.stackedtime_R!-Tuple{AbstractVector{Float64}, AbstractArray{Float64}, AbstractArray{Float64}, StateSpaceEcon.StackedTimeSolver.StackedTimeSolverData}"><code>StateSpaceEcon.StackedTimeSolver.stackedtime_R!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stackedtime_R!(R::Vector, point::Array, exog::Array, sd::StackedTimeSolverData)</code></pre><p>Compute the residual of the stacked time system at the given <code>point</code>. R is updated in place and returned.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.stackedtime_RJ-Tuple{AbstractArray{Float64}, AbstractArray{Float64}, StateSpaceEcon.StackedTimeSolver.StackedTimeSolverData}" href="#StateSpaceEcon.StackedTimeSolver.stackedtime_RJ-Tuple{AbstractArray{Float64}, AbstractArray{Float64}, StateSpaceEcon.StackedTimeSolver.StackedTimeSolverData}"><code>StateSpaceEcon.StackedTimeSolver.stackedtime_RJ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">R, J = stackedtime_RJ(point::Array, exog::Array, sd::StackedTimeSolverData)</code></pre><p>Compute the residual and Jacobian of the stacked time system at the given <code>point</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.update_plan!-Tuple{StateSpaceEcon.StackedTimeSolver.StackedTimeSolverData, Model, Plan}" href="#StateSpaceEcon.StackedTimeSolver.update_plan!-Tuple{StateSpaceEcon.StackedTimeSolver.StackedTimeSolverData, Model, Plan}"><code>StateSpaceEcon.StackedTimeSolver.update_plan!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_plan!(sd::StackedTimeSolverData, model, plan; changed=false)</code></pre><p>Update the stacked time solver data to reflect the new plan. The new plan must have the same range as the original plan, otherwise the solver data cannot be updated in place.</p><p>By default the data structure is updated only if an actual change in the plan is detected. Setting the <code>changed</code> flag to <code>true</code> forces the update even if the plan seems unchanged. This is necessary only in rare circumstances.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Internal function not part of the public interface.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.var_CiSc" href="#StateSpaceEcon.StackedTimeSolver.var_CiSc"><code>StateSpaceEcon.StackedTimeSolver.var_CiSc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">var_CiSc(sd::StackedTimeSolverData, var::ModelVariable, fc::FinalCondition)</code></pre><p>Return data related to the correction of the Jacobian matrix needed for the given final condition for the given variable.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Internal function not part of the public interface.</p></div></div></div></section></article><h4 id="Plans-2"><a class="docs-heading-anchor" href="#Plans-2">Plans</a><a class="docs-heading-anchor-permalink" href="#Plans-2" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.setplanvalue!-Union{Tuple{T}, Tuple{Plan{T}, Bool, Vector{Symbol}, AbstractUnitRange{T}}} where T&lt;:MIT" href="#StateSpaceEcon.Plans.setplanvalue!-Union{Tuple{T}, Tuple{Plan{T}, Bool, Vector{Symbol}, AbstractUnitRange{T}}} where T&lt;:MIT"><code>StateSpaceEcon.Plans.setplanvalue!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setplanvalue!(plan, value, vars, range)
setplanvalue!(plan, value, vars, date)
setplanvalue!(plan, value, vars, dates)</code></pre><p>Modify the status of the given variable(s) on the given date(s). If <code>value</code> is <code>true</code> then variables become exogenous, otherwise they become endogenous.</p></div></section></article><h4 id="Various-2"><a class="docs-heading-anchor" href="#Various-2">Various</a><a class="docs-heading-anchor-permalink" href="#Various-2" title="Permalink"></a></h4></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ModelBaseEcon/">« ModelBaseEcon</a><a class="docs-footer-nextpage" href="../FAME/">FAME »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Saturday 22 July 2023 00:49">Saturday 22 July 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
