<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>StateSpaceEcon · StateSpaceEcon</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../Tutorials/"><img src="../../assets/logo.png" alt="StateSpaceEcon logo"/></a><div class="docs-package-name"><span class="docs-autofit">StateSpaceEcon</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../Tutorials/">Introduction</a></li><li><a class="tocitem" href="../../Tutorials/README/">README</a></li><li><a class="tocitem" href="../../Tutorials/US_SW07/main/">Smets and Wouters 2007</a></li><li><a class="tocitem" href="../../Tutorials/TimeSeriesEcon/main/">TimeSeriesEcon</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../TimeSeriesEcon/">TimeSeriesEcon</a></li><li><a class="tocitem" href="../ModelBaseEcon/">ModelBaseEcon</a></li><li class="is-active"><a class="tocitem" href>StateSpaceEcon</a><ul class="internal"><li><a class="tocitem" href="#Steady-state-solver"><span>Steady state solver</span></a></li><li><a class="tocitem" href="#Plans"><span>Plans</span></a></li><li><a class="tocitem" href="#Stacked-time-solver"><span>Stacked time solver</span></a></li><li><a class="tocitem" href="#Various"><span>Various</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../indexpage/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>StateSpaceEcon</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>StateSpaceEcon</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/bankofcanada/DocsEcon.jl/blob/master/src/Reference/StateSpaceEcon.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="StateSpaceEcon-Reference"><a class="docs-heading-anchor" href="#StateSpaceEcon-Reference">StateSpaceEcon Reference</a><a id="StateSpaceEcon-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#StateSpaceEcon-Reference" title="Permalink"></a></h1><ul></ul><h2 id="Steady-state-solver"><a class="docs-heading-anchor" href="#Steady-state-solver">Steady state solver</a><a id="Steady-state-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Steady-state-solver" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver" href="#StateSpaceEcon.SteadyStateSolver"><code>StateSpaceEcon.SteadyStateSolver</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">SteadyStateSolver</code></pre><p>A module that is part of StateSpaceEcon package. Contains methods for finding a steady state of a model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.check_sstate-Tuple{Model}" href="#StateSpaceEcon.SteadyStateSolver.check_sstate-Tuple{Model}"><code>StateSpaceEcon.SteadyStateSolver.check_sstate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_sstate(model; &lt;options&gt;)</code></pre><p>Run a diagnostic test to determine if the steady state solution stored within the given model object is indeed a solution of the steady state system of equations.</p><p>Return the number of steady state equations that are violated by the current steady state solution. If <code>verbose=true</code>, also display diagnostic information in the form of listing all bad equations and their residuals.</p><p><strong>Options</strong></p><p>Standard options (default values from <code>model.options</code>)</p><ul><li><code>verbose</code> </li><li><code>tol</code> - an equation is considered satisfied if its residual, in absolute value, is smaller than this number.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.clear_sstate!-Tuple{Model}" href="#StateSpaceEcon.SteadyStateSolver.clear_sstate!-Tuple{Model}"><code>StateSpaceEcon.SteadyStateSolver.clear_sstate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">clear_sstate!(model; lvl=0.1, slp=0.0, &lt;options&gt;)</code></pre><p>Set the steady state values to the provided defaults and presolve.</p><p><strong>Arguments</strong></p><ul><li><code>model</code> - the model instance</li><li><code>lvl</code>, <code>slp</code> - the initial guess for the level and the slope. Each could be a number or a vector of length equal to the number of variable in the mode.</li></ul><p><strong>Options</strong></p><p>Standard options (default values are taken from <code>model.options</code>)</p><ul><li><code>verbose</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.diagnose_sstate-Tuple{Model}" href="#StateSpaceEcon.SteadyStateSolver.diagnose_sstate-Tuple{Model}"><code>StateSpaceEcon.SteadyStateSolver.diagnose_sstate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">diagnose_sstate([point,] model)</code></pre><p>Run diagnostics on the steady state of the given model. If <code>point</code> is not given, then we check the steady state solution stored inside the given model.</p><p>Return a tuple of &quot;bad&quot; equations and &quot;bad&quot; variables. </p><p>The set of &quot;bad&quot; equations is one that is inconsistent, i.e. there is no solution. This might happen if the system is overdetermined.</p><p>The set of &quot;bad&quot; variables contains variables that cannot be solved uniquely. This might happen if the system is underdetermined. In this case, try adding steady state constraints until you get a unique solution. See <a href="../ModelBaseEcon/#ModelBaseEcon.@steadystate-Tuple{Any,Symbol,Expr}"><code>@steadystate</code></a> in ModelBaseEcon.</p><div class="admonition is-warning"><header class="admonition-header">Internal function</header><div class="admonition-body"><p>The output from this function may be difficult to read.&lt;br&gt; Call <a href="#StateSpaceEcon.SteadyStateSolver.check_sstate-Tuple{Model}"><code>check_sstate</code></a> instead.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.initial_sstate!-Tuple{Model,AbstractArray{Float64,1}}" href="#StateSpaceEcon.SteadyStateSolver.initial_sstate!-Tuple{Model,AbstractArray{Float64,1}}"><code>StateSpaceEcon.SteadyStateSolver.initial_sstate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">initial_sstate!(model, init; &lt;options&gt;)</code></pre><p>Set the steady state values from the given vector and presolve.</p><p>Call this function to specify initial guesses for the iterative steady state solver. If the value of a steady state variable is known, it is better to use <a href="../ModelBaseEcon/#ModelBaseEcon.@steadystate-Tuple{Any,Symbol,Expr}"><code>@steadystate</code></a> to add that as a steady state constraint.</p><p><strong>Arguments</strong></p><ul><li><code>model</code> - the model.</li><li><code>init</code> - a vector of length equal to twice the number of variables in the model. The level and slope values are staggered, i.e., the level and slope of variable j are in init[2j-1] and init[2j].</li></ul><p><strong>Options</strong></p><p>Standard options (default values are taken from <code>model.options</code>)</p><ul><li><code>verbose</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SteadyStateSolver.sssolve!-Tuple{Model}" href="#StateSpaceEcon.SteadyStateSolver.sssolve!-Tuple{Model}"><code>StateSpaceEcon.SteadyStateSolver.sssolve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sssolve!(model; &lt;options&gt;)</code></pre><p>Solve the steady state problem for the given model.</p><p><strong>Options</strong></p><p>Standard options (default values are taken from <code>model.options</code>)</p><ul><li><code>verbose</code></li><li><code>tol</code>, <code>maxiter</code> - control the stopping criteria of the solver</li></ul><p>Specific options</p><ul><li><code>presolve::Bool</code> - whether or not to use a presolve pass. Default is <code>true</code>.</li><li><code>method::Symbol</code> - choose the solution algorithm. Valid options are <code>:nr</code> for Newton-Raphson, <code>:lm</code> for Levenberg-Marquardt, and <code>:auto</code>. The <code>:auto</code> method starts with the LM algorithm and automatically switches to NR when it starts to converge. Default is <code>:nr</code>.</li></ul></div></section></article><h2 id="Plans"><a class="docs-heading-anchor" href="#Plans">Plans</a><a id="Plans-1"></a><a class="docs-heading-anchor-permalink" href="#Plans" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans" href="#StateSpaceEcon.Plans"><code>StateSpaceEcon.Plans</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">Plans</code></pre><p>Module part of StateSpaceEcon. This module implements the <code>Plan</code> data structure, which is used in simulations. The plan object contains information about the range of the simulation and which variables and shocks are exogenous or endogenous at each period of the range.</p><p><strong>Constructors</strong></p><ul><li><a href="#StateSpaceEcon.Plans.Plan"><code>Plan(model, range)</code></a></li></ul><p><strong>Modify the plan</strong></p><ul><li><a href="#StateSpaceEcon.Plans.exogenize!-Tuple{Plan,Symbol,Any}"><code>exogenize!</code></a>, <a href="#StateSpaceEcon.Plans.endogenize!-Tuple{Plan,Symbol,Any}"><code>endogenize!</code></a> - make variables exogenous or endogenous</li><li><a href="#StateSpaceEcon.Plans.exog_endo!-Tuple{Plan,Any,Any,Any}"><code>exog_endo!</code></a>, <a href="#StateSpaceEcon.Plans.endo_exog!-Tuple{Plan,Any,Any,Any}"><code>endo_exog!</code></a> - swap exogenous and endogenous variables</li><li><a href="#StateSpaceEcon.Plans.autoexogenize!-Tuple{Plan,Model,Any}"><code>autoexogenize!</code></a> - exogenize and endogenize variables according to the list in the model</li></ul><p><strong>Prepare data for simulation</strong></p><ul><li><a href="#StateSpaceEcon.Plans.zeroarray-Tuple{Model,Plan}"><code>zeroarray</code></a>, <a href="#StateSpaceEcon.Plans.zerodict-Tuple{Model,Plan}"><code>zerodict</code></a>, <a href="#StateSpaceEcon.Plans.zerodata-Tuple{Model,Plan}"><code>zerodata</code></a> - prepare a matrix or a dictionary or a <a href="#StateSpaceEcon.SimData"><code>SimData</code></a> of data for the simulation containing zeros.</li><li><a href="#StateSpaceEcon.Plans.steadystatearray-Tuple{Model,AbstractUnitRange}"><code>steadystatearray</code></a>, <a href="#StateSpaceEcon.Plans.steadystatedict-Tuple{Model,AbstractUnitRange}"><code>steadystatedict</code></a>, <a href="#StateSpaceEcon.Plans.steadystatedata-Tuple{Model,AbstractUnitRange}"><code>steadystatedata</code></a> - prepare a matrix or a dictionary or a <a href="#StateSpaceEcon.SimData"><code>SimData</code></a> of data for the simulation containing the steady state.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.Plan" href="#StateSpaceEcon.Plans.Plan"><code>StateSpaceEcon.Plans.Plan</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Plan{T &lt;: MIT}</code></pre><p>A data structure representing the simulation plan. It holds information about the time range of the simulation and which variables/shocks are exogenous at each period.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.Plan-Tuple{Model,AbstractUnitRange}" href="#StateSpaceEcon.Plans.Plan-Tuple{Model,AbstractUnitRange}"><code>StateSpaceEcon.Plans.Plan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Plan(model, range)</code></pre><p>Create a default simulation plan for the given model over the given range. The range of the plan is augmented to include periods before and after the given range, over which initial and final conditions will be applied. </p><p>Instead of a range, one could also pass in a single moment in time (<a href="../TimeSeriesEcon/#TimeSeriesEcon.MIT"><code>MIT</code></a>) instance, in which case it is interpreted as a range of length 1.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.autoexogenize!-Tuple{Plan,Model,Any}" href="#StateSpaceEcon.Plans.autoexogenize!-Tuple{Plan,Model,Any}"><code>StateSpaceEcon.Plans.autoexogenize!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>autoexogenize!(plan, model, date)</p><p>Modify the given plan according to the &quot;autoexogenize&quot; protocol defined in the given model. All variables in the autoexogenization list become endogenous and their corresponding shocks become exogenous over the given date or range. <code>date</code> can be a moment in time (same frequency as the given plan), a range, an iterable, or a container.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.endo_exog!-Tuple{Plan,Any,Any,Any}" href="#StateSpaceEcon.Plans.endo_exog!-Tuple{Plan,Any,Any,Any}"><code>StateSpaceEcon.Plans.endo_exog!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">endo_exog!(plan, endo_vars, exog_vars, date)</code></pre><p>Modify the given plan so that the given variables listed in <code>exog_vars</code> will be exogenous and the variables listed in <code>endo_vars</code> will be endogenous on the given dates. <code>exog_vars</code> and <code>endo_vars</code> can each be a <code>Symbol</code> or a <code>String</code> or a <code>Vector</code> of such. <code>date</code> can be a moment in time (same type as the plan), or a range or an iterable or a container.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.endogenize!-Tuple{Plan,Symbol,Any}" href="#StateSpaceEcon.Plans.endogenize!-Tuple{Plan,Symbol,Any}"><code>StateSpaceEcon.Plans.endogenize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">endogenize!(plan, vars, date)</code></pre><p>Modify the given plan so that the given variables will be endogenous on the given dates. <code>vars</code> can be a <code>Symbol</code> or a <code>String</code> or a <code>Vector</code> of such. <code>date</code> can be a moment in time (same type as the plan), or a range or an iterable or a container.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.exog_endo!-Tuple{Plan,Any,Any,Any}" href="#StateSpaceEcon.Plans.exog_endo!-Tuple{Plan,Any,Any,Any}"><code>StateSpaceEcon.Plans.exog_endo!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">exog_endo!(plan, exog_vars, endo_vars, date)</code></pre><p>Modify the given plan so that the given variables listed in <code>exog_vars</code> will be exogenous and the variables listed in <code>endo_vars</code> will be endogenous on the given dates. <code>exog_vars</code> and <code>endo_vars</code> can each be a <code>Symbol</code> or a <code>String</code> or a <code>Vector</code> of such. <code>date</code> can be a moment in time (same type as the plan), or a range or an iterable or a container.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.exogenize!-Tuple{Plan,Symbol,Any}" href="#StateSpaceEcon.Plans.exogenize!-Tuple{Plan,Symbol,Any}"><code>StateSpaceEcon.Plans.exogenize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">exogenize!(plan, vars, date)</code></pre><p>Modify the given plan so that the given variables will be exogenous on the given dates. <code>vars</code> can be a <code>Symbol</code> or a <code>String</code> or a <code>Vector</code> of such. <code>date</code> can be a moment in time (same type as the plan), or a range or an iterable or a container.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.plansum-Tuple{Model,Plan}" href="#StateSpaceEcon.Plans.plansum-Tuple{Model,Plan}"><code>StateSpaceEcon.Plans.plansum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plansum(model, plan)</code></pre><p>Return the total number of exogenous variables in the simulation plan. Periods over which initial and final conditions are imposed are not counted in this sum.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.setexog!-Tuple{Plan,Int64,Any}" href="#StateSpaceEcon.Plans.setexog!-Tuple{Plan,Int64,Any}"><code>StateSpaceEcon.Plans.setexog!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setexog!(plan, t, vinds)</code></pre><p>Modify the plan at time t such that <code>vinds</code> are exogenous and the rest are endogenous.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.steadystatearray-Tuple{Model,AbstractUnitRange}" href="#StateSpaceEcon.Plans.steadystatearray-Tuple{Model,AbstractUnitRange}"><code>StateSpaceEcon.Plans.steadystatearray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">steadystatearray(model, plan)
steadystatearray(model, range)</code></pre><p>Create a matrix of the proper dimensions for a simulation with the given model with the given plan or over the given range. The matrix is initialized with the steady state level of each variable. If a range is given rather than a plan, it is augmented with periods before and after the given range in order to accommodate initial and final conditions.</p><p>See also: <a href="#StateSpaceEcon.Plans.zeroarray-Tuple{Model,Plan}"><code>zeroarray</code></a>, <a href="#StateSpaceEcon.Plans.zerodict-Tuple{Model,Plan}"><code>zerodict</code></a>, <a href="#StateSpaceEcon.Plans.steadystatearray-Tuple{Model,AbstractUnitRange}"><code>steadystatearray</code></a>, <a href="#StateSpaceEcon.Plans.steadystatedict-Tuple{Model,AbstractUnitRange}"><code>steadystatedict</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.steadystatedata-Tuple{Model,AbstractUnitRange}" href="#StateSpaceEcon.Plans.steadystatedata-Tuple{Model,AbstractUnitRange}"><code>StateSpaceEcon.Plans.steadystatedata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">steadystatedata(model, plan)
steadystatedata(model, range)</code></pre><p>Create a <a href="#StateSpaceEcon.SimData"><code>SimData</code></a> containing a <a href="../TimeSeriesEcon/#TimeSeriesEcon.TSeries"><code>TSeries</code></a> of the appropriate range for each variable in the model for a simulation with the given plan or over the given range. The matrix is initialized with the steady state level of each variable. If a range is given rather than a plan, it is augmented with periods before and after the given range in order to accommodate initial and final conditions.</p><p>See also: <a href="#StateSpaceEcon.Plans.zeroarray-Tuple{Model,Plan}"><code>zeroarray</code></a>, <a href="#StateSpaceEcon.Plans.zerodict-Tuple{Model,Plan}"><code>zerodict</code></a>, <a href="#StateSpaceEcon.Plans.steadystatearray-Tuple{Model,AbstractUnitRange}"><code>steadystatearray</code></a>, <a href="#StateSpaceEcon.Plans.steadystatedict-Tuple{Model,AbstractUnitRange}"><code>steadystatedict</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.steadystatedict-Tuple{Model,AbstractUnitRange}" href="#StateSpaceEcon.Plans.steadystatedict-Tuple{Model,AbstractUnitRange}"><code>StateSpaceEcon.Plans.steadystatedict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">steadystatearray(model, plan)
steadystatearray(model, range)</code></pre><p>Create a dictionary containing a <a href="../TimeSeriesEcon/#TimeSeriesEcon.TSeries"><code>TSeries</code></a> of the appropriate range for each variable in the model for a simulation with the given plan or over the given range. The matrix is initialized with the steady state level of each variable. If a range is given rather than a plan, it is augmented with periods before and after the given range in order to accommodate initial and final conditions.</p><p>See also: <a href="#StateSpaceEcon.Plans.zeroarray-Tuple{Model,Plan}"><code>zeroarray</code></a>, <a href="#StateSpaceEcon.Plans.zerodict-Tuple{Model,Plan}"><code>zerodict</code></a>, <a href="#StateSpaceEcon.Plans.steadystatearray-Tuple{Model,AbstractUnitRange}"><code>steadystatearray</code></a>, <a href="#StateSpaceEcon.Plans.steadystatedict-Tuple{Model,AbstractUnitRange}"><code>steadystatedict</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.zeroarray-Tuple{Model,Plan}" href="#StateSpaceEcon.Plans.zeroarray-Tuple{Model,Plan}"><code>StateSpaceEcon.Plans.zeroarray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">zeroarray(model, plan)
zeroarray(model, range)</code></pre><p>Create a matrix of the proper dimension for a simulation with the given model with the given plan or over the given range. If a range is given, the data is prepared for the default plan. This means that appropriate number of periods are added before and after the range to account for initial and final conditions.</p><p>See also: <a href="#StateSpaceEcon.Plans.zeroarray-Tuple{Model,Plan}"><code>zeroarray</code></a>, <a href="#StateSpaceEcon.Plans.zerodict-Tuple{Model,Plan}"><code>zerodict</code></a>, <a href="#StateSpaceEcon.Plans.steadystatearray-Tuple{Model,AbstractUnitRange}"><code>steadystatearray</code></a>, <a href="#StateSpaceEcon.Plans.steadystatedict-Tuple{Model,AbstractUnitRange}"><code>steadystatedict</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.zerodata-Tuple{Model,Plan}" href="#StateSpaceEcon.Plans.zerodata-Tuple{Model,Plan}"><code>StateSpaceEcon.Plans.zerodata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">zerodata(model, plan)
zerodata(model, range)</code></pre><p>Create a <code>NamedTuple</code> containing a <a href="../TimeSeriesEcon/#TimeSeriesEcon.TSeries"><code>TSeries</code></a> of the appropriate range for each variable in the model for a simulation with the given plan or over the given range. If a range is given rather than a plan, the data is prepared for the default plan over that range. This means that appropriate number of periods are added before and after the range to account for initial and final conditions.</p><p>See also: <a href="#StateSpaceEcon.Plans.zeroarray-Tuple{Model,Plan}"><code>zeroarray</code></a>, <a href="#StateSpaceEcon.Plans.zerodict-Tuple{Model,Plan}"><code>zerodict</code></a>, <a href="#StateSpaceEcon.Plans.steadystatearray-Tuple{Model,AbstractUnitRange}"><code>steadystatearray</code></a>, <a href="#StateSpaceEcon.Plans.steadystatedict-Tuple{Model,AbstractUnitRange}"><code>steadystatedict</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.Plans.zerodict-Tuple{Model,Plan}" href="#StateSpaceEcon.Plans.zerodict-Tuple{Model,Plan}"><code>StateSpaceEcon.Plans.zerodict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">zerodict(model, plan)
zerodict(model, range)</code></pre><p>Create a dictionary containing a <a href="../TimeSeriesEcon/#TimeSeriesEcon.TSeries"><code>TSeries</code></a> of the appropriate range for each variable in the model for a simulation with the given plan or over the given range. If a range is given rather than a plan, the data is prepared for the default plan over that range. This means that appropriate number of periods are added before and after the range to account for initial and final conditions.</p><p>See also: <a href="#StateSpaceEcon.Plans.zeroarray-Tuple{Model,Plan}"><code>zeroarray</code></a>, <a href="#StateSpaceEcon.Plans.zerodict-Tuple{Model,Plan}"><code>zerodict</code></a>, <a href="#StateSpaceEcon.Plans.steadystatearray-Tuple{Model,AbstractUnitRange}"><code>steadystatearray</code></a>, <a href="#StateSpaceEcon.Plans.steadystatedict-Tuple{Model,AbstractUnitRange}"><code>steadystatedict</code></a></p></div></section></article><h2 id="Stacked-time-solver"><a class="docs-heading-anchor" href="#Stacked-time-solver">Stacked time solver</a><a id="Stacked-time-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Stacked-time-solver" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver" href="#StateSpaceEcon.StackedTimeSolver"><code>StateSpaceEcon.StackedTimeSolver</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">StackedTimeSolver</code></pre><p>A module that is part of StateSpaceEcon package. Contains methods for solving the dynamic system of equations for the model and running simulations.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.FCType" href="#StateSpaceEcon.StackedTimeSolver.FCType"><code>StateSpaceEcon.StackedTimeSolver.FCType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FCType</code></pre><p>An enumeration type representing the possible types of final conditions.</p><ul><li><code>fcgiven</code> - the final conditions are provided by the user.</li><li><code>fclevel</code> - the final conditions are prescribed from the levels of the steady state solution.</li><li><code>fcslope</code> - the final conditions are such that the slope of the dynamic solution matches the slope of the steady state solution.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.array2data-Tuple{AbstractArray{Float64,2},AbstractArray{#s68,1} where #s68&lt;:AbstractString,MIT}" href="#StateSpaceEcon.StackedTimeSolver.array2data-Tuple{AbstractArray{Float64,2},AbstractArray{#s68,1} where #s68&lt;:AbstractString,MIT}"><code>StateSpaceEcon.StackedTimeSolver.array2data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">array2data(data, vars, start_date)</code></pre><p>Convert the simulation data array to a named tuple.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.array2dict-Tuple{AbstractArray{Float64,2},AbstractArray{#s68,1} where #s68&lt;:AbstractString,MIT}" href="#StateSpaceEcon.StackedTimeSolver.array2dict-Tuple{AbstractArray{Float64,2},AbstractArray{#s68,1} where #s68&lt;:AbstractString,MIT}"><code>StateSpaceEcon.StackedTimeSolver.array2dict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">array2dict(data, vars, start_date)</code></pre><p>Convert the simulation data array to a dictionary.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.dict2array-Tuple{Dict{#s32,#s31} where #s31 where #s32&lt;:AbstractString,AbstractArray{#s30,1} where #s30&lt;:AbstractString}" href="#StateSpaceEcon.StackedTimeSolver.dict2array-Tuple{Dict{#s32,#s31} where #s31 where #s32&lt;:AbstractString,AbstractArray{#s30,1} where #s30&lt;:AbstractString}"><code>StateSpaceEcon.StackedTimeSolver.dict2array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dict2array(d, vars; range)</code></pre><p>Convert a dictionary of <a href="../TimeSeriesEcon/#TimeSeriesEcon.TSeries"><code>TSeries</code></a> to a 2d array of simulation data for the given range.  The <code>range</code> argument is optional and defaults to <code>nothing</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.dictoverlay-Tuple{Dict{String,#s41} where #s41,Dict{String,#s40} where #s40}" href="#StateSpaceEcon.StackedTimeSolver.dictoverlay-Tuple{Dict{String,#s41} where #s41,Dict{String,#s40} where #s40}"><code>StateSpaceEcon.StackedTimeSolver.dictoverlay</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dictoverlay(d1, d2)</code></pre><p>Merge two dictionaries. Common key where the values are <a href="../TimeSeriesEcon/#TimeSeriesEcon.TSeries"><code>TSeries</code></a> of the same frequency are overlayed. Otherwise, a common key takes the value of the last Dict containing it.</p><p>See also: <a href="#StateSpaceEcon.StackedTimeSolver.seriesoverlay-Tuple{TSeries,TSeries}"><code>seriesoverlay</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.seriesoverlay-Tuple{TSeries,TSeries}" href="#StateSpaceEcon.StackedTimeSolver.seriesoverlay-Tuple{TSeries,TSeries}"><code>StateSpaceEcon.StackedTimeSolver.seriesoverlay</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">seriesoverlay(ts1, ts2)</code></pre><p>Return a new <a href="../TimeSeriesEcon/#TimeSeriesEcon.TSeries"><code>TSeries</code></a> over the full range of both arguments. The overlapping part contains values from the last argument.</p><p>See also: <a href="#StateSpaceEcon.StackedTimeSolver.dictoverlay-Tuple{Dict{String,#s41} where #s41,Dict{String,#s40} where #s40}"><code>dictoverlay</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StackedTimeSolver.simulate-Tuple{Model,Plan,AbstractArray{Float64,2}}" href="#StateSpaceEcon.StackedTimeSolver.simulate-Tuple{Model,Plan,AbstractArray{Float64,2}}"><code>StateSpaceEcon.StackedTimeSolver.simulate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">simulate(model, plan, data; &lt;options&gt;)</code></pre><p>Run a simulation for the given model, simulation plan and exogenous data.</p><p><strong>Arguments</strong></p><ul><li><code>model</code> - the <a href="../ModelBaseEcon/#ModelBaseEcon.Model"><code>Model</code></a> instance to simulate.</li><li><code>plan</code> - the <a href="#StateSpaceEcon.Plans.Plan"><code>Plan</code></a> for the simulation.</li><li><code>data</code> - a 2D <code>Array</code> containing the exogenous data. This includes the initial and final conditions.</li></ul><p><strong>Options as keyword arguments</strong></p><ul><li><code>fctype::</code><a href="#StateSpaceEcon.StackedTimeSolver.FCType"><code>FCType</code></a> - set the desired final condition type for the simulation. The default value is <code>fcgiven</code>. Other possible values include <code>fclevel</code> and <code>fcslope</code>.</li><li><code>initial_guess::AbstractMatrix{Float64}</code> - a 2D <code>Array</code> containing the initial guess for the solution. This is used to start the Newton-Raphson algorithm. The default value is an empty array (<code>zeros(0,0)</code>), in which case we use the exogenous data for the initial condition. You can use the steady state solution using <a href="#StateSpaceEcon.Plans.steadystatearray-Tuple{Model,AbstractUnitRange}"><code>steadystatearray</code></a>.</li><li><code>linearize::Bool</code> - set to <code>true</code> to instruct the solver to use the liearized model. If the model is already linearized, this option has the effect that the model gets linearized about the current steady stat and with the value of <code>deviation</code> given here. Otherwise the model is linearized about the steady state. After the simulation is computed, the model is restored to its original state. Default value is <code>false</code>.</li><li><code>deviation::Bool</code> - set to <code>true</code> if the <code>data</code> is in deviations from the steady state. This is only relevant if the <code>linearize</code> option is set to <code>true</code>. Default value is <code>false</code>.</li><li><code>anticipate::Bool</code> - set to <code>false</code> to instruct the solver that all shocks are unanticilated by the agents. Default value is <code>true</code>.</li><li><code>verbose::Bool</code> - control whether or not to print progress information. Default value is taken from <code>model.options</code>.</li><li><code>tol::Float64</code> - set the desired accuracy. Default value is taken from <code>model.options</code>.</li><li><code>maxiter::Int</code> - algorithm fails if the desired accuracy is not reached within this maximum number of iterations. Default value is taken from <code>model.options</code>.</li></ul><p><strong>See also:</strong></p><p><strong>Examples</strong></p></div></section></article><h2 id="Various"><a class="docs-heading-anchor" href="#Various">Various</a><a id="Various-1"></a><a class="docs-heading-anchor-permalink" href="#Various" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.StateSpaceEcon" href="#StateSpaceEcon.StateSpaceEcon"><code>StateSpaceEcon.StateSpaceEcon</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">StateSpaceEcon</code></pre><p>A package for Macroeconomic modelling.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.SimData" href="#StateSpaceEcon.SimData"><code>StateSpaceEcon.SimData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SimData</code></pre><p>Data structure containing the time series data for a simulation.</p><p>It is a collection of <a href="../TimeSeriesEcon/#TimeSeriesEcon.TSeries"><code>TSeries</code></a> of the same frequency and containing data for the same range. When used for simulation, the range must include the initial conditions, the simulation range and the final conditions, although it could extend beyond that. It must contain time series for all variables and shocks in the model, although it might contain other time series.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceEcon.printmatrix-Tuple{Any,Vararg{Any,N} where N}" href="#StateSpaceEcon.printmatrix-Tuple{Any,Vararg{Any,N} where N}"><code>StateSpaceEcon.printmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">printmatrix(mat [, Val(F), colnames])</code></pre><p>Display a matrix in full while controlling the formatting of each value and optionally showing the column names.</p><ul><li><code>Val(F)</code> - display each number in the given format <code>F</code>. The format is in the form of a decimal point number where the whole part indicates the total width and the fractional part is the number of digits printed after the decimal point. Default is <code>Val(12.7)</code></li><li><code>colnames</code> - a list of names to display in the first row. The names are displayed as given, possibly with padding to match the width given in the <code>Val</code> argument. If any names are longer than that, they will not be truncated and so the display will not be aligned properly. Sorry about that!</li></ul></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ModelBaseEcon/">« ModelBaseEcon</a><a class="docs-footer-nextpage" href="../../indexpage/">Index »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 24 August 2020 20:25">Monday 24 August 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
