<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ModelBaseEcon · StateSpaceEcon</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../Tutorials/"><img src="../../assets/logo.png" alt="StateSpaceEcon logo"/></a><div class="docs-package-name"><span class="docs-autofit">StateSpaceEcon</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../Tutorials/">Introduction</a></li><li><a class="tocitem" href="../../Tutorials/README/">README</a></li><li><a class="tocitem" href="../../Tutorials/US_SW07/main/">Smets and Wouters 2007</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../TimeSeriesEcon/">TimeSeriesEcon</a></li><li class="is-active"><a class="tocitem" href>ModelBaseEcon</a><ul class="internal"><li><a class="tocitem" href="#Options"><span>Options</span></a></li><li><a class="tocitem" href="#Timer"><span>Timer</span></a></li><li><a class="tocitem" href="#ModelBaseEcon"><span>ModelBaseEcon</span></a></li></ul></li><li><a class="tocitem" href="../StateSpaceEcon/">StateSpaceEcon</a></li></ul></li><li><a class="tocitem" href="../../indexpage/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>ModelBaseEcon</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ModelBaseEcon</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/bankofcanada/DocsEcon.jl/blob/master/src/Reference/ModelBaseEcon.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ModelBaseEcon-Reference"><a class="docs-heading-anchor" href="#ModelBaseEcon-Reference">ModelBaseEcon Reference</a><a id="ModelBaseEcon-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#ModelBaseEcon-Reference" title="Permalink"></a></h1><ul></ul><h2 id="Options"><a class="docs-heading-anchor" href="#Options">Options</a><a id="Options-1"></a><a class="docs-heading-anchor-permalink" href="#Options" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.OptionsMod" href="#ModelBaseEcon.OptionsMod"><code>ModelBaseEcon.OptionsMod</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">OptionsMod</code></pre><p>Sub-module of ModelBaseEcon, although it can be used independently. Implements the <a href="#ModelBaseEcon.OptionsMod.Options"><code>Options</code></a> data structure.</p><p><strong>Contents</strong></p><ul><li><a href="#ModelBaseEcon.OptionsMod.Options"><code>Options</code></a></li><li><a href="#ModelBaseEcon.OptionsMod.getoption"><code>getoption</code></a> - read the value of an option</li><li><a href="#ModelBaseEcon.OptionsMod.getoption!"><code>getoption!</code></a> - if not present, also create an option</li><li><a href="#ModelBaseEcon.OptionsMod.setoption!"><code>setoption!</code></a> - create or update the value of an option </li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.OptionsMod.Options" href="#ModelBaseEcon.OptionsMod.Options"><code>ModelBaseEcon.OptionsMod.Options</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Options</code></pre><p>A collection of key-value pairs representing the options controlling the behaviour or the definition of a Model object. The key is the option name and is always a Symbol, or converted to Symbol, while the value can be anything.</p><p>The options can be accessed using dot notation. Functions <a href="#ModelBaseEcon.OptionsMod.getoption"><code>getoption</code></a> and <a href="#ModelBaseEcon.OptionsMod.setoption!"><code>setoption!</code></a> are also provided. They can be used for programmatic processing of options as well as when the option name is not a valid Julia identifier.</p><p>See also: <a href="#ModelBaseEcon.OptionsMod.Options"><code>Options</code></a>, <a href="#ModelBaseEcon.OptionsMod.getoption"><code>getoption</code></a>, <a href="#ModelBaseEcon.OptionsMod.getoption!"><code>getoption!</code></a>, <a href="#ModelBaseEcon.OptionsMod.setoption!"><code>setoption!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; o = Options(maxiter=20, tol=1e-7)
Options:
    maxiter=20
    tol=1.0e-7

julia&gt; o.maxiter = 25
25

julia&gt; o
Options:
    maxiter=25
    tol=1.0e-7
</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.OptionsMod.Options-Tuple{Options}" href="#ModelBaseEcon.OptionsMod.Options-Tuple{Options}"><code>ModelBaseEcon.OptionsMod.Options</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Options(::Options)</code></pre><p>Construct an Options instance as an exact copy of an existing instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.OptionsMod.Options-Tuple{}" href="#ModelBaseEcon.OptionsMod.Options-Tuple{}"><code>ModelBaseEcon.OptionsMod.Options</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Options(key=value, ...)
Options(:key=&gt;value, ...)</code></pre><p>Construct an Options instance with key-value pairs given as keyword arguments or as a list of pairs. If the latter is used, each key must be a <code>Symbol</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.OptionsMod.getoption" href="#ModelBaseEcon.OptionsMod.getoption"><code>ModelBaseEcon.OptionsMod.getoption</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getoption(o::Options; name=default [, name=default, ...])
getoption(o::Options, name, default)</code></pre><p>Retrieve the value of an option or a set of options.  The provided defaults are used when the option doesn&#39;t exit.</p><p>The return value is the value of the option requested or, if the option doesn&#39;t exist, the default. In the first version of the function, if there are more than one options requested, the return value is a tuple.</p><p>In the second version, the name could be a symbol or a string, which can be helpful if the name of the option is not a valid identifier.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.OptionsMod.getoption!" href="#ModelBaseEcon.OptionsMod.getoption!"><code>ModelBaseEcon.OptionsMod.getoption!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getoption!(o::Options; name=default [, name=default, ...])
getoption!(o::Options, name, default)</code></pre><p>Retrieve the value of an option or a set of options. If the name does not match an existing option, the Options instance is updated by inserting the given name and default value.</p><p>The return value is the value of the option requested (or the default). In the first version of the function, if there are more than one options requested, the return value is a tuple.</p><p>In the second version, the name could be a symbol or a string, which can be helpful if the name of the option is not a valid identifier.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.OptionsMod.setoption!" href="#ModelBaseEcon.OptionsMod.setoption!"><code>ModelBaseEcon.OptionsMod.setoption!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setoption!(o::Options; name=default [, name=default, ...])
setoption!(o::Options, name, default)</code></pre><p>Retrieve the value of an option or a set of options. If the name does not match an existing option, the Options instance is updated by inserting the given name and default value.</p><p>The return value is the value of the option requested (or the default). In the first version of the function, if there are more than one options requested, the return value is a tuple.</p><p>In the second version, the name could be a symbol or a string, which can be helpful if the name of the option is not a valid identifier.</p></div></section></article><h2 id="Timer"><a class="docs-heading-anchor" href="#Timer">Timer</a><a id="Timer-1"></a><a class="docs-heading-anchor-permalink" href="#Timer" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.Timer" href="#ModelBaseEcon.Timer"><code>ModelBaseEcon.Timer</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">Timer</code></pre><p>A sub-module of ModelBaseEcon, although it can be used independently. Provides functionality for measuring the aggregate time spent in individual lines or blocks of code.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The implementation here is quick-and-dirty and is intended for getting a rough idea of where the bottlenecks are. It is best used for timing blocks of code that are passed through relatively few times and each pass takes a relatively long time. In the opposite extreme case (fast code that is called many times), the current implementation of <code>@timer</code> might add extreme overhead.</p></div></div><p><strong>Contents</strong></p><ul><li><a href="#ModelBaseEcon.Timer.inittimer-Tuple{}"><code>inittimer</code></a>       - Enable collection of timer data.</li><li><a href="#ModelBaseEcon.Timer.stoptimer-Tuple{}"><code>stoptimer</code></a>       - Disable collection of timer data.</li><li><a href="#ModelBaseEcon.Timer.printtimer"><code>printtimer</code></a>      - Display timer data.</li><li><a href="#ModelBaseEcon.Timer.@timer-Tuple"><code>@timer</code></a>          - Measure the runtime taken by the given code.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; true
[...]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.Timer.inittimer-Tuple{}" href="#ModelBaseEcon.Timer.inittimer-Tuple{}"><code>ModelBaseEcon.Timer.inittimer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inittimer()</code></pre><p>Enable the collection of timing data. Existing timing data is lost. By default, collection of timing data is disabled.</p><p>See also: <a href="#ModelBaseEcon.Timer.stoptimer-Tuple{}"><code>stoptimer</code></a>, <a href="#ModelBaseEcon.Timer.@timer-Tuple"><code>@timer</code></a>, <a href="#ModelBaseEcon.Timer.printtimer"><code>printtimer</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.Timer.printtimer" href="#ModelBaseEcon.Timer.printtimer"><code>ModelBaseEcon.Timer.printtimer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">printtimer(io::IO=Base.stdout)</code></pre><p>Display timing data.</p><p>Timing data is displayed in a table with each row containing the number of calls, total time in seconds, and the source line or block tag. Rows are sorted in order of decreasing total time.</p><p>See also: <a href="#ModelBaseEcon.Timer.@timer-Tuple"><code>@timer</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.Timer.stoptimer-Tuple{}" href="#ModelBaseEcon.Timer.stoptimer-Tuple{}"><code>ModelBaseEcon.Timer.stoptimer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">stoptimer()</code></pre><p>Disable the collection of timing data. Existing data is lost. By default, collection of timing data is disabled.</p><p>See also: <a href="#ModelBaseEcon.Timer.inittimer-Tuple{}"><code>inittimer</code></a>, <a href="#ModelBaseEcon.Timer.@timer-Tuple"><code>@timer</code></a>, <a href="#ModelBaseEcon.Timer.printtimer"><code>printtimer</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.Timer.@timer-Tuple" href="#ModelBaseEcon.Timer.@timer-Tuple"><code>ModelBaseEcon.Timer.@timer</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@timer(code)
@timer(tag::String, code)</code></pre><p>Measure the number of calls and the total time taken by the given code.</p><p>If a <code>tag</code> string is not provided, one is generated from the source file and line. The return value of this macro call is the return value of the code.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Important limitation is that the code must not contain a <code>return</code>, <code>break</code>, <code>continue</code>, or any other jump out of it. If it does, the program would run correctly, but the timing data collected would be incorrect.</p></div></div><p>See also: <a href="#ModelBaseEcon.Timer.inittimer-Tuple{}"><code>inittimer</code></a>, <a href="#ModelBaseEcon.Timer.stoptimer-Tuple{}"><code>stoptimer</code></a>, <a href="#ModelBaseEcon.Timer.printtimer"><code>printtimer</code></a></p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; inittimer()

julia&gt; @timer Base.sleep(1.0)

julia&gt; printtimer()
[...]</code></pre></div></section></article><h2 id="ModelBaseEcon"><a class="docs-heading-anchor" href="#ModelBaseEcon">ModelBaseEcon</a><a id="ModelBaseEcon-1"></a><a class="docs-heading-anchor-permalink" href="#ModelBaseEcon" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.ModelBaseEcon" href="#ModelBaseEcon.ModelBaseEcon"><code>ModelBaseEcon.ModelBaseEcon</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">ModelBaseEcon</code></pre><p>This package is part of the StateSpaceEcon ecosystem.  It contains the basic elements needed for model definition. StateSpaceEcon works with model objects defined with ModelBaseEcon.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.Equation" href="#ModelBaseEcon.Equation"><code>ModelBaseEcon.Equation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Equation &lt;: AbstractEquation</code></pre><p>Data structure representing a single equation in our state space model.</p><p><strong>Methods (for users)</strong></p><ul><li>TODO</li></ul><p><strong>Implementation (for developers)</strong></p><p>During the phase of definition of the Model, this type simply stores the expression entered by the user. During @initialize(), the true data structure is constructed. We need this, because the construction of the equation requaires information from the Model object, which may not be available at the time the equation expression is first read.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.LinearizationError" href="#ModelBaseEcon.LinearizationError"><code>ModelBaseEcon.LinearizationError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LinearizationError &lt;: ModelErrorBase</code></pre><p>A concrete error type used when a model cannot be linearized for some reason.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.Model" href="#ModelBaseEcon.Model"><code>ModelBaseEcon.Model</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Model &lt;: AbstractModel</code></pre><p>Data structure that represents a macroeconomic state space model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.ModelError" href="#ModelBaseEcon.ModelError"><code>ModelBaseEcon.ModelError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ModelError &lt;: ModelErrorBase</code></pre><p>Concrete error type used when no specific error description is available.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.ModelErrorBase" href="#ModelBaseEcon.ModelErrorBase"><code>ModelBaseEcon.ModelErrorBase</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ModelErrorBase</code></pre><p>Abstract error type, base for specific error types used in ModelBaseEcon.</p><p><strong>Implementation (note for developers)</strong></p><p>When implementing a derived error type, override two functions:</p><ul><li><code>msg(e::SomeModelError)</code> returning a string with the error message;</li><li><code>hint(e::SomeModelError)</code> returning a string containing a suggestion of how to fix the problem. Optional, if not implemented for a type, the fallback implementation returns an empty string.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.ModelNotInitError" href="#ModelBaseEcon.ModelNotInitError"><code>ModelBaseEcon.ModelNotInitError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ModelNotInitError &lt;: ModelErrorBase</code></pre><p>Specific error type used when there&#39;s an attempt to use a Model object that has not been initialized.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.NotImplementedError" href="#ModelBaseEcon.NotImplementedError"><code>ModelBaseEcon.NotImplementedError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct NotImplementedError &lt;: ModelErrorBase</code></pre><p>Specific error type used when a feature is planned but not yet implemented. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.SteadyStateData" href="#ModelBaseEcon.SteadyStateData"><code>ModelBaseEcon.SteadyStateData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SteadyStateData</code></pre><p>Data structure that holds information about the steady state solution of the Model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.SteadyStateEquation" href="#ModelBaseEcon.SteadyStateEquation"><code>ModelBaseEcon.SteadyStateEquation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct SteadyStateEquation &lt;: AbstractEquation</code></pre><p>Data structure representing an individual steady state equation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.alleqns-Tuple{SteadyStateData}" href="#ModelBaseEcon.alleqns-Tuple{SteadyStateData}"><code>ModelBaseEcon.alleqns</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">alleqns(ssd::SteadyStateData)</code></pre><p>Return a list of all steady state equations. </p><p>The list contains all equations derived from the dynamic system and all explicitly added steady state constraints.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.eval_R!" href="#ModelBaseEcon.eval_R!"><code>ModelBaseEcon.eval_R!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_R!(res::AbstractArray{Float64,1}, point::AbstractArray{Float64, 2}, ::MED) where MED &lt;: AbstractModelEvaluationData</code></pre><p>Evaluate the model residual at the given point using the given model evaluation structure. The residual is stored in the provided vector.</p><p><strong>Implementation details (for developers)</strong></p><p>When creating a new type of model evaluation data, you must define a method of this function specialized to it.</p><p>The <code>point</code> argument will be a 2d array, with the number of rows equal to <code>maxlag+maxlead+1</code> and the number of columns equal to the number of <code>variables+shocks+auxvars</code> of the model. The <code>res</code> vector will have the same length as the number of equations + auxiliary equations.  Your implementation must not modify <code>point</code> and must update <code>res</code>.</p><p>See also: <a href="#ModelBaseEcon.eval_RJ"><code>eval_RJ</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.eval_RJ" href="#ModelBaseEcon.eval_RJ"><code>ModelBaseEcon.eval_RJ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_RJ(point::AbstractArray{Float64, 2}, ::MED) where MED &lt;: AbstractModelEvaluationData</code></pre><p>Evaluate the model residual and its Jacobian at the given point using the given model evaluation structure. Return a tuple, with the first element being the residual and the second element being the Jacobian.</p><p><strong>Implementation details (for developers)</strong></p><p>When creating a new type of model evaluation data, you must define a method of this function specialized to it.</p><p>The <code>point</code> argument will be a 2d array, with the number of rows equal to <code>maxlag+maxlead+1</code> and the number of columns equal to the number of <code>variables+shocks+auxvars</code> of the model. Your implementation must not modify <code>point</code> and must return the tuple of (residual, Jacobian) evaluated at the given <code>point</code>. The Jacobian is expected to be <code>SparseMatrixCSC</code> (<em>this might change in the future</em>).</p><p>See also: <a href="#ModelBaseEcon.eval_R!"><code>eval_R!</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.geteqn-Tuple{Integer,SteadyStateData}" href="#ModelBaseEcon.geteqn-Tuple{Integer,SteadyStateData}"><code>ModelBaseEcon.geteqn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">geteqn(i, ssd::SteadyStateData)</code></pre><p>Return the i-th steady state equation. Index i is interpreted as in the output of <code>alleqns</code>. Calling <code>geteqn(i, sdd)</code> has the same effect as <code>alleqn(ssd)[i]</code>, but it&#39;s more efficient.</p><p><strong>Example</strong></p><pre><code class="language-julia"># Iterate all equations like this:
for i = 1:neqns(ssd)
    eqn = geteqn(i, ssd)
    # do something awesome with `eqn` and `i`
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.islinearized-Tuple{Model}" href="#ModelBaseEcon.islinearized-Tuple{Model}"><code>ModelBaseEcon.islinearized</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">islinearized(m::Model)</code></pre><p>Return <code>true</code> if the given model is linearized and <code>false</code> otherwise.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.issssolved-Tuple{SteadyStateData}" href="#ModelBaseEcon.issssolved-Tuple{SteadyStateData}"><code>ModelBaseEcon.issssolved</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">issssolved(sstate::SteadyStateData)</code></pre><p>Return <code>true</code> if the steady state has been solved, or <code>false</code> otherwise.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.linearize!" href="#ModelBaseEcon.linearize!"><code>ModelBaseEcon.linearize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">linearize!(model::Model; &lt;keyword arguments&gt;)</code></pre><p>Transform model into its linear approximation about its steady state.</p><p><strong>Keyword arguments</strong></p><ul><li><code>sstate</code> - linearize about the provided steady state solution</li><li><code>deviation</code>::Bool - whether or not the linearized model will tread data passed </li></ul><p>to is as deviation from the steady state</p><p>See also: <a href="#ModelBaseEcon.linearized-Tuple{Model}"><code>linearized</code></a> and <a href="#ModelBaseEcon.with_linearized-Tuple{Function,Model}"><code>with_linearized</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.linearized-Tuple{Model}" href="#ModelBaseEcon.linearized-Tuple{Model}"><code>ModelBaseEcon.linearized</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">linearized(model::Model; &lt;arguments&gt;)</code></pre><p>Create a new model that is the linear approximation of the given model about its steady state.</p><p><strong>Keyword arguments</strong></p><ul><li><code>sstate</code> - linearize about the provided steady state solution</li><li><code>deviation</code>::Bool - whether or not the linearized model will tread data passed </li></ul><p>to is as deviation from the steady state</p><p>See also: <a href="#ModelBaseEcon.linearize!"><code>linearize!</code></a> and <a href="#ModelBaseEcon.with_linearized-Tuple{Function,Model}"><code>with_linearized</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.neqns-Tuple{SteadyStateData}" href="#ModelBaseEcon.neqns-Tuple{SteadyStateData}"><code>ModelBaseEcon.neqns</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">neqns(ssd::SteadyStateData)</code></pre><p>Return the total number of equations in the steady state system, including the ones derived from the dynamic system and the ones added explicitly as steady state constraints.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.printsstate-Tuple{IO,SteadyStateData}" href="#ModelBaseEcon.printsstate-Tuple{IO,SteadyStateData}"><code>ModelBaseEcon.printsstate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">printsstate([io::IO,] ssd::SteadyStateData)</code></pre><p>Display steady state solution.</p><p>Steady state solution is presented in a table, where the first column is the name of the variable, the second and third columns are the corresponding values of the level and the slope. If the value is not determined (as per its <code>mask</code> value) then it is displayed as &quot;*&quot;.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.with_linearized-Tuple{Function,Model}" href="#ModelBaseEcon.with_linearized-Tuple{Function,Model}"><code>ModelBaseEcon.with_linearized</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">with_linearized(F::Function, model::Model; &lt;arguments&gt;)</code></pre><p>Apply the given function on a new model that is the linear approximation  of the given model about its steady state.  This is meant to be used with the <code>do</code> syntax, as in the example below.</p><p><strong>Keyword arguments</strong></p><ul><li><code>sstate</code> - linearize about the provided steady state solution</li><li><code>deviation</code>::Bool - whether or not the linearized model will tread data passed </li></ul><p>to is as deviation from the steady state</p><p>See also: <a href="#ModelBaseEcon.linearize!"><code>linearize!</code></a> and <a href="#ModelBaseEcon.with_linearized-Tuple{Function,Model}"><code>with_linearized</code></a></p><p><strong>Example</strong></p><pre><code class="language-julia">with_linearized(m) do lm
    # do something awesome with linearized model `lm`
end
# model `m` is still non-linear.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@autoexogenize-Tuple{Any,Vararg{Expr,N} where N}" href="#ModelBaseEcon.@autoexogenize-Tuple{Any,Vararg{Expr,N} where N}"><code>ModelBaseEcon.@autoexogenize</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@autoexogenize model begin
    varname = shkname
    ...
end</code></pre><p>Define a mapping between variables and shocks that can be used to conveniently  swap exogenous and endogenous variables.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@autoshocks-Tuple{Any}" href="#ModelBaseEcon.@autoshocks-Tuple{Any}"><code>ModelBaseEcon.@autoshocks</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@autoshocks model</code></pre><p>Create a list of shocks that matches the list of variables.  Each shock name is created from a variable name by appending &quot;_shk&quot;.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@equations-Tuple{Any,Expr}" href="#ModelBaseEcon.@equations-Tuple{Any,Expr}"><code>ModelBaseEcon.@equations</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Usage example:</p><pre><code class="language-none">@equations model begin
    y[t] = a * y[t-1] + b * y[t+1] + y_shk[t]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@initialize-Tuple{Symbol}" href="#ModelBaseEcon.@initialize-Tuple{Symbol}"><code>ModelBaseEcon.@initialize</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@initialize model</code></pre><p>Prepare a model instance for analysis. Call this macro after all variable names, shock names and equations have been defined.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@load_example-Tuple{Any}" href="#ModelBaseEcon.@load_example-Tuple{Any}"><code>ModelBaseEcon.@load_example</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Deprecated. Use <code>@using_example</code> instead.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@parameters-Tuple{Any,Vararg{Expr,N} where N}" href="#ModelBaseEcon.@parameters-Tuple{Any,Vararg{Expr,N} where N}"><code>ModelBaseEcon.@parameters</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@parameters model begin
    name = value
    ...
end</code></pre><p>Declare and define the model parameters. </p><p>The parameters must have values. Provide the information in a series of assignment statements wrapped inside a begin-end block. The names can be used in equations as if they were regular variables.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@shocks-Tuple{Any,Expr}" href="#ModelBaseEcon.@shocks-Tuple{Any,Expr}"><code>ModelBaseEcon.@shocks</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@shocks model names...
@shocks model begin
    names...
end</code></pre><p>Define the names of transition shocks in the model.</p><p><strong>Example</strong></p><p>```jldoctest @shocks model a<em>shk b</em>shk c_shk</p><p><strong>If the list is long, use a begin-end block separating names with newline or semicolon</strong></p><p>@shocks model begin     a<em>shk; b</em>shk     c_shk end ````</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@steadystate-Tuple{Any,Symbol,Expr}" href="#ModelBaseEcon.@steadystate-Tuple{Any,Symbol,Expr}"><code>ModelBaseEcon.@steadystate</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@steadystate model [type] equation</code></pre><p>Add a steady state equation to the model.</p><p>The steady state system of the model is automatically derived from the dynamic system. Use this macro to define additional equations for the steady state. This is particularly useful in the case of a non-linear model that might have multiple steady state, or the steady state might be difficult to solve for, to help the steady state solver find the one you want to use.</p><ul><li><code>model</code> is the model instance you want to update</li><li><code>type</code> (optional) is the type of constraint you want to add. This can be <code>level</code></li></ul><p>or <code>slope</code>. If missing, the default is <code>level</code></p><ul><li><code>equation</code> is the expression defining the steady state constraint. In the</li></ul><p>equation, use variables and shocks from the model, but without any t-references.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@using_example-Tuple{Any}" href="#ModelBaseEcon.@using_example-Tuple{Any}"><code>ModelBaseEcon.@using_example</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@using_example name</code></pre><p>Load models from the package examples/ folder. The <code>@load_example</code> version is deprecated - stop using it now.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@variables-Tuple{Any,Expr}" href="#ModelBaseEcon.@variables-Tuple{Any,Expr}"><code>ModelBaseEcon.@variables</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@variables model names...
@variables model begin
    names...
end</code></pre><p>Define the names of transition variables in the model.</p><p><strong>Example</strong></p><p>```jldoctest @variables model a b c</p><p><strong>If the list is long, use a begin-end block separating names with newline or semicolon</strong></p><p>@variables model begin     a; b     c end ````</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../TimeSeriesEcon/">« TimeSeriesEcon</a><a class="docs-footer-nextpage" href="../StateSpaceEcon/">StateSpaceEcon »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 24 August 2020 18:55">Monday 24 August 2020</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
