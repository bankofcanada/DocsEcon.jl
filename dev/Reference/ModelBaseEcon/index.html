<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ModelBaseEcon · StateSpaceEcon</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="StateSpaceEcon logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">StateSpaceEcon</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../Tutorials/">Introduction</a></li><li><a class="tocitem" href="../../Tutorials/README/">README</a></li><li><a class="tocitem" href="../../Tutorials/1.TimeSeriesEcon/main/">Time Series</a></li><li><a class="tocitem" href="../../Tutorials/2.simple_RBC/main/">Simple RBC Model</a></li><li><a class="tocitem" href="../../Tutorials/3.US_SW07/main/">Smets and Wouters 2007</a></li><li><a class="tocitem" href="../../Tutorials/4.FRB-US/main/">FRB/US</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../TimeSeriesEcon/">TimeSeriesEcon</a></li><li class="is-active"><a class="tocitem" href>ModelBaseEcon</a></li><li><a class="tocitem" href="../StateSpaceEcon/">StateSpaceEcon</a></li><li><a class="tocitem" href="../FAME/">FAME</a></li></ul></li><li><span class="tocitem">Design Papers</span><ul><li><a class="tocitem" href="../../DesignPapers/">Design Papers</a></li><li><a class="tocitem" href="../../DesignPapers/final_conditions/">Final Conditions</a></li><li><a class="tocitem" href="../../DesignPapers/log_variables/">Log-variables</a></li></ul></li><li><a class="tocitem" href="../../indexpage/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>ModelBaseEcon</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>ModelBaseEcon</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/bankofcanada/DocsEcon.jl/blob/master/src/Reference/ModelBaseEcon.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ModelBaseEcon-Reference"><a class="docs-heading-anchor" href="#ModelBaseEcon-Reference">ModelBaseEcon Reference</a><a id="ModelBaseEcon-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#ModelBaseEcon-Reference" title="Permalink"></a></h1><ul></ul><h3 id="Public-interface"><a class="docs-heading-anchor" href="#Public-interface">Public interface</a><a id="Public-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Public-interface" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.ModelBaseEcon" href="#ModelBaseEcon.ModelBaseEcon"><code>ModelBaseEcon.ModelBaseEcon</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">ModelBaseEcon</code></pre><p>This package is part of the StateSpaceEcon ecosystem. It provides the basic elements needed for model definition. StateSpaceEcon works with model objects defined with ModelBaseEcon.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.Equation" href="#ModelBaseEcon.Equation"><code>ModelBaseEcon.Equation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Equation &lt;: AbstractEquation ⋯ end</code></pre><p>Data type representing a single equation in a model.</p><p>Equations are defined in <a href="#ModelBaseEcon.@equations-Tuple{Any, Expr}"><code>@equations</code></a> blocks. The actual equation instances are later created with <a href="#ModelBaseEcon.@initialize-Tuple{Symbol}"><code>@initialize</code></a> and stored within the model object.</p><p>Equation flags can be specified by annotating the equation definition with one or more <code>@&lt;flag&gt;</code>. See <a href="#ModelBaseEcon.EqnFlags"><code>EqnFlags</code></a> for details.</p><p>Each equation has two functions associated with it, one which computes the residual and the other computes both the residual and the gradient . Usually there&#39;s no need to users to call these functions directly. They are used internally by the solvers.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.LogTransform" href="#ModelBaseEcon.LogTransform"><code>ModelBaseEcon.LogTransform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LogTransform &lt;: Transformation</code></pre><p>The <code>log</code> transformation. The inverse is of course <code>exp</code>. This is the default for variables declared with <code>@log</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.Model" href="#ModelBaseEcon.Model"><code>ModelBaseEcon.Model</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Model &lt;: AbstractModel ⋯ end</code></pre><p>Data structure that represents a macroeconomic model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.ModelParam" href="#ModelBaseEcon.ModelParam"><code>ModelBaseEcon.ModelParam</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct ModelParam ⋯ end</code></pre><p>Contains a model parameter. For a simple parameter it simply stores its value. For a link or an alias, it stores the link information and also caches the current value for speed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.ModelVariable" href="#ModelBaseEcon.ModelVariable"><code>ModelBaseEcon.ModelVariable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ModelVariable ⋯ end</code></pre><p>Data type for model variables. <code>ModelVariable</code> functions like a <code>Symbol</code> in many respects, but also holds meta-information about the variable, such as doc string, the variable type, transformation, steady state behaviour.</p><p>Variable types include</p><ul><li><code>:var</code> - a regular variable is endogenous by default, but can be exogenized. </li><li><code>:shock</code> - a shock variable is exogenous by default, but can be endogenized. Steady state is 0.</li><li><code>:exog</code> - an exogenous variable is always exogenous. </li></ul><p>These can be declared with <a href="#ModelBaseEcon.@variables-Tuple{Any, Expr}"><code>@variables</code></a>, <a href="#ModelBaseEcon.@shocks-Tuple{Any, Expr}"><code>@shocks</code></a>, and  <a href="#ModelBaseEcon.@exogenous-Tuple{Any, Expr}"><code>@exogenous</code></a> blocks. You can also use <code>@exog</code> within an  <code>@variables</code> block to declare an exogenous variable.</p><p>Transformations include</p><ul><li><code>:none</code> - no transformation. This is the default. In steady state these variables exhibit linear growth.</li><li><code>:log</code> - logarithm. This is useful for variables that must be always strictly positive. Internally the solver work with the logarithm of the variable. in steady state these variables exhibit exponential growth (the log variable grows linearly).</li><li><code>:neglog</code> - same as <code>:log</code> but for variables that are strictly negative. </li></ul><p>These can be declared with <a href="#ModelBaseEcon.@logvariables-Tuple{Any, Expr}"><code>@logvariables</code></a>, <a href="#ModelBaseEcon.@neglogvariables-Tuple{Any, Expr}"><code>@neglogvariables</code></a>, <code>@log</code>, <code>@neglog</code>.</p><p>Steady state behaviours include</p><ul><li><code>:const</code> - these variables have zero slope in steady state and final conditions.</li><li><code>:growth</code> - these variables have constant slope in steady state and final conditions. The meaning of &quot;slope&quot; changes depending on the transformation. For <code>:log</code> and <code>:neglog</code> variables this is the growth rate, while for <code>:none</code> variables it is the usual slope of linear growth. </li></ul><p>Shock variables are always <code>:const</code> while regular variables are assumed <code>:growth</code>. They can be declared <code>:const</code> using <code>@steady</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.NegLogTransform" href="#ModelBaseEcon.NegLogTransform"><code>ModelBaseEcon.NegLogTransform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NegLogTransform &lt;: Transformation</code></pre><p>The <code>log(-x)</code>, with the inverse being <code>-exp(x)</code>. Use this when the variable is negative with exponential behaviour (toward -∞).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.NoTransform" href="#ModelBaseEcon.NoTransform"><code>ModelBaseEcon.NoTransform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoTransform &lt;: Transformation</code></pre><p>The identity transformation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.Parameters" href="#ModelBaseEcon.Parameters"><code>ModelBaseEcon.Parameters</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Parameters([mod::Module])</code></pre><p>When creating an instance of <code>Parameters</code>, optionally one can specify the module in which parameter expressions will be evaluated. This only matters if there are any link parameters that depend on custom functions or global variables/constants. In this case, the <code>mod</code> argument should be the module in which these definitions exist.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.Parameters" href="#ModelBaseEcon.Parameters"><code>ModelBaseEcon.Parameters</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Parameters &lt;: AbstractDict{Symbol, Any} ⋯ end</code></pre><p>Container for model parameters. It functions as a <code>Dict</code> where the keys are the parameter names. Simple parameter values are stored directly. Special parameters depend on other parameters are are wrapped in the appropriate data structures to keep track of such dependencies. There are two types of special parameters - aliases and links.</p><p>Individual parameters can be accessed in two different ways - dot and bracket notation.</p><p>Read access by dot notation calls <a href="#ModelBaseEcon.peval"><code>peval</code></a> while bracket notation doesn&#39;t. This makes no difference for simple parameters. For special parameters, access by bracket notation returns its internal structure, while access by dot notation returns its current value depending on other parameters.</p><p>Write access is the same in both dot and bracket notation. The new parameter value is assigned directly in the case of simple parameter. To create an alias parameter, use the <a href="#ModelBaseEcon.@alias-Tuple{Any}"><code>@alias</code></a> macro. To create a link parameter use the <a href="#ModelBaseEcon.@link-Tuple{Any}"><code>@link</code></a> macro.</p><p>See also: <a href="#ModelBaseEcon.ModelParam"><code>ModelParam</code></a>, <a href="#ModelBaseEcon.peval"><code>peval</code></a>, <a href="#ModelBaseEcon.@alias-Tuple{Any}"><code>@alias</code></a>, <a href="#ModelBaseEcon.@link-Tuple{Any}"><code>@link</code></a>, <a href="#ModelBaseEcon.update_links!-Tuple{ModelBaseEcon.AbstractModel}"><code>update_links!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.SteadyStateData" href="#ModelBaseEcon.SteadyStateData"><code>ModelBaseEcon.SteadyStateData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SteadyStateData</code></pre><p>Data structure that holds information about the steady state solution of the Model. This includes a collection of <a href="#ModelBaseEcon.SteadyStateVariable"><code>SteadyStateVariable</code></a>s and two collections of <a href="#ModelBaseEcon.SteadyStateEquation"><code>SteadyStateEquation</code></a>s - one for the steady state equations generated from dynamic equations and another for steady state constraints created with <a href="#ModelBaseEcon.@steadystate-Tuple{Any, Symbol, Expr}"><code>@steadystate</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.SteadyStateEquation" href="#ModelBaseEcon.SteadyStateEquation"><code>ModelBaseEcon.SteadyStateEquation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SteadyStateEquation &lt;: AbstractEquation ⋯ end</code></pre><p>Data structure representing an individual steady state equation.</p><p>Steady state equations can be constructed from the dynamic equations of the model. Each steady state variable has two unknowns, level and slope, so from each dynamic equation we construct two steady state equations.</p><p>Steady state equations can also be constructed with <a href="#ModelBaseEcon.@steadystate-Tuple{Any, Symbol, Expr}"><code>@steadystate</code></a> after <a href="#ModelBaseEcon.@initialize-Tuple{Symbol}"><code>@initialize</code></a> has been called. We call such equations steady state constraints.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.Transformation" href="#ModelBaseEcon.Transformation"><code>ModelBaseEcon.Transformation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Transformation end</code></pre><p>The base class for all variable transformations.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.add_equation!-Tuple{Model, Expr}" href="#ModelBaseEcon.add_equation!-Tuple{Model, Expr}"><code>ModelBaseEcon.add_equation!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_equation!(model::Model, expr::Expr; modelmodule::Module)</code></pre><p>Process the given expression in the context of the given module, create the Equation() instance for it, and add it to the model instance.</p><p>Usually there&#39;s no need to call this function directly. It is called during <a href="#ModelBaseEcon.@initialize-Tuple{Symbol}"><code>@initialize</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.alleqns-Tuple{SteadyStateData}" href="#ModelBaseEcon.alleqns-Tuple{SteadyStateData}"><code>ModelBaseEcon.alleqns</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">alleqns(ssd::SteadyStateData)</code></pre><p>Return a list of all steady state equations.</p><p>The list contains all explicitly added steady state constraints and all equations derived from the dynamic system.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.assign_parameters!" href="#ModelBaseEcon.assign_parameters!"><code>ModelBaseEcon.assign_parameters!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assign_parameters!(model, collection; [options])
assign_parameters!(model; [options], param=value, ...)</code></pre><p>Assign values to model parameters. New parameters can be given as key-value pairs in the function call, or in a collection, such as a <code>Dict</code>, for example.</p><p>Individual parameters can be assigned directly to the <code>model</code> using dot notation. This function should be more convenient when all parameters values are loaded from a file and available in a dictionary or some other key-value collection.</p><p>There are two options that control the behaviour.</p><ul><li><code>preserve_links=true</code> - if set to <code>true</code> new values for link-parameters are ignored and the link is updated automatically from the new values of parameters it depends on. If set to <code>false</code> any link parameters are overwritten and become non-link parameters set to the given new values.</li><li><code>check=true</code> - if a parameter with the given name does not exist we ignore it. When <code>check</code> is set to <code>true</code> we issue a warning, when set to <code>false</code> we ignore it silently.</li></ul><p>See also: <a href="#ModelBaseEcon.export_parameters"><code>export_parameters</code></a> and <a href="#ModelBaseEcon.export_parameters!-Tuple{Any, ModelBaseEcon.AbstractModel}"><code>export_parameters!</code></a></p><p>Example</p><pre><code class="nohighlight hljs">julia&gt; @using_example E1
julia&gt; assign_parameters(E1.model; α=0.3, β=0.7)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.assign_sstate!" href="#ModelBaseEcon.assign_sstate!"><code>ModelBaseEcon.assign_sstate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assign_sstate!(model, collection)
assign_sstate!(model; var = value, ...)</code></pre><p>Assign a steady state solution from the given collection of name=&gt;value pairs into the given model. </p><p>In each pair, the value can be a number in which case it is assigned as the level and the slope is set to 0. The value can also be a <code>Tuple</code> or a <code>Vector</code> in which case the first two elements are assigned as the level and the slope. Finally, the value can itself be a name-value collection (like a named tuple or a dictionary) with fields <code>:level</code> and <code>:slope</code>. Variables whose steady states are found in the collection are assigned and also marked as solved.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.eval_R!" href="#ModelBaseEcon.eval_R!"><code>ModelBaseEcon.eval_R!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eval_R!(res::AbstractArray{Float64,1}, point::AbstractArray{Float64, 2}, ::MED) where MED &lt;: AbstractModelEvaluationData</code></pre><p>Evaluate the model residual at the given point using the given model evaluation structure. The residual is stored in the provided vector.</p><p><strong>Implementation details (for developers)</strong></p><p>When creating a new type of model evaluation data, you must define a method of this function specialized to it.</p><p>The <code>point</code> argument will be a 2d array, with the number of rows equal to <code>maxlag+maxlead+1</code> and the number of columns equal to the number of <code>variables+shocks+auxvars</code> of the model. The <code>res</code> vector will have the same length as the number of equations + auxiliary equations. Your implementation must not modify <code>point</code> and must update <code>res</code>.</p><p>See also: <a href="#ModelBaseEcon.eval_RJ"><code>eval_RJ</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.eval_RJ" href="#ModelBaseEcon.eval_RJ"><code>ModelBaseEcon.eval_RJ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eval_RJ(point::AbstractArray{Float64, 2}, ::MED) where MED &lt;: AbstractModelEvaluationData</code></pre><p>Evaluate the model residual and its Jacobian at the given point using the given model evaluation structure. Return a tuple, with the first element being the residual and the second element being the Jacobian.</p><p><strong>Implementation details (for developers)</strong></p><p>When creating a new type of model evaluation data, you must define a method of this function specialized to it.</p><p>The <code>point</code> argument will be a 2d array, with the number of rows equal to <code>maxlag+maxlead+1</code> and the number of columns equal to the number of <code>variables+shocks+auxvars</code> of the model. Your implementation must not modify <code>point</code> and must return the tuple of (residual, Jacobian) evaluated at the given <code>point</code>. The Jacobian is expected to be <code>SparseMatrixCSC</code> (<em>this might change in the future</em>).</p><p>See also: <a href="#ModelBaseEcon.eval_R!"><code>eval_R!</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.export_model" href="#ModelBaseEcon.export_model"><code>ModelBaseEcon.export_model</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">export_model(model, name, file::IO)
export_model(model, name, path::String)</code></pre><p>Export the model into a module file. The <code>name</code> parameter is used for the name of the module as well as the module file. The module file is created in the directory specified by the optional third argument.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.export_parameters" href="#ModelBaseEcon.export_parameters"><code>ModelBaseEcon.export_parameters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">export_parameters(model; include_links=true)
export_parameters(parameters; include_links=true)</code></pre><p>Write all parameters into a <code>Dict{Symbol, Any}</code>. For link and alias parameter, only their current value is stored, the linking information is not. Set <code>include_links=false</code> to suppress the writing of link and alias parameters.</p><p>Use <a href="#ModelBaseEcon.assign_parameters!"><code>assign_parameters!</code></a> to restore the parameters values from the container created here.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.export_parameters!-Tuple{Any, ModelBaseEcon.AbstractModel}" href="#ModelBaseEcon.export_parameters!-Tuple{Any, ModelBaseEcon.AbstractModel}"><code>ModelBaseEcon.export_parameters!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">export_parameters!(container, model; include_links=true)
export_parameters!(container, parameters; include_links=true)</code></pre><p>Write all parameters into the given <code>container</code>. The parameters are <code>push!</code>-ed as <code>name =&gt; value</code> pairs. For link and alias parameter, only their current value is stored, the linking information is not. Set <code>include_links=false</code> to suppress the writing of link and alias parameters.</p><p>Use <a href="#ModelBaseEcon.assign_parameters!"><code>assign_parameters!</code></a> to restore the parameters values from the container created here.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.export_sstate" href="#ModelBaseEcon.export_sstate"><code>ModelBaseEcon.export_sstate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">export_sstate(model)</code></pre><p>Return a dictionary containing the steady state solution stored in the given model. The value for each variable will be a number, if the variable has zero slope, or a named tuple <code>(level = NUM, slope=NUM)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.export_sstate!" href="#ModelBaseEcon.export_sstate!"><code>ModelBaseEcon.export_sstate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">export_sstate!(container, model)</code></pre><p>Fill the given container with the steady state solution stored in the  given model. The value for each variable will be a number, if the variable has zero slope, or else a named tuple of the form <code>(level = NUM, slope=NUM)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.fullprint" href="#ModelBaseEcon.fullprint"><code>ModelBaseEcon.fullprint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fullprint(model)</code></pre><p>If a model contains more than 20 variables or more than 20 equations, its display is truncated. In this case you can call <code>fullprint</code> to see the whole model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.geteqn-Tuple{Integer, SteadyStateData}" href="#ModelBaseEcon.geteqn-Tuple{Integer, SteadyStateData}"><code>ModelBaseEcon.geteqn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">geteqn(i, ssd::SteadyStateData)</code></pre><p>Return the i-th steady state equation. Index i is interpreted as in the output of <a href="#ModelBaseEcon.alleqns-Tuple{SteadyStateData}"><code>alleqns(::SteadyStateData)</code></a>. Calling <code>geteqn(i, sdd)</code> has the same effect as <code>alleqn(ssd)[i]</code>, but it&#39;s more efficient.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Iterate all equations like this:
for i = 1:neqns(ssd)
    eqn = geteqn(i, ssd)
    # do something awesome with `eqn` and `i`
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.inverse_transform" href="#ModelBaseEcon.inverse_transform"><code>ModelBaseEcon.inverse_transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inverse_transform(x, var::ModelVariable)</code></pre><p>Apply the inverse transformation associated with model variable <code>m</code> to data <code>x</code>.</p><p>See also <a href="#ModelBaseEcon.inverse_transformation"><code>inverse_transformation</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.inverse_transformation" href="#ModelBaseEcon.inverse_transformation"><code>ModelBaseEcon.inverse_transformation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inverse_transformation(::Type{&lt;:Transformation})</code></pre><p>Return a <code>Function</code> that will be called to transform the simulation data after solving. See also <a href="#ModelBaseEcon.transformation"><code>transformation</code></a>.</p><p>It is expected that <code>transformation(T) ∘ inverse_transformation(T) == identity</code> and <code>inverse_transformation(T) ∘ transformation(T) == identity</code>, but these is not verified.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.isexog-Tuple{ModelVariable}" href="#ModelBaseEcon.isexog-Tuple{ModelVariable}"><code>ModelBaseEcon.isexog</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isexog(v)</code></pre><p>Return <code>true</code> if the given <code>ModelVariable</code> is exogenous, otherwise return <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.islin-Tuple{ModelVariable}" href="#ModelBaseEcon.islin-Tuple{ModelVariable}"><code>ModelBaseEcon.islin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">islin(v)</code></pre><p>Return <code>true</code> if the given <code>ModelVariable</code> is a no-transformation variable, otherwise return <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.islinearized-Tuple{Model}" href="#ModelBaseEcon.islinearized-Tuple{Model}"><code>ModelBaseEcon.islinearized</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">islinearized(model::Model)</code></pre><p>Return <code>true</code> if the given model is linearized and <code>false</code> otherwise.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.islog-Tuple{ModelVariable}" href="#ModelBaseEcon.islog-Tuple{ModelVariable}"><code>ModelBaseEcon.islog</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">islog(v)</code></pre><p>Return <code>true</code> if the given <code>ModelVariable</code> is a log-transformation variable, otherwise return <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.isneglog-Tuple{ModelVariable}" href="#ModelBaseEcon.isneglog-Tuple{ModelVariable}"><code>ModelBaseEcon.isneglog</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isneglog(v)</code></pre><p>Return <code>true</code> if the given <code>ModelVariable</code> is a negative-log-transformation variable, otherwise return <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.isshock-Tuple{ModelVariable}" href="#ModelBaseEcon.isshock-Tuple{ModelVariable}"><code>ModelBaseEcon.isshock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isshock(v)</code></pre><p>Return <code>true</code> if the given <code>ModelVariable</code> is a shock, otherwise return <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.issssolved-Tuple{SteadyStateData}" href="#ModelBaseEcon.issssolved-Tuple{SteadyStateData}"><code>ModelBaseEcon.issssolved</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">issssolved(sstate::SteadyStateData)</code></pre><p>Return <code>true</code> if the steady state has been solved, or <code>false</code> otherwise.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This function only checks that the steady state is marked as solved. It does not verify that the stored steady state values actually satisfy the steady state system of equations. Use <code>check_sstate</code> from StateSpaceEcon for that.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.issteady-Tuple{ModelVariable}" href="#ModelBaseEcon.issteady-Tuple{ModelVariable}"><code>ModelBaseEcon.issteady</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">issteady(v)</code></pre><p>Return <code>true</code> if the given <code>ModelVariable</code> is zero-slope, otherwise return <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.linearize!" href="#ModelBaseEcon.linearize!"><code>ModelBaseEcon.linearize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">linearize!(model::Model; &lt;keyword arguments&gt;)</code></pre><p>Transform model into its linear approximation about its steady state.</p><p><strong>Keyword arguments</strong></p><ul><li><code>sstate</code> - linearize about the provided steady state solution</li><li><code>deviation</code>::Bool - whether or not the linearized model will treat data passed to it as deviation from the steady state</li></ul><p>See also: <a href="#ModelBaseEcon.linearized-Tuple{Model}"><code>linearized</code></a> and <a href="#ModelBaseEcon.with_linearized-Tuple{Function, Model}"><code>with_linearized</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.linearized-Tuple{Model}" href="#ModelBaseEcon.linearized-Tuple{Model}"><code>ModelBaseEcon.linearized</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">linearized(model::Model; &lt;arguments&gt;)</code></pre><p>Create a new model that is the linear approximation of the given model about its steady state.</p><p><strong>Keyword arguments</strong></p><ul><li><code>sstate</code> - linearize about the provided steady state solution</li><li><code>deviation</code>::Bool - whether or not the linearized model will tread data passed </li></ul><p>to is as deviation from the steady state</p><p>See also: <a href="#ModelBaseEcon.linearize!"><code>linearize!</code></a> and <a href="#ModelBaseEcon.with_linearized-Tuple{Function, Model}"><code>with_linearized</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.logm-Tuple{Any}" href="#ModelBaseEcon.logm-Tuple{Any}"><code>ModelBaseEcon.logm</code></a> — <span class="docstring-category">Method</span></header><section><div><p>logm(x) = log(-x)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.mexp-Tuple{Any}" href="#ModelBaseEcon.mexp-Tuple{Any}"><code>ModelBaseEcon.mexp</code></a> — <span class="docstring-category">Method</span></header><section><div><p>mexp(x) = -exp(x)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.need_transform" href="#ModelBaseEcon.need_transform"><code>ModelBaseEcon.need_transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">need_transform(v)</code></pre><p>Return <code>true</code> if there is a transformation associated with model variable <code>v</code>, otherwise return <code>false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.neqns-Tuple{SteadyStateData}" href="#ModelBaseEcon.neqns-Tuple{SteadyStateData}"><code>ModelBaseEcon.neqns</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">neqns(ssd::SteadyStateData)</code></pre><p>Return the total number of equations in the steady state system, including the ones added explicitly as steady state constraints and the ones derived from the dynamic system.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.peval" href="#ModelBaseEcon.peval"><code>ModelBaseEcon.peval</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">peval(params, what)</code></pre><p>Evaluate the given expression in the context of the given parameters <code>params</code>.</p><p>If <code>what</code> is a <code>ModelParam</code>, its current value is returned. If it&#39;s a link and  there&#39;s a chance it might be out of date, call <a href="#ModelBaseEcon.update_links!-Tuple{ModelBaseEcon.AbstractModel}"><code>update_links!</code></a>.</p><p>If <code>what</code> is a Symbol or an Expr, all mentions of parameter names are substituted by their values and the expression is evaluated.</p><p>If <code>what is any other value, it is returned unchanged.</code></p><p>See also: <a href="#ModelBaseEcon.Parameters"><code>Parameters</code></a>, <a href="#ModelBaseEcon.@alias-Tuple{Any}"><code>@alias</code></a>, <a href="#ModelBaseEcon.@link-Tuple{Any}"><code>@link</code></a>, <a href="#ModelBaseEcon.ModelParam"><code>ModelParam</code></a>, <a href="#ModelBaseEcon.update_links!-Tuple{ModelBaseEcon.AbstractModel}"><code>update_links!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.print_linearized" href="#ModelBaseEcon.print_linearized"><code>ModelBaseEcon.print_linearized</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">print_linearized(io, model)
print_linearized(model)</code></pre><p>Write the system of equations of the linearized model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.printsstate-Tuple{IO, ModelBaseEcon.AbstractModel}" href="#ModelBaseEcon.printsstate-Tuple{IO, ModelBaseEcon.AbstractModel}"><code>ModelBaseEcon.printsstate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">printsstate([io::IO,] ssd::SteadyStateData)</code></pre><p>Display steady state solution.</p><p>Steady state solution is presented in a table, where the first column is the name of the variable, the second and third columns are the corresponding values of the level and the slope. If the value is not determined (as per its <code>mask</code> value) then it is displayed as &quot;*&quot;.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.refresh_med!" href="#ModelBaseEcon.refresh_med!"><code>ModelBaseEcon.refresh_med!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">refresh_med!(model)</code></pre><p>Refresh the model evaluation data stored within the given model instance. Most notably, this is necessary when the steady state is used in the dynamic equations.</p><p>Normally there&#39;s no need for the end-used to call this function. It should be called when necessay by the solver.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.selective_linearize!-Tuple{ModelBaseEcon.AbstractModel}" href="#ModelBaseEcon.selective_linearize!-Tuple{ModelBaseEcon.AbstractModel}"><code>ModelBaseEcon.selective_linearize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">selective_linearize!(model)</code></pre><p>Instruct the model instance to use selective linearization. Only equations annotated with <code>@lin</code> in the model definition will be linearized about the current steady state solution while the rest of the eq</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.to_exog-Tuple{Any}" href="#ModelBaseEcon.to_exog-Tuple{Any}"><code>ModelBaseEcon.to_exog</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_exog(v)</code></pre><p>Make an exogenous <code>ModelVariable</code> from <code>v</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.to_lin-Tuple{Any}" href="#ModelBaseEcon.to_lin-Tuple{Any}"><code>ModelBaseEcon.to_lin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_lin(v)</code></pre><p>Make a no-transformation <code>ModelVariable</code> from <code>v</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.to_log-Tuple{Any}" href="#ModelBaseEcon.to_log-Tuple{Any}"><code>ModelBaseEcon.to_log</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_log(v)</code></pre><p>Make a log-transformation <code>ModelVariable</code> from <code>v</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.to_neglog-Tuple{Any}" href="#ModelBaseEcon.to_neglog-Tuple{Any}"><code>ModelBaseEcon.to_neglog</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_neglog(v)</code></pre><p>Make a negative-log-transformation <code>ModelVariable</code> from <code>v</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.to_shock-Tuple{Any}" href="#ModelBaseEcon.to_shock-Tuple{Any}"><code>ModelBaseEcon.to_shock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_shock(v)</code></pre><p>Make a shock <code>ModelVariable</code> from <code>v</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.to_steady-Tuple{Any}" href="#ModelBaseEcon.to_steady-Tuple{Any}"><code>ModelBaseEcon.to_steady</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_steady(v)</code></pre><p>Make a zero-slope <code>ModelVariable</code> from <code>v</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.transform" href="#ModelBaseEcon.transform"><code>ModelBaseEcon.transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform(x, var::ModelVariable)</code></pre><p>Apply the transformation associated with model variable <code>m</code> to data <code>x</code>.</p><p>See also <a href="#ModelBaseEcon.transformation"><code>transformation</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.transformation" href="#ModelBaseEcon.transformation"><code>ModelBaseEcon.transformation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transformation(::Type{&lt;:Transformation})</code></pre><p>Return a <code>Function</code> that will be substituted into the model equations and will be called to transform the input data before solving. See also <a href="#ModelBaseEcon.inverse_transformation"><code>inverse_transformation</code></a>.</p><p>It is expected that <code>transformation(T) ∘ inverse_transformation(T) == identity</code> and <code>inverse_transformation(T) ∘ transformation(T) == identity</code>, but these is not verified.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.update_links!-Tuple{ModelBaseEcon.AbstractModel}" href="#ModelBaseEcon.update_links!-Tuple{ModelBaseEcon.AbstractModel}"><code>ModelBaseEcon.update_links!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_links!(model)
update_links!(params)</code></pre><p>Recompute the current values of all parameters.</p><p>Typically when a new value of a parameter is assigned, all parameter links and aliases that depend on it are updated recursively. If a parameter is mutable, e.g. a Vector or another collection, its value can be updated in place without re-assigning the parameter, thus the automatic update does not happen. In this case, it is necessary to call <code>update_links!</code> manually.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.with_linearized-Tuple{Function, Model}" href="#ModelBaseEcon.with_linearized-Tuple{Function, Model}"><code>ModelBaseEcon.with_linearized</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">with_linearized(F::Function, model::Model; &lt;arguments&gt;)</code></pre><p>Apply the given function on a new model that is the linear approximation  of the given model about its steady state.  This is meant to be used with the <code>do</code> syntax, as in the example below.</p><p><strong>Keyword arguments</strong></p><ul><li><code>sstate</code> - linearize about the provided steady state solution</li><li><code>deviation</code>::Bool - whether or not the linearized model will tread data passed </li></ul><p>to is as deviation from the steady state</p><p>See also: <a href="#ModelBaseEcon.linearize!"><code>linearize!</code></a> and <a href="#ModelBaseEcon.with_linearized-Tuple{Function, Model}"><code>with_linearized</code></a></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">with_linearized(m) do lm
    # do something awesome with linearized model `lm`
end
# model `m` is still non-linear.</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@alias-Tuple{Any}" href="#ModelBaseEcon.@alias-Tuple{Any}"><code>ModelBaseEcon.@alias</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@alias name</code></pre><p>Create a parameter alias. Use <code>@alias</code> in the <a href="#ModelBaseEcon.@parameters-Tuple{Any, Vararg{Expr}}"><code>@parameters</code></a> section of your model definition.</p><pre><code class="nohighlight hljs">@parameters model begin
    a = 5
    b = @alias a
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@autoexogenize-Tuple{Any, Vararg{Expr}}" href="#ModelBaseEcon.@autoexogenize-Tuple{Any, Vararg{Expr}}"><code>ModelBaseEcon.@autoexogenize</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@autoexogenize model begin
    varname = shkname
    ...
end</code></pre><p>Define a mapping between variables and shocks that can be used to conveniently  swap exogenous and endogenous variables.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@autoshocks" href="#ModelBaseEcon.@autoshocks"><code>ModelBaseEcon.@autoshocks</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@autoshocks model [suffix]</code></pre><p>Create a list of shocks that matches the list of variables. Each shock name is created from a variable name by appending suffix. Default suffix is &quot;_shk&quot;, but it can be specified as the second argument too.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@d-Tuple" href="#ModelBaseEcon.@d-Tuple"><code>ModelBaseEcon.@d</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@d(expr[, n=1 [, s=0 ]])</code></pre><p>Apply the difference operator to the given expression. If <code>L</code> represents the lag operator, then we have the following definitions.</p><pre><code class="nohighlight hljs">@d(x[t]) = (1-L)x = x[t]-x[t-1]
@d(x[t], n) = (1-L)^n x
@d(x[t], n, s) = (1-L)^n (1-L^s) x</code></pre><p>See also <a href="#ModelBaseEcon.@lag-Tuple"><code>@lag</code></a>, <a href="#ModelBaseEcon.@d-Tuple"><code>@d</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@dlog-Tuple" href="#ModelBaseEcon.@dlog-Tuple"><code>ModelBaseEcon.@dlog</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@dlog(expr[, n=1 [, s=0 ]])</code></pre><p>Apply the difference operator on the log() of the given expression. Equivalent to @d(log(expr), n, s).</p><p>See also <a href="#ModelBaseEcon.@lag-Tuple"><code>@lag</code></a>, <a href="#ModelBaseEcon.@d-Tuple"><code>@d</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@equations-Tuple{Any, Expr}" href="#ModelBaseEcon.@equations-Tuple{Any, Expr}"><code>ModelBaseEcon.@equations</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@equations model begin
    lhs = rhs
    lhs = rhs
    ...
end</code></pre><p>Define model equations. See <a href="#ModelBaseEcon.Equation"><code>Equation</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@exogenous-Tuple{Any, Expr}" href="#ModelBaseEcon.@exogenous-Tuple{Any, Expr}"><code>ModelBaseEcon.@exogenous</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@exogenous</code></pre><p>Like <a href="#ModelBaseEcon.@variables-Tuple{Any, Expr}"><code>@variables</code></a>, but the names declared with <code>@exogenous</code> are exogenous.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@initialize-Tuple{Symbol}" href="#ModelBaseEcon.@initialize-Tuple{Symbol}"><code>ModelBaseEcon.@initialize</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@initialize model</code></pre><p>Prepare a model instance for analysis. Call this macro after all parameters, variable names, shock names and equations have been declared and defined.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@lag-Tuple" href="#ModelBaseEcon.@lag-Tuple"><code>ModelBaseEcon.@lag</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@lag(expr[, n=1])</code></pre><p>Apply the lag operator to the given expression.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@lead-Tuple" href="#ModelBaseEcon.@lead-Tuple"><code>ModelBaseEcon.@lead</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@lead(expr[, n=1])</code></pre><p>Apply the lead operator to the given expression. Equivalent to <code>@lag(expr, -n)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@link-Tuple{Any}" href="#ModelBaseEcon.@link-Tuple{Any}"><code>ModelBaseEcon.@link</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@link expr</code></pre><p>Create a parameter link. Use <code>@link</code> in the <a href="#ModelBaseEcon.@parameters-Tuple{Any, Vararg{Expr}}"><code>@parameters</code></a> section of your model definition.</p><p>If your parameter depends on other parameters, then you use <code>@link</code> to declare that. The expression can be any valid Julia code.</p><pre><code class="nohighlight hljs">@parameters model begin
    a = 5
    b = @link a + 1
end</code></pre><p>When a parameter the link depends on is assigned a new value, the link that depends on it gets updated automatically.</p><div class="admonition is-info"><header class="admonition-header">Important note</header><div class="admonition-body"><p>There are two cases in which the value of a link does not get updated automatically. If the parameter it depends on is mutable, e.g. a <code>Vector</code>, it is possible for it to get updated in place. The other case is when the link contains global variable or custom function.</p><p>In such case, it is necessary to call <a href="#ModelBaseEcon.update_links!-Tuple{ModelBaseEcon.AbstractModel}"><code>update_links!</code></a>.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@load_example-Tuple{Any}" href="#ModelBaseEcon.@load_example-Tuple{Any}"><code>ModelBaseEcon.@load_example</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Deprecated. Use <code>@using_example</code> instead.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@logvariables-Tuple{Any, Expr}" href="#ModelBaseEcon.@logvariables-Tuple{Any, Expr}"><code>ModelBaseEcon.@logvariables</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@logvariables</code></pre><p>Same as <a href="#ModelBaseEcon.@variables-Tuple{Any, Expr}"><code>@variables</code></a>, but the variables declared with <code>@logvariables</code> are log-transformed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@movav-Tuple" href="#ModelBaseEcon.@movav-Tuple"><code>ModelBaseEcon.@movav</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@movav(expr, n)</code></pre><p>Apply moving average with n periods backwards on the given expression. For example: <code>@movav(x[t], 3) = (x[t] + x[t-1] + x[t-2]) / 3</code>.</p><p>See also <a href="#ModelBaseEcon.@lag-Tuple"><code>@lag</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@movavew-Tuple" href="#ModelBaseEcon.@movavew-Tuple"><code>ModelBaseEcon.@movavew</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@movavew(expr, n, r)</code></pre><p>Apply moving average with exponential weights with ratio <code>r</code>. For example: <code>@moveavew(x[t], 3, 0.7) = (x[t] + 0.7*x[t-1] + 0.7^2x[t-2]) / (1 + 0.7 + 0.7^2)</code></p><p>See also <a href="#ModelBaseEcon.@movsumew-Tuple"><code>@movsumew</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@movsum-Tuple" href="#ModelBaseEcon.@movsum-Tuple"><code>ModelBaseEcon.@movsum</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@movsum(expr, n)</code></pre><p>Apply moving sum with n periods backwards on the given expression. For example: <code>@movsum(x[t], 3) = x[t] + x[t-1] + x[t-2]</code>.</p><p>See also <a href="#ModelBaseEcon.@lag-Tuple"><code>@lag</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@movsumew-Tuple" href="#ModelBaseEcon.@movsumew-Tuple"><code>ModelBaseEcon.@movsumew</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@movsumew(expr, n, r)</code></pre><p>Apply moving sum with exponential weights with ratio <code>r</code>. For example: <code>@movsumew(x[t], 3, 0.7) = x[t] + 0.7*x[t-1] + 0.7^2x[t-2]</code></p><p>See also <a href="#ModelBaseEcon.@movavew-Tuple"><code>@movavew</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@neglogvariables-Tuple{Any, Expr}" href="#ModelBaseEcon.@neglogvariables-Tuple{Any, Expr}"><code>ModelBaseEcon.@neglogvariables</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@neglogvariables</code></pre><p>Same as <a href="#ModelBaseEcon.@variables-Tuple{Any, Expr}"><code>@variables</code></a>, but the variables declared with <code>@neglogvariables</code> are negative-log-transformed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@parameters-Tuple{Any, Vararg{Expr}}" href="#ModelBaseEcon.@parameters-Tuple{Any, Vararg{Expr}}"><code>ModelBaseEcon.@parameters</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@parameters model begin
    name = value
    ...
end</code></pre><p>Declare and define the model parameters.</p><p>The parameters must have values. Provide the information in a series of assignment statements wrapped inside a begin-end block. Use <code>@link</code> and <code>@alias</code> to define dynamic links. See <a href="#ModelBaseEcon.Parameters"><code>Parameters</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@parameters-Tuple{}" href="#ModelBaseEcon.@parameters-Tuple{}"><code>ModelBaseEcon.@parameters</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">params = @parameters</code></pre><p>When called without any arguments, return an empty <a href="#ModelBaseEcon.Parameters"><code>Parameters</code></a> container, with its evaluation module set to the module in which the macro is being called.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@peval-Tuple{Any, Any}" href="#ModelBaseEcon.@peval-Tuple{Any, Any}"><code>ModelBaseEcon.@peval</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@peval params what</code></pre><p>Evaluate the expression <code>what</code> within the context of the  given set of parameters </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@shocks-Tuple{Any, Expr}" href="#ModelBaseEcon.@shocks-Tuple{Any, Expr}"><code>ModelBaseEcon.@shocks</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@shocks</code></pre><p>Like <a href="#ModelBaseEcon.@variables-Tuple{Any, Expr}"><code>@variables</code></a>, but the names declared with <code>@shocks</code> are shocks.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@steadystate-Tuple{Any, Symbol, Expr}" href="#ModelBaseEcon.@steadystate-Tuple{Any, Symbol, Expr}"><code>ModelBaseEcon.@steadystate</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@steadystate model [type] lhs = rhs</code></pre><p>Add a steady state equation to the model.</p><p>The steady state system of the model is automatically derived from the dynamic system. Use this macro to define additional equations for the steady state. This is particularly useful in the case of a non-linear model that might have multiple steady state, or the steady state might be difficult to solve for, to help the steady state solver find the one you want to use.</p><ul><li><code>model</code> is the model instance you want to update</li><li><code>type</code> (optional) is the type of constraint you want to add. This can be <code>level</code></li></ul><p>or <code>slope</code>. If missing, the default is <code>level</code></p><ul><li><code>lhs = rhs</code> is the expression defining the steady state constraint. In the</li></ul><p>equation, use variables and shocks from the model, but without any t-references.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@steadyvariables-Tuple{Any, Expr}" href="#ModelBaseEcon.@steadyvariables-Tuple{Any, Expr}"><code>ModelBaseEcon.@steadyvariables</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@steadyvariables</code></pre><p>Same as <a href="#ModelBaseEcon.@variables-Tuple{Any, Expr}"><code>@variables</code></a>, but the variables declared with <code>@steadyvariables</code> have zero slope in their steady state and final conditions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@using_example-Tuple{Any}" href="#ModelBaseEcon.@using_example-Tuple{Any}"><code>ModelBaseEcon.@using_example</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@using_example name</code></pre><p>Load models from the package examples/ folder. The <code>@load_example</code> version is deprecated - stop using it now.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.@variables-Tuple{Any, Expr}" href="#ModelBaseEcon.@variables-Tuple{Any, Expr}"><code>ModelBaseEcon.@variables</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@variables model name1 name2 ...
@variables model begin
    name1
    name2
    ...
end</code></pre><p>Declare the names of variables in the model.</p><p>In the <code>begin-end</code> version the variable names can be preceeded by a description (like a docstring) and flags like <code>@log</code>, <code>@steady</code>, <code>@exog</code>, etc. See <a href="#ModelBaseEcon.ModelVariable"><code>ModelVariable</code></a> for details about this.</p></div></section></article><h4 id="Options"><a class="docs-heading-anchor" href="#Options">Options</a><a id="Options-1"></a><a class="docs-heading-anchor-permalink" href="#Options" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.OptionsMod" href="#ModelBaseEcon.OptionsMod"><code>ModelBaseEcon.OptionsMod</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">OptionsMod</code></pre><p>Sub-module of ModelBaseEcon, although it can be used independently. Implements the <a href="#ModelBaseEcon.OptionsMod.Options"><code>Options</code></a> data structure.</p><p><strong>Contents</strong></p><ul><li><a href="#ModelBaseEcon.OptionsMod.Options"><code>Options</code></a></li><li><a href="#ModelBaseEcon.OptionsMod.getoption"><code>getoption</code></a> - read the value of an option</li><li><a href="#ModelBaseEcon.OptionsMod.getoption!"><code>getoption!</code></a> - if not present, also create an option</li><li><a href="#ModelBaseEcon.OptionsMod.setoption!"><code>setoption!</code></a> - create or update the value of an option </li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.OptionsMod.Options" href="#ModelBaseEcon.OptionsMod.Options"><code>ModelBaseEcon.OptionsMod.Options</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Options</code></pre><p>A collection of key-value pairs representing the options controlling the behaviour or the definition of a Model object. The key is the option name and is always a Symbol, or converted to Symbol, while the value can be anything.</p><p>The options can be accessed using dot notation. Functions <a href="#ModelBaseEcon.OptionsMod.getoption"><code>getoption</code></a> and <a href="#ModelBaseEcon.OptionsMod.setoption!"><code>setoption!</code></a> are also provided. They can be used for programmatic processing of options as well as when the option name is not a valid Julia identifier.</p><p>See also: <a href="#ModelBaseEcon.OptionsMod.Options"><code>Options</code></a>, <a href="#ModelBaseEcon.OptionsMod.getoption"><code>getoption</code></a>, <a href="#ModelBaseEcon.OptionsMod.getoption!"><code>getoption!</code></a>, <a href="#ModelBaseEcon.OptionsMod.setoption!"><code>setoption!</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; o = Options(maxiter=20, tol=1e-7)
Options:
    maxiter=20
    tol=1.0e-7

julia&gt; o.maxiter = 25
25

julia&gt; o
Options:
    maxiter=25
    tol=1.0e-7
</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.OptionsMod.Options-Tuple{Options}" href="#ModelBaseEcon.OptionsMod.Options-Tuple{Options}"><code>ModelBaseEcon.OptionsMod.Options</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Options(::Options)</code></pre><p>Construct an Options instance as an exact copy of an existing instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.OptionsMod.Options-Tuple{}" href="#ModelBaseEcon.OptionsMod.Options-Tuple{}"><code>ModelBaseEcon.OptionsMod.Options</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Options(key=value, ...)
Options(:key=&gt;value, ...)</code></pre><p>Construct an Options instance with key-value pairs given as keyword arguments or as a list of pairs. If the latter is used, each key must be a <code>Symbol</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.OptionsMod.getoption" href="#ModelBaseEcon.OptionsMod.getoption"><code>ModelBaseEcon.OptionsMod.getoption</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getoption(o::Options; name=default [, name=default, ...])
getoption(o::Options, name, default)</code></pre><p>Retrieve the value of an option or a set of options.  The provided defaults are used when the option doesn&#39;t exit.</p><p>The return value is the value of the option requested or, if the option doesn&#39;t exist, the default. In the first version of the function, if there are more than one options requested, the return value is a tuple.</p><p>In the second version, the name could be a symbol or a string, which can be helpful if the name of the option is not a valid identifier.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.OptionsMod.getoption!" href="#ModelBaseEcon.OptionsMod.getoption!"><code>ModelBaseEcon.OptionsMod.getoption!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getoption!(o::Options; name=default [, name=default, ...])
getoption!(o::Options, name, default)</code></pre><p>Retrieve the value of an option or a set of options. If the name does not match an existing option, the Options instance is updated by inserting the given name and default value.</p><p>The return value is the value of the option requested (or the default). In the first version of the function, if there are more than one options requested, the return value is a tuple.</p><p>In the second version, the name could be a symbol or a string, which can be helpful if the name of the option is not a valid identifier.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.OptionsMod.setoption!" href="#ModelBaseEcon.OptionsMod.setoption!"><code>ModelBaseEcon.OptionsMod.setoption!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setoption!(o::Options; name=default [, name=default, ...])
setoption!(o::Options, name, default)</code></pre><p>Retrieve the value of an option or a set of options. If the name does not match an existing option, the Options instance is updated by inserting the given name and default value.</p><p>The return value is the value of the option requested (or the default). In the first version of the function, if there are more than one options requested, the return value is a tuple.</p><p>In the second version, the name could be a symbol or a string, which can be helpful if the name of the option is not a valid identifier.</p></div></section></article><h4 id="Timer"><a class="docs-heading-anchor" href="#Timer">Timer</a><a id="Timer-1"></a><a class="docs-heading-anchor-permalink" href="#Timer" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.Timer" href="#ModelBaseEcon.Timer"><code>ModelBaseEcon.Timer</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">Timer</code></pre><p>A sub-module of ModelBaseEcon, although it can be used independently. Provides functionality for measuring the aggregate time spent in individual lines or blocks of code.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The implementation here is quick-and-dirty and is intended for getting a rough idea of where the bottlenecks are. It is best used for timing blocks of code that are passed through relatively few times and each pass takes a relatively long time. In the opposite extreme case (fast code that is called many times), the current implementation of <code>@timer</code> might add extreme overhead.</p></div></div><p><strong>Contents</strong></p><ul><li><a href="#ModelBaseEcon.Timer.inittimer-Tuple{}"><code>inittimer</code></a>       - Enable collection of timer data.</li><li><a href="#ModelBaseEcon.Timer.stoptimer-Tuple{}"><code>stoptimer</code></a>       - Disable collection of timer data.</li><li><a href="#ModelBaseEcon.Timer.printtimer"><code>printtimer</code></a>      - Display timer data.</li><li><a href="#ModelBaseEcon.Timer.@timer-Tuple"><code>@timer</code></a>          - Measure the runtime taken by the given code.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.Timer.inittimer-Tuple{}" href="#ModelBaseEcon.Timer.inittimer-Tuple{}"><code>ModelBaseEcon.Timer.inittimer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inittimer()</code></pre><p>Enable the collection of timing data. Existing timing data is lost. By default, collection of timing data is disabled.</p><p>See also: <a href="#ModelBaseEcon.Timer.stoptimer-Tuple{}"><code>stoptimer</code></a>, <a href="#ModelBaseEcon.Timer.@timer-Tuple"><code>@timer</code></a>, <a href="#ModelBaseEcon.Timer.printtimer"><code>printtimer</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.Timer.printtimer" href="#ModelBaseEcon.Timer.printtimer"><code>ModelBaseEcon.Timer.printtimer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">printtimer(io::IO=Base.stdout)</code></pre><p>Display timing data.</p><p>Timing data is displayed in a table with each row containing the number of calls, total time in seconds, and the source line or block tag. Rows are sorted in order of decreasing total time.</p><p>See also: <a href="#ModelBaseEcon.Timer.@timer-Tuple"><code>@timer</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.Timer.stoptimer-Tuple{}" href="#ModelBaseEcon.Timer.stoptimer-Tuple{}"><code>ModelBaseEcon.Timer.stoptimer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stoptimer()</code></pre><p>Disable the collection of timing data. Existing data is lost. By default, collection of timing data is disabled.</p><p>See also: <a href="#ModelBaseEcon.Timer.inittimer-Tuple{}"><code>inittimer</code></a>, <a href="#ModelBaseEcon.Timer.@timer-Tuple"><code>@timer</code></a>, <a href="#ModelBaseEcon.Timer.printtimer"><code>printtimer</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.Timer.@timer-Tuple" href="#ModelBaseEcon.Timer.@timer-Tuple"><code>ModelBaseEcon.Timer.@timer</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@timer(code)
@timer(tag::String, code)</code></pre><p>Measure the number of calls and the total time taken by the given code.</p><p>If a <code>tag</code> string is not provided, one is generated from the source file and line. The return value of this macro call is the return value of the code.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Important limitation is that the code must not contain a <code>return</code>, <code>break</code>, <code>continue</code>, or any other jump out of it. If it does, the program would run correctly, but the timing data collected would be incorrect.</p></div></div><p>See also: <a href="#ModelBaseEcon.Timer.inittimer-Tuple{}"><code>inittimer</code></a>, <a href="#ModelBaseEcon.Timer.stoptimer-Tuple{}"><code>stoptimer</code></a>, <a href="#ModelBaseEcon.Timer.printtimer"><code>printtimer</code></a></p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; inittimer()

julia&gt; @timer Base.sleep(1.0)

julia&gt; printtimer()
[...]</code></pre></div></section></article><h3 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.AbstractEquation" href="#ModelBaseEcon.AbstractEquation"><code>ModelBaseEcon.AbstractEquation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractEquation end</code></pre><p>Base type for <a href="#ModelBaseEcon.Equation"><code>Equation</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.AbstractModel" href="#ModelBaseEcon.AbstractModel"><code>ModelBaseEcon.AbstractModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractModel end</code></pre><p>Base type for <a href="#ModelBaseEcon.Model"><code>Model</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.AbstractModelEvaluationData" href="#ModelBaseEcon.AbstractModelEvaluationData"><code>ModelBaseEcon.AbstractModelEvaluationData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractModelEvaluationData</code></pre><p>Base type for all model evaluation structures. Specific derived types would specialize in different types of models.</p><p><strong>Implementaion (for developers)</strong></p><p>Derived types must specialize two functions</p><ul><li><a href="#ModelBaseEcon.eval_R!"><code>eval_R!</code></a> - evaluate the residual</li><li><a href="#ModelBaseEcon.eval_RJ"><code>eval_RJ</code></a> - evaluate the residual and its Jacobian</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.AbstractParam" href="#ModelBaseEcon.AbstractParam"><code>ModelBaseEcon.AbstractParam</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractParam end</code></pre><p>Base type for model parameters.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.EqnFlags" href="#ModelBaseEcon.EqnFlags"><code>ModelBaseEcon.EqnFlags</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct EqnFlags ⋯ end</code></pre><p>Holds information about the equation. Flags can be specified in the model definition by annotating the equation with <code>@&lt;flag&gt;</code> (insert the flag you want to raise in place of <code>&lt;flag&gt;</code>). Multiple flags may be applied to the same equation.</p><p>Supported flags:</p><ul><li><code>@log lhs = rhs</code> instructs the model parser to make the residual <code>log(lhs / rhs)</code>. Normally the residual is <code>lhs - rhs</code>.</li><li><code>@lin lhs = rhs</code> marks the equation for selective linearization.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.EqnNotReadyError" href="#ModelBaseEcon.EqnNotReadyError"><code>ModelBaseEcon.EqnNotReadyError</code></a> — <span class="docstring-category">Type</span></header><section><div><p>struct EqnNotReadyError &lt;: ModelErrorBase</p><p>Concrete error type used to indicate that a given equation has not been prepared for use in the model yet.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.LinearizationError" href="#ModelBaseEcon.LinearizationError"><code>ModelBaseEcon.LinearizationError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearizationError &lt;: ModelErrorBase</code></pre><p>A concrete error type used when a model cannot be linearized for some reason.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.LinearizedModelEvaluationData" href="#ModelBaseEcon.LinearizedModelEvaluationData"><code>ModelBaseEcon.LinearizedModelEvaluationData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LinearizedModelEvaluationData &lt;: AbstractModelEvaluationData</code></pre><p>Model evaluation data for the linearized model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.ModelErrorBase" href="#ModelBaseEcon.ModelErrorBase"><code>ModelBaseEcon.ModelErrorBase</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type ModelErrorBase &lt;: Exception end</code></pre><p>Abstract error type, base for specific error types used in ModelBaseEcon.</p><p><strong>Implementation (note for developers)</strong></p><p>When implementing a derived error type, override two functions:</p><ul><li><code>msg(e::SomeModelError)</code> returning a string with the error message;</li><li><code>hint(e::SomeModelError)</code> returning a string containing a suggestion of how to fix the problem. Optional, if not implemented for a type, the fallback implementation returns an empty string.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.ModelEvaluationData" href="#ModelBaseEcon.ModelEvaluationData"><code>ModelBaseEcon.ModelEvaluationData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ModelEvaluationData &lt;: AbstractModelEvaluationData</code></pre><p>The standard model evaluation data used in the general case and by default.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.ModelEvaluationData-Tuple{ModelBaseEcon.AbstractModel}" href="#ModelBaseEcon.ModelEvaluationData-Tuple{ModelBaseEcon.AbstractModel}"><code>ModelBaseEcon.ModelEvaluationData</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ModelEvaluationData(model::AbstractModel)</code></pre><p>Create the standard evaluation data structure for the given model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.ModelFlags" href="#ModelBaseEcon.ModelFlags"><code>ModelBaseEcon.ModelFlags</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct ModelFlags ⋯ end</code></pre><p>Model flags include</p><ul><li><code>ssZeroSlope</code> - Set to <code>true</code> to instruct the solvers that all variables have zero slope in steady state and final conditions. In other words the model is stationary.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.ModelNotInitError" href="#ModelBaseEcon.ModelNotInitError"><code>ModelBaseEcon.ModelNotInitError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ModelNotInitError &lt;: ModelErrorBase</code></pre><p>Specific error type used when there&#39;s an attempt to use a Model object that has not been initialized.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.NotImplementedError" href="#ModelBaseEcon.NotImplementedError"><code>ModelBaseEcon.NotImplementedError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NotImplementedError &lt;: ModelErrorBase</code></pre><p>Specific error type used when a feature is planned but not yet implemented. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.SSEqnData" href="#ModelBaseEcon.SSEqnData"><code>ModelBaseEcon.SSEqnData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SSEqnData</code></pre><p>Internal structure used for evaluation of the residual of the steady state equation derived from a dynamic equation.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This data type is for internal use only and not intended to be used directly by users.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.SteadyStateVariable" href="#ModelBaseEcon.SteadyStateVariable"><code>ModelBaseEcon.SteadyStateVariable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SteadyStateVariable ⋯ end</code></pre><p>Holds the steady state solution for one variable, which includes the values of two steady state unknowns - level and slope.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.iterate" href="#Base.iterate"><code>Base.iterate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iterate(params::Parameters)</code></pre><p>Iterates the given Parameters collection in the order of dependency. Specifically, each parameter comes up only after all parameters it depends on have already been visited. The order within that is alphabetical.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.at_d" href="#ModelBaseEcon.at_d"><code>ModelBaseEcon.at_d</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">at_d(expr[, n=1 [, s=0 ]])</code></pre><p>Apply the difference operator to the given expression. If <code>L</code> represents the lag operator, then we have the following definitions.</p><pre><code class="nohighlight hljs">at_d(x[t]) = (1-L)x = x[t]-x[t-1]
at_d(x[t], n) = (1-L)^n x
at_d(x[t], n, s) = (1-L)^n (1-L^s) x</code></pre><p>See also <a href="#ModelBaseEcon.at_lag-Tuple{Any, Vararg{Any}}"><code>at_lag</code></a>, <a href="#ModelBaseEcon.at_d"><code>at_d</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.at_dlog-Tuple{Expr, Vararg{Any}}" href="#ModelBaseEcon.at_dlog-Tuple{Expr, Vararg{Any}}"><code>ModelBaseEcon.at_dlog</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">at_dlog(expr[, n=1 [, s=0 ]])</code></pre><p>Apply the difference operator on the log() of the given expression. Equivalent to at_d(log(expr), n, s).</p><p>See also <a href="#ModelBaseEcon.at_lag-Tuple{Any, Vararg{Any}}"><code>at_lag</code></a>, <a href="#ModelBaseEcon.at_d"><code>at_d</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.at_lag-Tuple{Any, Vararg{Any}}" href="#ModelBaseEcon.at_lag-Tuple{Any, Vararg{Any}}"><code>ModelBaseEcon.at_lag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">at_lag(expr[, n=1])</code></pre><p>Apply the lag operator to the given expression.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.at_lead" href="#ModelBaseEcon.at_lead"><code>ModelBaseEcon.at_lead</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">at_lead(expr[, n=1])</code></pre><p>Apply the lead operator to the given expression. Equivalent to <code>at_lag(expr, -n)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.at_movav-Tuple{Expr, Integer}" href="#ModelBaseEcon.at_movav-Tuple{Expr, Integer}"><code>ModelBaseEcon.at_movav</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">at_movav(expr, n)</code></pre><p>Apply moving average with n periods backwards on the given expression. For example: <code>at_movav(x[t], 3) = (x[t] + x[t-1] + x[t-2]) / 3</code>.</p><p>See also <a href="#ModelBaseEcon.at_lag-Tuple{Any, Vararg{Any}}"><code>at_lag</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.at_movavew-Tuple{Expr, Integer, Real}" href="#ModelBaseEcon.at_movavew-Tuple{Expr, Integer, Real}"><code>ModelBaseEcon.at_movavew</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">at_movavew(expr, n, r)</code></pre><p>Apply moving average with exponential weights with ratio <code>r</code>. For example: <code>at_moveavew(x[t], 3, 0.7) = (x[t] + 0.7*x[t-1] + 0.7^2x[t-2]) / (1 + 0.7 + 0.7^2)</code></p><p>See also <a href="#ModelBaseEcon.at_movsumew-Tuple{Expr, Integer, Any}"><code>at_movsumew</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.at_movsum-Tuple{Expr, Integer}" href="#ModelBaseEcon.at_movsum-Tuple{Expr, Integer}"><code>ModelBaseEcon.at_movsum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">at_movsum(expr, n)</code></pre><p>Apply moving sum with n periods backwards on the given expression. For example: <code>at_movsum(x[t], 3) = x[t] + x[t-1] + x[t-2]</code>.</p><p>See also <a href="#ModelBaseEcon.at_lag-Tuple{Any, Vararg{Any}}"><code>at_lag</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.at_movsumew-Tuple{Expr, Integer, Any}" href="#ModelBaseEcon.at_movsumew-Tuple{Expr, Integer, Any}"><code>ModelBaseEcon.at_movsumew</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">at_movsumew(expr, n, r)</code></pre><p>Apply moving sum with exponential weights with ratio <code>r</code>. For example: <code>at_movsumew(x[t], 3, 0.7) = x[t] + 0.7*x[t-1] + 0.7^2x[t-2]</code></p><p>See also <a href="#ModelBaseEcon.at_movavew-Tuple{Expr, Integer, Real}"><code>at_movavew</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.funcsyms" href="#ModelBaseEcon.funcsyms"><code>ModelBaseEcon.funcsyms</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">funcsyms(mod::Module)</code></pre><p>Create a pair of identifiers that does not conflict with existing identifiers in the given module.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Internal function. Do not call directly.</p></div></div><p><strong>Implementation (for developers)</strong></p><p>We need two identifiers <code>resid_N</code> and <code>RJ_N</code> where &quot;N&quot; is some integer number. The first is going to be the name of the function that evaluates the equation and the second is going to be the name of the function that evaluates both the equation and its gradient.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.hint-Tuple{ModelBaseEcon.ModelErrorBase}" href="#ModelBaseEcon.hint-Tuple{ModelBaseEcon.ModelErrorBase}"><code>ModelBaseEcon.hint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hint(::ModelErrorBase)</code></pre><p>Return the hint message - a suggestion of how the problem might be fixed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.initfuncs-Tuple{Module}" href="#ModelBaseEcon.initfuncs-Tuple{Module}"><code>ModelBaseEcon.initfuncs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initfuncs(mod::Module)</code></pre><p>Initialize the given module before creating functions that evaluate residuals and thier gradients.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Internal function. Do not call directly.</p></div></div><p><strong>Implementation (for developers)</strong></p><p>Declare the necessary types in the module where the model is being defined. There are two such types. First is <code>EquationEvaluator</code>, which is callable and stores a collection of parameters. The call will be defined in <a href="#ModelBaseEcon.makefuncs-NTuple{5, Any}"><code>makefuncs</code></a> and will evaluate the residual. The other type is <code>EquationGradient</code>, which is also callable and stores the <code>EquationEvaluator</code> together with a <code>DiffResult</code> and a <code>GradientConfig</code> used by <code>ForwardDiff</code>. Its call is defined here and computes the residual and the gradient.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.initialize!-Tuple{Model, Module}" href="#ModelBaseEcon.initialize!-Tuple{Model, Module}"><code>ModelBaseEcon.initialize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialize!(model, modelmodule)</code></pre><p>In the model file, after all declarations of flags, parameters, variables, and equations are done, it is necessary to initialize the model instance. Usually it is easier to call <a href="#ModelBaseEcon.@initialize-Tuple{Symbol}"><code>@initialize</code></a>, which automatically sets the <code>modelmodule</code> value. When it is necessary to set the <code>modelmodule</code> argument to some other module, then this can be done by calling this function instead of the macro.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.initssdata!-Tuple{ModelBaseEcon.AbstractModel}" href="#ModelBaseEcon.initssdata!-Tuple{ModelBaseEcon.AbstractModel}"><code>ModelBaseEcon.initssdata!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initssdata!(m::AbstractModel)</code></pre><p>Create and initialize the <code>SteadyStateData</code> structure of the given model.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function is for internal use only and not intended to be called directly by users. It is called during <a href="#ModelBaseEcon.@initialize-Tuple{Symbol}"><code>@initialize</code></a>.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.make_sseqn" href="#ModelBaseEcon.make_sseqn"><code>ModelBaseEcon.make_sseqn</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">make_sseqn(model::AbstractModel, eqn::Equation, shift::Bool, var_to_idx)</code></pre><p>Create a steady state equation from the given dynamic equation for the given model.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function is for internal use only and not intended to be called directly by users.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.makefuncs-NTuple{5, Any}" href="#ModelBaseEcon.makefuncs-NTuple{5, Any}"><code>ModelBaseEcon.makefuncs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">makefuncs(expr, tssyms, sssyms, psyms, mod)</code></pre><p>Create two functions that evaluate the residual and its gradient for the given expression.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Internal function. Do not call directly.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>expr</code>: the expression</li><li><code>tssyms</code>: list of time series variable symbols</li><li><code>sssyms</code>: list of steady state symbols</li><li><code>psyms</code>: list of parameter symbols</li></ul><p><strong>Return value</strong></p><p>Return a quote block to be evaluated in the module where the model is being defined. The quote block contains definitions of the residual function (as a callable <code>EquationEvaluator</code> instance) and a second function that evaluates both the residual and its gradient (as a callable <code>EquationGradient</code> instance).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.modelerror" href="#ModelBaseEcon.modelerror"><code>ModelBaseEcon.modelerror</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">modelerror(ME::Type{&lt;:ModelErrorBase}, args...; kwargs...)</code></pre><p>Raise an exception derived from <a href="#ModelBaseEcon.ModelErrorBase"><code>ModelErrorBase</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.moduleof" href="#ModelBaseEcon.moduleof"><code>ModelBaseEcon.moduleof</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">moduleof(equation)
moduleof(model)</code></pre><p>Return the module in which the given equation or model was initialized.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.msg" href="#ModelBaseEcon.msg"><code>ModelBaseEcon.msg</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">msg(::ModelErrorBase)</code></pre><p>Return the error message - a description of what went wrong.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.precompile_dual_funcs-Tuple{Int64}" href="#ModelBaseEcon.precompile_dual_funcs-Tuple{Int64}"><code>ModelBaseEcon.precompile_dual_funcs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">precompilefuncs(N::Int)</code></pre><p>Pre-compiles functions used by models for a <code>ForwardDiff.Dual</code> numbers with chunk size <code>N</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Internal function. Do not call directly</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.precompilefuncs-Tuple{Any, Any, Any, Int64}" href="#ModelBaseEcon.precompilefuncs-Tuple{Any, Any, Any, Int64}"><code>ModelBaseEcon.precompilefuncs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">precompilefuncs(resid, RJ, resid_param, N::Int)</code></pre><p>Pre-compiles the given <code>resid</code> and <code>RJ</code> functions together with the dual-number arithmetic required by ForwardDiff.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Internal function. Do not call directly</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.process_equation" href="#ModelBaseEcon.process_equation"><code>ModelBaseEcon.process_equation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">process_equation(model::Model, expr; &lt;keyword arguments&gt;)</code></pre><p>Process the given expression in the context of the given model and create an Equation() instance for it.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function is for internal use only and should not be called directly.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.setss!-Tuple{ModelBaseEcon.AbstractModel, Expr}" href="#ModelBaseEcon.setss!-Tuple{ModelBaseEcon.AbstractModel, Expr}"><code>ModelBaseEcon.setss!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setss!(model::AbstractModel, expr::Expr; type::Symbol, modelmodule::Module)</code></pre><p>Add a steady state equation to the model. Equations added by <code>setss!</code> are in addition to the equations generated automatically from the dynamic system.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function is for internal use only and not intended to be called directly by users. Use <a href="#ModelBaseEcon.@steadystate-Tuple{Any, Symbol, Expr}"><code>@steadystate</code></a> instead of calling this function.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.sseqn_resid_RJ-Tuple{ModelBaseEcon.SSEqnData}" href="#ModelBaseEcon.sseqn_resid_RJ-Tuple{ModelBaseEcon.SSEqnData}"><code>ModelBaseEcon.sseqn_resid_RJ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sseqn_resid_RJ(sed::SSEqnData)</code></pre><p>Create the <code>eval_resid</code> and <code>eval_RJ</code> for a steady state equation derived from a dynamic equation using information from the given <a href="#ModelBaseEcon.SSEqnData"><code>SSEqnData</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This function is for internal use only and not intended to be called directly by users.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.update_auxvars-Tuple{AbstractMatrix{Float64}, Model}" href="#ModelBaseEcon.update_auxvars-Tuple{AbstractMatrix{Float64}, Model}"><code>ModelBaseEcon.update_auxvars</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_auxvars(point, model; tol=model.tol, default=0.0)</code></pre><p>Calculate the values of auxiliary variables from the given values of regular variables and shocks.</p><p>Auxiliary variables were introduced as substitutions, e.g. log(expression) was replaced by aux1 and equation was added exp(aux1) = expression, where expression contains regular variables and shocks.</p><p>This function uses the auxiliary equation to compute the value of the auxiliary variable for the given values of other variables. Note that the given values of other variables might be inadmissible, in the sense that expression is negative. If that happens, the auxiliary variable is set to the given <code>default</code> value.</p><p>If the <code>point</code> array does not contain space for the auxiliary variables, it is extended appropriately.</p><p>If there are no auxiliary variables/equations in the model, return <em>a copy</em> of <code>point</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The current implementation is specialized only to log substitutions. TODO: implement a general approach that would work for any substitution.</p></div></div></div></section></article><h4 id="Options-2"><a class="docs-heading-anchor" href="#Options-2">Options</a><a class="docs-heading-anchor-permalink" href="#Options-2" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="Base.merge!-Tuple{Options, Vararg{Options}}" href="#Base.merge!-Tuple{Options, Vararg{Options}}"><code>Base.merge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">merge!(o1::Options, o2::Options...)</code></pre><p>Update the first argument, adding all options from the remaining arguments. If the same option exists in multiple places, use the last one.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.merge-Tuple{Options, Vararg{Options}}" href="#Base.merge-Tuple{Options, Vararg{Options}}"><code>Base.merge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">merge(o1::Options, o2::Options, ...)</code></pre><p>Merge the given Options instances into a new Options instance. If the same option key exists in more than one instance, keep the value from the last one.</p></div></section></article><h4 id="Timer-2"><a class="docs-heading-anchor" href="#Timer-2">Timer</a><a class="docs-heading-anchor-permalink" href="#Timer-2" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="ModelBaseEcon.Timer.timerData" href="#ModelBaseEcon.Timer.timerData"><code>ModelBaseEcon.Timer.timerData</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">timerData</code></pre><p>Stores timing data.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For internal use. Do not modify directly.</p></div></div><p>If equal to <code>nothing</code>, timing is disabled. Otherwise, contains a &quot;database&quot; of timing data in the  form of a Dict.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../TimeSeriesEcon/">« TimeSeriesEcon</a><a class="docs-footer-nextpage" href="../StateSpaceEcon/">StateSpaceEcon »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 19 July 2023 18:37">Wednesday 19 July 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
