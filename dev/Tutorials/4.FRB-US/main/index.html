<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>FRB/US · StateSpaceEcon</title><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="StateSpaceEcon logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">StateSpaceEcon</a></span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Welcome</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../README/">README</a></li><li><a class="tocitem" href="../../1.TimeSeriesEcon/main/">Time Series</a></li><li><a class="tocitem" href="../../2.simple_RBC/main/">Simple RBC Model</a></li><li><a class="tocitem" href="../../3.US_SW07/main/">Smets and Wouters 2007</a></li><li class="is-active"><a class="tocitem" href>FRB/US</a><ul class="internal"><li><a class="tocitem" href="#Getting-started"><span>Getting started</span></a></li><li><a class="tocitem" href="#The-Model-File"><span>The Model File</span></a></li><li><a class="tocitem" href="#Load-the-Model"><span>Load the Model</span></a></li><li><a class="tocitem" href="#Load-the-Longbase-Data"><span>Load the Longbase Data</span></a></li><li><a class="tocitem" href="#Load-set_policy.jl"><span>Load <code>set_policy.jl</code></span></a></li><li><a class="tocitem" href="#Prepare-the-Simulation-Plan"><span>Prepare the Simulation Plan</span></a></li><li><a class="tocitem" href="#Prepare-the-Exogenous-Data"><span>Prepare the Exogenous Data</span></a></li><li><a class="tocitem" href="#Back-out-the-Shocks"><span>Back out the Shocks</span></a></li><li><a class="tocitem" href="#Recover-the-Baseline-Case"><span>Recover the Baseline Case</span></a></li><li><a class="tocitem" href="#Simulate-a-shock"><span>Simulate a shock</span></a></li></ul></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../../Reference/TimeSeriesEcon/">TimeSeriesEcon</a></li><li><a class="tocitem" href="../../../Reference/ModelBaseEcon/">ModelBaseEcon</a></li><li><a class="tocitem" href="../../../Reference/StateSpaceEcon/">StateSpaceEcon</a></li><li><a class="tocitem" href="../../../Reference/FAME/">FAME</a></li></ul></li><li><span class="tocitem">Design Papers</span><ul><li><a class="tocitem" href="../../../DesignPapers/">Design Papers</a></li><li><a class="tocitem" href="../../../DesignPapers/final_conditions/">Final Conditions</a></li><li><a class="tocitem" href="../../../DesignPapers/log_variables/">Log-variables</a></li><li><a class="tocitem" href="../../../DesignPapers/equation_changes/">Equation Changing Syntax</a></li><li><a class="tocitem" href="../../../DesignPapers/frequency_conversions/">Frequency Conversion</a></li></ul></li><li><a class="tocitem" href="../../../indexpage/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>FRB/US</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>FRB/US</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/bankofcanada/TutorialsEcon.jl/blob/master/4.FRB-US/main.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="FRB/US-with-VAR-based-Expectations"><a class="docs-heading-anchor" href="#FRB/US-with-VAR-based-Expectations">FRB/US with VAR-based Expectations</a><a id="FRB/US-with-VAR-based-Expectations-1"></a><a class="docs-heading-anchor-permalink" href="#FRB/US-with-VAR-based-Expectations" title="Permalink"></a></h1><h2 id="Getting-started"><a class="docs-heading-anchor" href="#Getting-started">Getting started</a><a id="Getting-started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-started" title="Permalink"></a></h2><p>If you wish to run the code of this tutorial, or to experiment for yourself, make sure to follow the instructions in <a href="../../#Getting-started">Introduction/Getting_started</a>.</p><h2 id="The-Model-File"><a class="docs-heading-anchor" href="#The-Model-File">The Model File</a><a id="The-Model-File-1"></a><a class="docs-heading-anchor-permalink" href="#The-Model-File" title="Permalink"></a></h2><p>We recommend placing the model definition in its own Julia module in a separate source file. Although this is not strictly necessary, it helps to keep the code well organized and it also allows us to take advantage of pre-compilation. The first time we load the model file it takes some time to compile, and after that loading is much faster.</p><p>The FRB/US model we will be working with is located in <a href="../models/FRBUS_VAR.jl"><code>models/FRBUS_VAR.jl</code></a>.  This file was automatically generated from the <code>model.xml</code> file contained within <a href="https://www.federalreserve.gov/econres/us-models-package.htm"><code>frbus_package.zip</code></a>.</p><h3 id="Some-Notes-About-the-Julia-Model-File"><a class="docs-heading-anchor" href="#Some-Notes-About-the-Julia-Model-File">Some Notes About the Julia Model File</a><a id="Some-Notes-About-the-Julia-Model-File-1"></a><a class="docs-heading-anchor-permalink" href="#Some-Notes-About-the-Julia-Model-File" title="Permalink"></a></h3><ol><li><p>Some variables are declared as <em>log variables</em> using the <code>@log</code> declaration within a <code>@variables</code> block. For example</p><pre><code class="language-julia hljs">@variables model begin
    # ... #
    &quot;Investment in equipment, current \$&quot; @log ebfin
    &quot;Personal consumption expenditures, current \$ (NIPA definition)&quot; @log ecnian
    # ... #
end</code></pre><p>A full discussion of log variables is beyond the scope of this tutorial.  However a very simplified explanation is that this improves the stability of  the numerical solver for variables which are always positive.</p></li><li><p>Variables which do not have an associated equation, and for which data is always given, are declared <em>exogenous</em> using an <code>@exogenous</code> block. For example</p><pre><code class="language-julia hljs">@exogenous model begin
    # Exogenous variables:
    &quot;Potential government employment ratio (relative to business)&quot; adjlegrt
    &quot;Dummy, post-1979 indicator&quot; d79a
    &quot;Dummy, 1980-1995 indicator&quot; d8095
    # ... #
end</code></pre></li><li><p>The EViews syntax is translated to Julia syntax. EViews functions <code>d()</code> and <code>dlog()</code> are replaced with their equivalent StateSpaceEcon <em>meta functions</em> <code>@d()</code> and <code>@dlog()</code>. EViews <code>@movav()</code> is left alone, because a <em>meta function</em> by the same name already exists in StateSpaceEcon, and does the same thing. Finally, the EViews <code>@recode()</code> is replaced with the equivalent Julia function <code>ifelse()</code>, or where appropriate with a <code>min()</code> or a <code>max()</code>.</p></li><li><p>Several equations contain expressions matching the pattern <code>1 / (1 + exp(-cx))</code>, where <code>c</code> is a large constant (usually 25) and <code>x</code> is some expression. This sigmoid function is a smooth approximation of the Heaviside step function for large values of <code>c</code>. While mathematically the derivative of this function is well defined and converges to approximately zero everywhere outside a very small interval containing 0, numerically it causes problems because it results in either 0/0 or ∞/∞. To remedy this situation, we replace such patterns with equivalent calls to <code>heaviside(cx)</code>, where the function <code>heaviside()</code> is defined in the model file.</p><pre><code class="language-julia hljs">export heaviside
&quot;Heaviside step function&quot; @inline heaviside(x) = convert(typeof(x), x&gt;zero(x))</code></pre></li></ol><h3 id="Regenerating-the-Model-File"><a class="docs-heading-anchor" href="#Regenerating-the-Model-File">Regenerating the Model File</a><a id="Regenerating-the-Model-File-1"></a><a class="docs-heading-anchor-permalink" href="#Regenerating-the-Model-File" title="Permalink"></a></h3><p>We have included the script <a href="../update_models.jl"><code>update_models.jl</code></a>. It is not necessary for running the code below, but it may be helpful for further experimentation.</p><p>If the model file is missing, for some reason or another, this script will automatically download <code>frbus_package.zip</code> and process the <code>model.xml</code> within it to re-generate <code>model/FRBUS_VAR.jl</code>. This could also be useful if you make modifications to <code>model.xml</code> (including not only the equations, but also the parameter values), or if you want to use a different FRBUS package from the one posted on the FRBUS website. In this case, simply place your <code>frbus_package.zip</code> in the <code>models/</code> directory and run <code>update_models.jl</code>. Of course such modifications can also be done directly into the existing <code>models/FRBUS_VAR.jl</code> file.</p><p>Note that after updating <code>models/FRBUS_VAR.jl</code>, it&#39;d be best to restart the REPL. The first time you load the new model module it&#39;ll take a bit longer due to pre-compilation.</p><h2 id="Load-the-Model"><a class="docs-heading-anchor" href="#Load-the-Model">Load the Model</a><a id="Load-the-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Load-the-Model" title="Permalink"></a></h2><p>Assuming that the <code>models/</code> directory is already in the <code>LOAD_PATH</code> list, we can load the model by <code>using</code> its module. Once loaded, the module contains a variable <code>model</code> which represents the model object.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using FRBUS_VAR</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m = FRBUS_VAR.model</code><code class="nohighlight hljs ansi" style="display:block;">367 variable(s), 284 shock(s), 139 parameter(s), 284 equations(s) with 117 auxiliary equations.</code></pre><p>We see that the model has a number of variables, shocks, equations, and parameters. The total number of variables include exogenous variables.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; m.variables</code><code class="nohighlight hljs ansi" style="display:block;">367-element Vector{ModelVariable}:
 &quot;Federal funds rate, first diff&quot; delrff
 &quot;Price inflation aggregation discrepancy&quot; dpgap
 &quot;Investment in equipment, current $&quot; @log ebfin
 &quot;Personal consumption expenditures, current $ (NIPA definition)&quot; @log ecnian
 &quot;Federal Government expenditures, current $&quot; @log egfen
 &quot;Federal government employee compensation, current $&quot; @log egfln
 &quot;S&amp;L Government expenditures, current $&quot; @log egsen
 &quot;S&amp;L government employee compensation, current $&quot; @log egsln
 &quot;Residential investment expenditures&quot; @log ehn
 &quot;Change in private inventories, cw 2012$&quot; ei
 ⋮
 &quot;Multiplicative factor (Consumer interest payments to business)&quot; @exog uyhibn
 &quot;Multiplicative factor in YHLN identity&quot; @exog uyhln
 &quot;Multiplicative factor in YHPTN identity&quot; @exog uyhptn
 &quot;Multiplicative factor in personal saving identity (accounts for transfers to foreign&quot; @exog uyhsn
 &quot;Multiplicative factor in YHTN identity&quot; @exog uyhtn
 &quot;Multiplicative factor in YLN identity&quot; @exog uyl
 &quot;Multiplicative factor in YNIN identity&quot; @exog uyni
 &quot;Multiplicative factor in YPN identity&quot; @exog uyp
 &quot;Microsoft one-time dividend payout in 2004Q4&quot; @exog ymsdn</code></pre><p>We also see that the model object includes a number of auxiliary equations. These equations (and variables) are automatically added as substitutions for expressions that must be positive.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; m.auxeqns</code><code class="nohighlight hljs ansi" style="display:block;">117-element Vector{Equation}:
 exp(aux1[t]) = phr[t] * pxp[t]
 exp(aux2[t]) = pbfir[t] * pxp[t]
 exp(aux3[t]) = pegfr[t] * pxp[t]
 exp(aux4[t]) = pegsr[t] * pxp[t]
 exp(aux5[t]) = pxr[t] * pxp[t]
 exp(aux6[t]) = ((pbfir[t] * pxp[t]) / pxb[t]) / ((pbfir[t - 1] * pxp[t - 1]) / pxb[t - 1])
 exp(aux7[t]) = ((ynicpn[t] - tcin[t]) * 0.5) / pxb[t]
 exp(aux8[t]) = leg[t]
 exp(aux9[t]) = uleg[t]
 exp(aux10[t]) = lprdt[t]
 ⋮
 exp(aux109[t]) = xbtr[t]
 exp(aux110[t]) = xbtr[t - 1]
 exp(aux111[t]) = qynidn[t - 1] / (ynidn[t - 1] - ymsdn[t - 1])
 exp(aux112[t]) = zyhpst[t]
 exp(aux113[t]) = zyhpst[t - 1]
 exp(aux114[t]) = zyhst[t]
 exp(aux115[t]) = zyhst[t - 1]
 exp(aux116[t]) = zyhtst[t]
 exp(aux117[t]) = zyhtst[t - 1]</code></pre><p>For example, we see that variable <code>aux1</code> was added with the first equation in the above list. At the same time, in equation for <code>dpgap</code>, the expression <code>log(phr[t] * pxp[t])</code> has been replaced by <code>aux1[t]</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; m.equations[2]</code><code class="nohighlight hljs ansi" style="display:block;">&quot;Price inflation aggregation discrepancy&quot; dpgap[t] - dpgap_a[t] = pipxnc[t] / 400 - (y_dpgap[1] * @d(aux1[t], 0, 1) + (y_dpgap[2] * @d(aux2[t], 0, 1) + ((y_dpgap[3] + y_dpgap[4]) * @d(aux3[t], 0, 1) + ((y_dpgap[5] + y_dpgap[6]) * @d(aux4[t], 0, 1) + y_dpgap[7] * @d(aux5[t], 0, 1)))))</code></pre><p>A detailed discussion of auxiliary variables and equations is beyond the scope of this tutorial. It suffices to say that we can safely ignore their presence for now.</p><h2 id="Load-the-Longbase-Data"><a class="docs-heading-anchor" href="#Load-the-Longbase-Data">Load the Longbase Data</a><a id="Load-the-Longbase-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Load-the-Longbase-Data" title="Permalink"></a></h2><p>Unfortunately the <code>longbase</code> data is loaded from the LONGBASE.TXT file provided in the FRB/US data package. The file is read and parsed via the function defined in <a href="../load_longbase.jl"><code>load_longbase.jl</code></a>. Note that this is not a module,  so we load it by calling <code>include()</code>, not <code>using</code>. We have saved a copy of this file as of 2022-11-29, named <code>longbase_2022-11-29.csv</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; include(&quot;load_longbase.jl&quot;)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; longbase = load_longbase(&quot;longbase_2022-11-29.csv&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">843×651 MVTSeries{Quarterly} with range 1962Q1:2172Q3 and variables (delrff,…):
           delrff        dpgap        … zyhst_a     zyhtst_a
  1962Q1 :  0.0685484     0.000717931 … 0.0         0.0
  1962Q2 :  0.217238      0.00279794  … 0.0         0.0
  1962Q3 :  0.204613      0.000676539 … 0.0         0.0
  1962Q4 :  0.0769286    -0.00222033  … 0.0         0.0
  1963Q1 :  0.031112      0.00371643  … 0.0         0.0
  1963Q2 : -0.000739006  -7.93421e-5  … 0.0         0.0
  1963Q3 :  0.34871      -0.00262161  … 0.0         0.0
  1963Q4 :  0.129242      0.00267605  … 0.0         0.0
  1964Q1 :  0.0220479    -0.000558833 … 0.0         0.0
           ⋮             ⋮            ⋱ ⋮           ⋮
  2170Q3 :  6.21725e-14   0.0         … 0.0         0.0
  2170Q4 :  8.30447e-14   0.0         … 0.0         0.0
  2171Q1 :  2.53131e-14   0.0         … 0.0         0.0
  2171Q2 :  2.35367e-14   0.0         … 0.0         0.0
  2171Q3 : -1.90958e-14   0.0         … 0.0         0.0
  2171Q4 :  0.0           0.0         … 0.0         0.0
  2172Q1 : -7.54952e-14   0.0         … 0.0         0.0
  2172Q2 :  0.0           0.0         … 0.0         0.0
  2172Q3 : -2.9754e-14    0.0         … 0.0         0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test size(longbase) == (843, 651) # check size</code><code class="nohighlight hljs ansi" style="display:block;">Test Passed
  Expression: size(longbase) == (843, 651)
   Evaluated: (843, 651) == (843, 651)</code></pre><h2 id="Load-set_policy.jl"><a class="docs-heading-anchor" href="#Load-set_policy.jl">Load <code>set_policy.jl</code></a><a id="Load-set_policy.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Load-set_policy.jl" title="Permalink"></a></h2><p>The model contains a number of switch variables to control which monetary policy function is used and which fiscal policy function is used at each period of the simulation. For convenience, we have included functions <code>set_mp!()</code> and <code>set_fp!()</code>, which are defined in <a href="../set_policy.jl"><code>set_policy.jl</code></a>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; include(&quot;set_policy.jl&quot;)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @doc set_mp!</code><code class="nohighlight hljs ansi" style="display:block;">  set_mp!(data, switch[, range])

  Set the monetary policy function over the given range. The given switch is
  set to 1 and all other monetary policy switches are set to 0. If range is
  not given, the switch is set over the full range of the data.

  The set of valid switch values is in dmp_switches.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # these are the mp switches
       dmp_switches</code><code class="nohighlight hljs ansi" style="display:block;">(:dmpintay, :dmptay, :dmptlr, :dmpalt, :dmpgen, :dmpex, :dmprr)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; #  these are their descriptions
       for s in dmp_switches
           v = filter(x -&gt; x.name == s, m.variables)[1]
           println(&quot;$s : \t$(v.doc)&quot;)
       end</code><code class="nohighlight hljs ansi" style="display:block;">dmpintay : 	Monetary policy switch:  inertial taylor rule
dmptay : 	Monetary policy switch:  Taylor&#39;s reaction function
dmptlr : 	Monetary policy switch:  Taylor&#39;s reaction function with unemployment gap
dmpalt : 	Monetary policy switch: MA rule
dmpgen : 	Monetary policy switch:  Generalized reaction function
dmpex : 	Monetary policy switch:  exogenous federal funds rate
dmprr : 	Monetary policy switch:  exogenous real federal funds rate</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @doc set_fp!</code><code class="nohighlight hljs ansi" style="display:block;">  set_fp!(data, switch[, range])

  Set the fiscal policy function over the given range. The given switch is set
  to 1 and all other fiscal policy switches are set to 0. If range is not
  given, the switch is set over the full range of the data.

  The set of valid switch values is in dfp_switches.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # these are the fp switches
       dfp_switches</code><code class="nohighlight hljs ansi" style="display:block;">(:dfpex, :dfpsrp, :dfpdbt)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # these are their descriptions
       for s in dfp_switches
           v = filter(x -&gt; x.name == s, m.variables)[1]
           println(&quot;$s : \t$(v.doc)&quot;)
       end</code><code class="nohighlight hljs ansi" style="display:block;">dfpex : 	Fiscal policy switch:  1 for exogenous personal income trend tax rates
dfpsrp : 	Fiscal policy switch:  1 for surplus ratio stabilization
dfpdbt : 	Fiscal policy switch:  1 for debt ratio stabilization</code></pre><h2 id="Prepare-the-Simulation-Plan"><a class="docs-heading-anchor" href="#Prepare-the-Simulation-Plan">Prepare the Simulation Plan</a><a id="Prepare-the-Simulation-Plan-1"></a><a class="docs-heading-anchor-permalink" href="#Prepare-the-Simulation-Plan" title="Permalink"></a></h2><p>The simulation is controlled by a <a href="../../../Reference/StateSpaceEcon/#StateSpaceEcon.Plans.Plan"><code>Plan</code></a> object. The plan is defined by a model object and a simulation range. The full range handled by the plan contains additional periods before and after the simulation range, which account for initial and final conditions. By default, the simulation plan is setup such that all shocks are exogenous and all variables are endogenous, except for the variables that are declared either in an <code>@exogenous</code> block or with the <code>@exog</code> declaration within an <code>@variables</code> block in the model file.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sim = 2022Q1:2027Q4     # simulation range</code><code class="nohighlight hljs ansi" style="display:block;">2022Q1:2027Q4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; p = Plan(m, sim)        # the plan object</code><code class="nohighlight hljs ansi" style="display:block;">Plan{MIT{Quarterly{3}}} with range 2018Q2:2027Q4
  2018Q2:2027Q4 → adjlegrt, d79a, d8095, d83, d87, ddockm, ddockx, deuc, …</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ini = firstdate(p):first(sim) - 1      # range of initial conditions</code><code class="nohighlight hljs ansi" style="display:block;">2018Q2:2021Q4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fin = last(sim) + 1:lastdate(p)        # range of final conditions</code><code class="nohighlight hljs ansi" style="display:block;">2028Q1:2027Q4</code></pre><p>Note that the <code>fin</code> range is actually empty. This is because this model doesn&#39;t have any leads.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; isempty(fin)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h2 id="Prepare-the-Exogenous-Data"><a class="docs-heading-anchor" href="#Prepare-the-Exogenous-Data">Prepare the Exogenous Data</a><a id="Prepare-the-Exogenous-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Prepare-the-Exogenous-Data" title="Permalink"></a></h2><p>We start by pre-allocating simulation data that is set to 0 everywhere.  Then we assign within it the data from <code>longbase</code> using Julia&#39;s <code>.=</code> operator.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ed = zerodata(m, p);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ed .= longbase[p.range];</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>Next we set the monetary policy, the fiscal policy and a few other switches.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; # set monetary policy (Inertial Taylor Rule)
       set_mp!(ed, :dmpintay);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # turn off zero bound and policy thresholds;
       # hold policy maker&#39;s perceived equilibrium real interest rate
       ed.dmptrsh .= 0.0;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ed.rffmin .= -9999;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ed.drstar .= 0.0;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # set fiscal policy (Surplus Ratio Stabilization)
       set_fp!(ed, :dfpsrp);</code><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;"></code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><h2 id="Back-out-the-Shocks"><a class="docs-heading-anchor" href="#Back-out-the-Shocks">Back out the Shocks</a><a id="Back-out-the-Shocks-1"></a><a class="docs-heading-anchor-permalink" href="#Back-out-the-Shocks" title="Permalink"></a></h2><p>The first simulation test is to compute the shocks given the variable paths from <code>longbase</code>. To do this, we swap the variables and shocks, making variables exogenous and shocks endogenous. The mapping between variables and their corresponding shocks is declared in the model file, so we can simply call <a href="../../../Reference/StateSpaceEcon/#StateSpaceEcon.Plans.autoexogenize!-Tuple{Plan, Model, Any}"><code>autoexogenize!</code></a>. We make a copy of the plan <code>p</code>, so that the original plan would not be modified. We also make a copy of the exogenous data, <code>ed</code>, so that the original would remain unchanged.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; p_0 = autoexogenize!(copy(p), m, sim)</code><code class="nohighlight hljs ansi" style="display:block;">Plan{MIT{Quarterly{3}}} with range 2018Q2:2027Q4
  2018Q2:2021Q4 → adjlegrt, d79a, d8095, d83, d87, ddockm, ddockx, deuc, …
  2022Q1:2027Q4 → delrff, dpgap, ebfin, ecnian, egfen, egfln, egsen, egsln, …</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ed_0 = copy(ed)</code><code class="nohighlight hljs ansi" style="display:block;">39×651 MVTSeries{Quarterly} with range 2018Q2:2027Q4 and variables (delrff,…):
           delrff       dpgap        … zyhst_a     zyhtst_a
  2018Q2 :  0.289284     0.00069891  … 0.0         0.0
  2018Q3 :  0.186305     0.00051661  … 0.0         0.0
  2018Q4 :  0.293605     0.000629633 … 0.0         0.0
  2019Q1 :  0.184215    -0.000929157 … 0.0         0.0
  2019Q2 : -0.00349898   0.000139446 … 0.0         0.0
  2019Q3 : -0.2         -0.000163501 … 0.0         0.0
  2019Q4 : -0.547329     0.000976262 … 0.0         0.0
  2020Q1 : -0.417581    -0.000343449 … 0.0         0.0
  2020Q2 : -1.17415     -0.00277455  … 0.0         0.0
           ⋮            ⋮            ⋱ ⋮           ⋮
  2025Q4 : -0.273057     0.000784251 … 0.0         0.0
  2026Q1 : -0.136529     0.000843528 … 0.0         0.0
  2026Q2 : -0.0497604    0.000882637 … 0.0         0.0
  2026Q3 : -0.0422963    0.000896193 … 0.0         0.0
  2026Q4 : -0.0359519    0.000886621 … 0.0         0.0
  2027Q1 : -0.0305591    0.000857853 … 0.0         0.0
  2027Q2 : -0.0259752    0.000811801 … 0.0         0.0
  2027Q3 : -0.0220789    0.000750954 … 0.0         0.0
  2027Q4 : -0.0187671    0.000678757 … 0.0         0.0</code></pre><p>Now we run the <a href="../../../Reference/StateSpaceEcon/#StateSpaceEcon.simulate"><code>simulate</code></a> command. Note that the first time we run a function in Julia it takes a bit longer due to compilation time. In this case, it takes much longer because the model is very large and each and every equation gets compiled together with its automatic derivative.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sol_0 = @time simulate(m, p_0, ed_0; verbose=true, tol=1e-12);</code><code class="nohighlight hljs ansi" style="display:block;">[ Info: Simulating 2022Q1:2027Q4
[ Info: 1, || Fx || = 10.853465085036248, || Δx || = 10.853465085036248
[ Info: 2, || Fx || = 1.0186340659856796e-10, || Δx || = 1.663794833867629e-13
 11.006712 seconds (2.65 M allocations: 149.207 MiB, 0.35% gc time, 98.77% compilation time)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test sol_0[m.variables] ≈ ed[m.variables]</code><code class="nohighlight hljs ansi" style="display:block;">Test Passed
  Expression: sol_0[m.variables] ≈ ed[m.variables]
   Evaluated: 39×367 MVTSeries{Quarterly} with range 2018Q2:2027Q4 and variables (delrff,…):
           delrff       dpgap        … uyni     uyp      ymsdn
  2018Q2 :  0.289284     0.00069891  … 1.0      1.012    0.0
  2018Q3 :  0.186305     0.00051661  … 1.0      1.01196  0.0
  2018Q4 :  0.293605     0.000629633 … 1.0      1.01192  0.0
  2019Q1 :  0.184215    -0.000929157 … 1.0      1.01164  0.0
  2019Q2 : -0.00349898   0.000139446 … 1.0      1.01188  0.0
  2019Q3 : -0.2         -0.000163501 … 1.0      1.01161  0.0
  2019Q4 : -0.547329     0.000976262 … 1.0      1.01171  0.0
  2020Q1 : -0.417581    -0.000343449 … 1.0      1.01121  0.0
  2020Q2 : -1.17415     -0.00277455  … 1.0      1.01041  0.0
           ⋮            ⋮            ⋱ ⋮        ⋮        ⋮
  2025Q4 : -0.273057     0.000784251 … 1.0      1.01064  0.0
  2026Q1 : -0.136529     0.000843528 … 1.0      1.01064  0.0
  2026Q2 : -0.0497604    0.000882637 … 1.0      1.01064  0.0
  2026Q3 : -0.0422963    0.000896193 … 1.0      1.01064  0.0
  2026Q4 : -0.0359519    0.000886621 … 1.0      1.01064  0.0
  2027Q1 : -0.0305591    0.000857853 … 1.0      1.01064  0.0
  2027Q2 : -0.0259752    0.000811801 … 1.0      1.01064  0.0
  2027Q3 : -0.0220789    0.000750954 … 1.0      1.01064  0.0
  2027Q4 : -0.0187671    0.000678757 … 1.0      1.01064  0.0      ≈ 39×367 MVTSeries{Quarterly} with range 2018Q2:2027Q4 and variables (delrff,…):
           delrff       dpgap        … uyni     uyp      ymsdn
  2018Q2 :  0.289284     0.00069891  … 1.0      1.012    0.0
  2018Q3 :  0.186305     0.00051661  … 1.0      1.01196  0.0
  2018Q4 :  0.293605     0.000629633 … 1.0      1.01192  0.0
  2019Q1 :  0.184215    -0.000929157 … 1.0      1.01164  0.0
  2019Q2 : -0.00349898   0.000139446 … 1.0      1.01188  0.0
  2019Q3 : -0.2         -0.000163501 … 1.0      1.01161  0.0
  2019Q4 : -0.547329     0.000976262 … 1.0      1.01171  0.0
  2020Q1 : -0.417581    -0.000343449 … 1.0      1.01121  0.0
  2020Q2 : -1.17415     -0.00277455  … 1.0      1.01041  0.0
           ⋮            ⋮            ⋱ ⋮        ⋮        ⋮
  2025Q4 : -0.273057     0.000784251 … 1.0      1.01064  0.0
  2026Q1 : -0.136529     0.000843528 … 1.0      1.01064  0.0
  2026Q2 : -0.0497604    0.000882637 … 1.0      1.01064  0.0
  2026Q3 : -0.0422963    0.000896193 … 1.0      1.01064  0.0
  2026Q4 : -0.0359519    0.000886621 … 1.0      1.01064  0.0
  2027Q1 : -0.0305591    0.000857853 … 1.0      1.01064  0.0
  2027Q2 : -0.0259752    0.000811801 … 1.0      1.01064  0.0
  2027Q3 : -0.0220789    0.000750954 … 1.0      1.01064  0.0
  2027Q4 : -0.0187671    0.000678757 … 1.0      1.01064  0.0</code></pre><p>The compilation is done once and the compiled code is used in every call after that. So the second call to <a href="../../../Reference/StateSpaceEcon/#StateSpaceEcon.simulate"><code>simulate</code></a> is much, much faster.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sol_0 = @time simulate(m, p_0, ed_0; verbose=true, tol=1e-12);</code><code class="nohighlight hljs ansi" style="display:block;">[ Info: Simulating 2022Q1:2027Q4
[ Info: 1, || Fx || = 10.853465085036248, || Δx || = 10.853465085036248
[ Info: 2, || Fx || = 1.0186340659856796e-10, || Δx || = 1.663794833867629e-13
  0.135918 seconds (535.31 k allocations: 45.702 MiB, 22.77% gc time)</code></pre><h2 id="Recover-the-Baseline-Case"><a class="docs-heading-anchor" href="#Recover-the-Baseline-Case">Recover the Baseline Case</a><a id="Recover-the-Baseline-Case-1"></a><a class="docs-heading-anchor-permalink" href="#Recover-the-Baseline-Case" title="Permalink"></a></h2><p>Next simulation is a sanity check test. If we run a simulation with the shocks set to the values we just backed out, the resulting variable paths must match the ones we started with.</p><p>Once again we start with an exogenous data set everywhere to 0. Then we assign only the initial conditions and the shocks we just backed out.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; p_r = Plan(m, sim);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ed_r = zerodata(m, p_r);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # initial conditions for the variables are taken from longbase
       ed_r[ini, m.variables] .= longbase[ini, m.variables];</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # shocks are taken from from sol_0
       ed_r[p_r.range, m.shocks] .= sol_0[p_r.range, m.shocks];</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # exogenous variables are also taken  from sol_0
       exogenous = [v for v in m.variables if isexog(v)];</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ed_r[p_r.range, exogenous] .= sol_0[p_r.range, exogenous];</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>Now, the only thing left is to set the initial guess for the endogenous variables. If we leave it at 0, that would be an initial guess too far from the solution and the Newton-Raphson will likely diverge. If we set it to the known solution, that would diminish this exercise to merely verifying that it is indeed a solution (we already know that). So, to make things a bit more interesting, we add a bit of noise to the true solution.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; endogenous = [v for v in m.variables if !isexog(v)];</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ed_r[sim, endogenous] .= longbase[sim, endogenous] .+ 0.03.*randn(length(sim), length(endogenous));</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>Once again we have to set the monetary policy and the fiscal policy rules, as well as the values of some of the other switches.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; set_mp!(ed_r, :dmpintay);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ed_r.dmptrsh .= 0.0;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ed_r.rffmin .= -9999;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ed_r.drstar .= 0.0;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; set_fp!(ed_r, :dfpsrp);</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>And finally we can run the simulation and check to make sure that indeed the recovered simulation matches the base case.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; sol_r = @time simulate(m, p_r, ed_r; verbose=true, tol=1e-9);</code><code class="nohighlight hljs ansi" style="display:block;">[ Info: Simulating 2022Q1:2027Q4
[ Info: 1, || Fx || = 2090.051818221041, || Δx || = 2422.557083910862
[ Info: 2, || Fx || = 169.08344092464358, || Δx || = 2393.9401900237353
[ Info: 3, || Fx || = 83.7568979209027, || Δx || = 81.16208323737386
[ Info: 4, || Fx || = 0.7982482461020481, || Δx || = 0.2285593824723709
[ Info: 5, || Fx || = 9.340475207864074e-5, || Δx || = 9.475599198599772e-6
[ Info: 6, || Fx || = 1.8917489796876907e-10
  0.753649 seconds (1.22 M allocations: 223.475 MiB, 6.19% gc time)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test sol_r ≈ sol_0</code><code class="nohighlight hljs ansi" style="display:block;">Test Passed
  Expression: sol_r ≈ sol_0
   Evaluated: 39×651 MVTSeries{Quarterly} with range 2018Q2:2027Q4 and variables (delrff,…):
           delrff       dpgap        … zyhst_a       zyhtst_a
  2018Q2 :  0.289284     0.00069891  …  0.0           0.0
  2018Q3 :  0.186305     0.00051661  …  0.0           0.0
  2018Q4 :  0.293605     0.000629633 …  0.0           0.0
  2019Q1 :  0.184215    -0.000929157 …  0.0           0.0
  2019Q2 : -0.00349898   0.000139446 …  0.0           0.0
  2019Q3 : -0.2         -0.000163501 …  0.0           0.0
  2019Q4 : -0.547329     0.000976262 …  0.0           0.0
  2020Q1 : -0.417581    -0.000343449 …  0.0           0.0
  2020Q2 : -1.17415     -0.00277455  …  0.0           0.0
           ⋮            ⋮            ⋱ ⋮             ⋮
  2025Q4 : -0.273057     0.000784251 … -0.000139393  -1.75781e-5
  2026Q1 : -0.136529     0.000843528 … -0.000125454  -1.58203e-5
  2026Q2 : -0.0497604    0.000882637 … -0.000119181  -1.50293e-5
  2026Q3 : -0.0422963    0.000896193 … -0.000113222  -1.42778e-5
  2026Q4 : -0.0359519    0.000886621 … -0.000107561  -1.35639e-5
  2027Q1 : -0.0305591    0.000857853 … -0.000102183  -1.28857e-5
  2027Q2 : -0.0259752    0.000811801 … -9.70738e-5   -1.22414e-5
  2027Q3 : -0.0220789    0.000750954 … -9.22201e-5   -1.16294e-5
  2027Q4 : -0.0187671    0.000678757 … -8.76091e-5   -1.10479e-5  ≈ 39×651 MVTSeries{Quarterly} with range 2018Q2:2027Q4 and variables (delrff,…):
           delrff       dpgap        … zyhst_a       zyhtst_a
  2018Q2 :  0.289284     0.00069891  …  0.0           0.0
  2018Q3 :  0.186305     0.00051661  …  0.0           0.0
  2018Q4 :  0.293605     0.000629633 …  0.0           0.0
  2019Q1 :  0.184215    -0.000929157 …  0.0           0.0
  2019Q2 : -0.00349898   0.000139446 …  0.0           0.0
  2019Q3 : -0.2         -0.000163501 …  0.0           0.0
  2019Q4 : -0.547329     0.000976262 …  0.0           0.0
  2020Q1 : -0.417581    -0.000343449 …  0.0           0.0
  2020Q2 : -1.17415     -0.00277455  …  0.0           0.0
           ⋮            ⋮            ⋱ ⋮             ⋮
  2025Q4 : -0.273057     0.000784251 … -0.000139393  -1.75781e-5
  2026Q1 : -0.136529     0.000843528 … -0.000125454  -1.58203e-5
  2026Q2 : -0.0497604    0.000882637 … -0.000119181  -1.50293e-5
  2026Q3 : -0.0422963    0.000896193 … -0.000113222  -1.42778e-5
  2026Q4 : -0.0359519    0.000886621 … -0.000107561  -1.35639e-5
  2027Q1 : -0.0305591    0.000857853 … -0.000102183  -1.28857e-5
  2027Q2 : -0.0259752    0.000811801 … -9.70738e-5   -1.22414e-5
  2027Q3 : -0.0220789    0.000750954 … -9.22201e-5   -1.16294e-5
  2027Q4 : -0.0187671    0.000678757 … -8.76091e-5   -1.10479e-5</code></pre><h2 id="Simulate-a-shock"><a class="docs-heading-anchor" href="#Simulate-a-shock">Simulate a shock</a><a id="Simulate-a-shock-1"></a><a class="docs-heading-anchor-permalink" href="#Simulate-a-shock" title="Permalink"></a></h2><p>The last exercise is to simulate the impulse response to a unit shock in <code>rffintay</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; m.rffintay</code><code class="nohighlight hljs ansi" style="display:block;">&quot;Value of eff. federal funds rate given by the inertial Taylor rule&quot; rffintay</code></pre><p>We start with the base case and add 1 to the <code>rffintay_a</code> shock at the first period of the simulation.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; p_1 = Plan(m, sim);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ed_1 = copy(sol_0);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ed_1.rffintay_a[first(sim)] += 1;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sol_1 = @time simulate(m, p_1, ed_1; verbose=true, tol=1e-9);</code><code class="nohighlight hljs ansi" style="display:block;">[ Info: Simulating 2022Q1:2027Q4
[ Info: 1, || Fx || = 1.0, || Δx || = 5299.663208477446
[ Info: 2, || Fx || = 348.8940862391828, || Δx || = 337.8388824925491
[ Info: 3, || Fx || = 0.21547953273693565, || Δx || = 0.012655202085606212
[ Info: 4, || Fx || = 1.080850470458472e-5, || Δx || = 7.94561095960442e-7
[ Info: 5, || Fx || = 2.1827872842550278e-10
  0.616985 seconds (1.05 M allocations: 188.718 MiB, 5.54% gc time)</code></pre><p>Finally, we can plot the impulse response function to see what we&#39;ve done.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; # compute the differences between the base case and the shocked simulation.
       dd = MVTSeries(p.range;
           d_rff=sol_1.rff - sol_0.rff,
           d_rg10=sol_1.rg10 - sol_0.rg10,
           d_lur=sol_1.lur - sol_0.lur,
           d_pic4=sol_1.pic4 - sol_0.pic4,
       );</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # produce the plot
       plt = plot(dd, trange=sim, vars=(:d_rff, :d_rg10, :d_lur, :d_pic4),
           legend=false, size=(900, 600),  linewidth=1.5,
           titlefontsize=8
       );</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot!(plt[1,1], title=&quot;d_rff: $(m.rff.doc) (s-c)&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot!(plt[1,2], title=&quot;d_rg10: $(m.rg10.doc) (s-c)&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot!(plt[2,1], title=&quot;d_lur: $(m.lur.doc) (s-c)&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot!(plt[2,2], title=&quot;d_pic4: $(m.pic4.doc) (s-c)&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; plt</code><code class="nohighlight hljs ansi" style="display:block;">Plot{Plots.GRBackend() n=4}
Captured extra kwargs:
  Series{1}:
    trange: 2022Q1:2027Q4
    vars: (:d_rff, :d_rg10, :d_lur, :d_pic4)
  Series{2}:
    trange: 2022Q1:2027Q4
    vars: (:d_rff, :d_rg10, :d_lur, :d_pic4)
  Series{3}:
    trange: 2022Q1:2027Q4
    vars: (:d_rff, :d_rg10, :d_lur, :d_pic4)
  Series{4}:
    trange: 2022Q1:2027Q4
    vars: (:d_rff, :d_rg10, :d_lur, :d_pic4)</code></pre><p><a href="../irf.png"><img src="../irf.png" alt="Impulse Response Graph"/></a></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../3.US_SW07/main/">« Smets and Wouters 2007</a><a class="docs-footer-nextpage" href="../../../Reference/TimeSeriesEcon/">TimeSeriesEcon »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 20 July 2023 16:14">Thursday 20 July 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
